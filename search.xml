<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>提高程序运行效率</title>
      <link href="/2023/07/03/Efficiency/"/>
      <url>/2023/07/03/Efficiency/</url>
      
        <content type="html"><![CDATA[<p>提高效率的技巧</p><span id="more"></span><p><a href="https://www.erlang.org/doc/efficiency_guide/users_guide.html">Erlang – Efficiency Guide</a></p><h1 id="Erlang性能的7个传说"><a href="#Erlang性能的7个传说" class="headerlink" title="Erlang性能的7个传说"></a>Erlang性能的7个传说</h1><ol><li>尾递归比递归快得多</li><li><code>++</code>总是很差</li><li>String很慢</li><li>修复<strong>Dets</strong> 文件很慢</li><li>BEAM是基于堆栈的字节码虚拟机，因此很慢</li><li>不用的变量用<code>_</code>标记</li><li><strong>NIF</strong> 总是比自己写快</li></ol><p>另外，还有以下几个已经过时的传说</p><ol><li>Funs很慢</li><li>列表推导很慢</li><li><code>--</code>很慢</li></ol><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>与普通递归相比，由于尾递归的调用处于方法的最后，因此方法之前所积累下的各种状态对于递归调用结果已经没有任何意义，因此完全可以把本次方法中留在堆栈中的数据完全清除，把空间让给最后的递归调用。这样的优化便使得递归不会在调用堆栈上产生堆积，意味着即时是“无限”递归也不会让堆栈溢出。这便是尾递归的优势。</p><p>尾递归的本质，其实是将递归方法中的需要的“所有状态”通过方法的参数传入下一次调用中，通过参数传递结果，达到不压栈的目的。</p><h3 id="递归改写为尾递归的方法"><a href="#递归改写为尾递归的方法" class="headerlink" title="递归改写为尾递归的方法"></a>递归改写为尾递归的方法</h3><p>将普通递归函数改写为尾递归函数，需要引入一个额外的累积参数（accumulator），用于保存中间结果并在递归调用中传递。这样，在每次递归调用时，不再产生新的堆栈帧，而是更新累积参数的值，直到达到终止条件。以下是将普通递归函数改写为尾递归函数的一般步骤：</p><ol><li>引入一个额外的累积参数，用于保存中间结果。</li><li>将递归函数的终止条件作为尾递归函数的终止条件，并将累积参数作为返回值返回。</li><li>在递归调用中，更新累积参数的值，并继续递归调用。</li></ol><p>以下是一个示例，将普通递归的阶乘函数改写为尾递归函数：</p><p>普通递归示例（阶乘函数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fact(0) -&gt; 1;</span><br><span class="line">fact(N) -&gt; N * fact(N - 1).</span><br></pre></td></tr></table></figure><p>尾递归示例（阶乘函数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fact(N) -&gt; fact(N, 1).</span><br><span class="line"></span><br><span class="line">fact(0, Acc) -&gt; Acc;</span><br><span class="line">fact(N, Acc) -&gt; fact(N - 1, N * Acc).</span><br></pre></td></tr></table></figure><p>在尾递归的示例中，<code>fact/2</code> 函数接受两个参数：<code>N</code> 表示要计算阶乘的数，<code>Acc</code> 表示累积的结果。递归调用发生在每次迭代时，通过更新参数 <code>N</code> 和 <code>Acc</code> 来进行下一次迭代，直到达到终止条件 <code>N = 0</code>。最终结果直接返回给调用者，没有进行任何后续计算。</p><p>通过将普通递归改写为尾递归，可以避免堆栈溢出的风险，并允许尾递归函数以迭代的方式执行，从而提高性能和资源利用率。</p><h2 id="String的处理方法"><a href="#String的处理方法" class="headerlink" title="String的处理方法"></a>String的处理方法</h2><p>在 Erlang 中，处理字符串的性能可以通过以下几个方法来改善：</p><ol><li>避免频繁的字符串拼接：Erlang 中的字符串是不可变的，每次字符串拼接都会创建一个新的字符串，这会导致性能下降。相反，可以使用列表来构建字符串，然后使用 <code>lists:flatten/1</code> 函数将列表转换为字符串。这样可以减少字符串拼接的开销。<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 不推荐的方法：频繁字符串拼接</span></span><br><span class="line">Str1 = <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">Str2 = <span class="string">&quot;World&quot;</span>,</span><br><span class="line">Result = Str1 ++ Str2.</span><br><span class="line"></span><br><span class="line"><span class="comment">% 推荐的方法：使用列表构建字符串，然后使用 lists:flatten/1 转换为字符串</span></span><br><span class="line">StrList = [<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>],</span><br><span class="line">Result = lists:flatten(StrList).</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li>使用二进制而不是字符串：在处理大量数据时，使用 Erlang 的二进制（<code>&lt;&lt;&gt;&gt;</code>）来表示字符串会更高效，因为二进制操作是原子的，可以更快地进行匹配和处理。可以使用 <code>&lt;&lt;Str/binary&gt;&gt;</code> 语法将字符串转换为二进制，使用 <code>binary_to_list/1</code> 将二进制转换为字符串。<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 使用二进制表示字符串</span></span><br><span class="line">StrBinary = &lt;&lt;<span class="string">&quot;Hello&quot;</span>&gt;&gt;.</span><br><span class="line"></span><br><span class="line"><span class="comment">% 将二进制转换为字符串</span></span><br><span class="line">Str = binary_to_list(StrBinary).</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li>避免频繁的字符查找和替换：如果需要在字符串中查找或替换字符，最好使用二进制模式匹配和替换，而不是使用字符串函数。字符串函数通常需要遍历整个字符串，而二进制模式匹配可以更快地找到目标字符。<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 不推荐的方法：使用字符串函数进行字符替换</span></span><br><span class="line">Str = <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">NewStr = string:replace(Str, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;Universe&quot;</span>).</span><br><span class="line"></span><br><span class="line"><span class="comment">% 推荐的方法：使用二进制模式匹配进行字符替换</span></span><br><span class="line">StrBinary = &lt;&lt;<span class="string">&quot;Hello World&quot;</span>&gt;&gt;,</span><br><span class="line">NewStrBinary = &lt;&lt;(&lt;&lt;<span class="string">&quot;Universe&quot;</span>&gt;&gt;/binary):<span class="number">8</span>/binary&gt;&gt;.</span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li>使用 <code>string</code> 模块进行字符串处理：Erlang 的 <code>string</code> 模块提供了一些针对字符串的优化函数，例如 <code>string:to_upper/1</code> 和 <code>string:to_lower/1</code> 可以高效地转换字符串的大小写。在需要频繁操作字符串的场景中，使用这些优化函数可以提高性能。<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 使用 string:to_upper/1 转换字符串为大写</span></span><br><span class="line">Str = <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">UpperStr = string:to_upper(Str).</span><br><span class="line"></span><br><span class="line"><span class="comment">% 使用 string:substr/3 获取字符串的子串</span></span><br><span class="line">Str = <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">SubStr = string:substr(Str, <span class="number">7</span>, <span class="number">5</span>).</span><br></pre></td></tr></table></figure></li></ol><ol start="5"><li>避免不必要的字符串复制：在处理字符串时，尽量避免不必要的字符串复制。例如，可以使用 <code>string:substr/3</code> 函数来获取字符串的子串，而不是创建一个新的字符串。<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 不推荐的方法：创建一个新的字符串副本</span></span><br><span class="line">Str = <span class="string">&quot;Hello World&quot;</span>,</span><br><span class="line">SubStr = string:substr(Str, <span class="number">7</span>, <span class="number">5</span>).</span><br><span class="line"></span><br><span class="line"><span class="comment">% 推荐的方法：使用二进制模式匹配获取子串</span></span><br><span class="line">StrBinary = &lt;&lt;<span class="string">&quot;Hello World&quot;</span>&gt;&gt;,</span><br><span class="line">SubStrBinary = &lt;&lt;StrBinary/binary, <span class="number">7</span>:<span class="number">5</span>&gt;&gt;.</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li>使用 NIF 或 Port：如果有对性能要求非常高的字符串处理任务，可以考虑使用 NIF（Native Implemented Function）或 Port（进程间通信）来实现。NIF 允许通过 C 代码编写高效的原生函数，而 Port 允许与其他编程语言进行交互。</li></ol><p><code>string_utils.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;erl_nif.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> ERL_NIF_TERM <span class="title">to_upper_nif</span><span class="params">(ErlNifEnv* env, <span class="keyword">int</span> argc, <span class="keyword">const</span> ERL_NIF_TERM argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ErlNifBinary input_binary;</span><br><span class="line">    enif_inspect_binary(env, argv[<span class="number">0</span>], &amp;input_binary);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* input_str = (<span class="keyword">char</span>*) input_binary.data;</span><br><span class="line">    <span class="keyword">size_t</span> input_len = input_binary.size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* output_str = (<span class="keyword">char</span>*) enif_alloc(input_len + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">strncpy</span>(output_str, input_str, input_len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; input_len; i++) &#123;</span><br><span class="line">        output_str[i] = <span class="built_in">toupper</span>(output_str[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ERL_NIF_TERM output_binary;</span><br><span class="line">    enif_alloc_binary(input_len, &amp;output_binary);</span><br><span class="line">    <span class="built_in">memcpy</span>(output_binary.data, output_str, input_len);</span><br><span class="line"></span><br><span class="line">    enif_free(output_str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output_binary;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> ErlNifFunc nif_funcs[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;to_upper&quot;</span>, <span class="number">1</span>, to_upper_nif&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ERL_NIF_INIT(Elixir.StringUtils.Nif, nif_funcs, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>总的来说，避免频繁的字符串拼接、使用二进制、避免不必要的字符查找和替换以及使用合适的优化函数可以提高 Erlang 中字符串处理的性能。</p><h1 id="常见注意事项"><a href="#常见注意事项" class="headerlink" title="常见注意事项"></a>常见注意事项</h1><h1 id="Binaries的构造和匹配"><a href="#Binaries的构造和匹配" class="headerlink" title="Binaries的构造和匹配"></a>Binaries的构造和匹配</h1><h1 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h1><h1 id="List-Handling"><a href="#List-Handling" class="headerlink" title="List Handling"></a>List Handling</h1><h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>supervisor</title>
      <link href="/2023/07/02/supervisor/"/>
      <url>/2023/07/02/supervisor/</url>
      
        <content type="html"><![CDATA[<p>介绍四大行为模式之一的supervisor</p><span id="more"></span><p>supervisor负责启动、停止、监控子进程。</p><h2 id="启动和监控子进程"><a href="#启动和监控子进程" class="headerlink" title="启动和监控子进程"></a>启动和监控子进程</h2><p>主要通过各种<strong>配置</strong>来指定监控的策略。</p><ul><li>start_child(SupRef, ChildSpec) -&gt; startchild_ret()<ul><li>SupRef 监控者的引用，可以是Pid、注册名等</li><li>ChildSpec</li></ul></li><li>start_link(Module, Args) -&gt; startlink_ret()</li><li>start_link(SupName, Module, Args) -&gt; startlink_ret()<ul><li>Pid、注册名等</li><li>Module 通过回调函数的init来查找启动策略</li><li>startlink_ret<ul><li>{ok, pid()} </li><li>ignore </li><li>{error, startlink_err()}</li></ul></li><li>Args 对应Module:init的Args </li></ul></li><li>Module:init(Args) -&gt; Result<ul><li>Result<ul><li>{ok,{SupFlags,[ChildSpec]}}</li><li>ignore</li><li>SupFlags表示监督者配置<br>ChildSpecs是子进程标识列表，子进程标识ChildSpec是特殊的Map，后面有具体的例子</li></ul></li></ul></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(ch_sup)</span>.</span><br><span class="line"><span class="keyword">-behaviour</span><span class="params">(supervisor)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>])</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    supervisor:start_link(ch_sup, []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">init</span><span class="params">(_Args)</span> -&gt;</span></span><br><span class="line">    SupFlags = #&#123;strategy =&gt; one_for_one, intensity =&gt; <span class="number">1</span>, period =&gt; <span class="number">5</span>&#125;,</span><br><span class="line">    ChildSpecs = [#&#123;id =&gt; ch3,</span><br><span class="line">                    start =&gt; &#123;ch3, start_link, []&#125;,</span><br><span class="line">                    restart =&gt; permanent,</span><br><span class="line">                    shutdown =&gt; brutal_kill,</span><br><span class="line">                    type =&gt; worker,</span><br><span class="line">                    modules =&gt; [ch3]&#125;],</span><br><span class="line">    &#123;ok, &#123;SupFlags, ChildSpecs&#125;&#125;.</span><br></pre></td></tr></table></figure><h3 id="SupFlags"><a href="#SupFlags" class="headerlink" title="SupFlags"></a>SupFlags</h3><ul><li>strategy 重启策略 <ul><li>one_for_all 若一个子进程终止，终止所有子进程并重启所有子进程</li><li>one_for_one <strong>默认</strong>策略，若一个子进程终止，只有该进程会重启</li><li>rest_for_one 若一个子进程终止，终止该进程以后启动的所有子进程（ChildSpecs中指定的顺序）并重启所有终止的子进程</li><li>simple_one_for_one 简化的one_for_one 策略，监督者不启动子进程，而是在运行中使用<code>supervisor:start_child(Sup, List)</code>函数添加</li></ul></li><li>intensity（默认1）和period（默认5） 重启强度<br>监督者在period内重启了intensity次子进程，监督者和子进程都会被终止</li><li>auto_shutdown 当重要的子进程（significant children）关闭时关闭自身 <ul><li>never 默认配置</li><li>any_significant</li><li>all_significant</li></ul></li></ul><h3 id="ChildSpecs"><a href="#ChildSpecs" class="headerlink" title="ChildSpecs"></a>ChildSpecs</h3><ul><li>id 必须配置，用于监督者<strong>内部</strong>标识子进程，常用模块名</li><li>start 必须配置，子进程的启动方法，例：<code>start =&gt; &#123;&#39;AModule&#39;, start_link, []&#125;</code></li><li>restart 何时重启 <ul><li>permanent 总是重启（包括正常关闭）</li><li>transient 非正常终止时重启</li><li>temporary 永不重启</li></ul></li><li>significant 布尔类型，标识重要进程</li><li>shutdown 如何终结这个进程<ul><li>brutal_kill 无条件使用<code>exit(Child, kill)</code>终止</li><li>timeout 通知子进程让其自己关闭，等待接收退出信号，超时没收到信号无条件使用<code>exit(Child, kill)</code>终止</li><li>若子进程是另一个监督者，必须设置为<strong>infinity</strong>来提供足够的关闭时间</li></ul></li><li>type <ul><li>worker</li><li>supervisor</li></ul></li><li>modules</li></ul><p>多个子进程的配置</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></span><br><span class="line">  gen_event:swap_handler(alarm_handler, &#123;alarm_handler, swap&#125;, &#123;my_alarm_handler, xyz&#125;),</span><br><span class="line">  &#123;ok, &#123;&#123;one_for_one, <span class="number">3</span>, <span class="number">10</span>&#125;, <span class="comment">% RestartStrategy MaxRestarts Time</span></span><br><span class="line">    [</span><br><span class="line">      &#123;tag1, <span class="comment">%% worker1</span></span><br><span class="line">        &#123;area_server, start_link, []&#125;,</span><br><span class="line">        permanent,</span><br><span class="line">        <span class="number">10000</span>,</span><br><span class="line">        worker,</span><br><span class="line">        [area_server]&#125;,</span><br><span class="line">      &#123;tag2, <span class="comment">%% worker2</span></span><br><span class="line">        &#123;prime_server, start_link, []&#125;,</span><br><span class="line">        permanent,</span><br><span class="line">        <span class="number">10000</span>,</span><br><span class="line">        worker,</span><br><span class="line">        [prime_server]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;&#125;.</span><br></pre></td></tr></table></figure><p>worker启动格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;Tag, &#123;Mod, Func, ArgList&#125;,</span><br><span class="line">  Restart,</span><br><span class="line">  Shutdown,</span><br><span class="line">  Type,</span><br><span class="line">  [Mod1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="停止子进程"><a href="#停止子进程" class="headerlink" title="停止子进程"></a>停止子进程</h2><ul><li>terminate_child(SupRef, Id) -&gt; Result<br>id是关联子进程的值，通常是子进程的模块名</li><li>delete_child(SupRef, Id) -&gt; Result</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gen_event</title>
      <link href="/2023/07/01/gen_event/"/>
      <url>/2023/07/01/gen_event/</url>
      
        <content type="html"><![CDATA[<p>介绍四大行为模式之一的gen_event</p><span id="more"></span><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="事件概念"><a href="#事件概念" class="headerlink" title="事件概念"></a>事件概念</h2><p>“事件”指的是程序执行过程中发生的某些特定情况或操作，例如用户点击了某个按钮、程序执行了某个操作、系统状态发生了变化等等。</p><p>在服务器端中，事件指的是服务器程序运行过程中发生的特定情况或操作，例如客户端连接到服务器、收到客户端请求、完成数据库操作、定时任务执行等等。</p><p>服务器端的事件通常是预定义的，通过注册事件监听器或回调函数来响应这些事件。当事件被触发时，服务器程序会自动调用相应的监听器或回调函数进行处理。</p><p>服务器端的事件通常用于实现异步处理、任务调度、定时任务等功能。例如，在Web服务器中，当客户端发起请求时，服务器会触发”收到请求”事件，程序员可以通过注册”请求处理器”监听器来处理这个事件，将请求转发给后端处理或返回相应的结果。</p><h2 id="erlang实现事件处理"><a href="#erlang实现事件处理" class="headerlink" title="erlang实现事件处理"></a>erlang实现事件处理</h2><p>实际上是一个特殊的进程，当接收到特定的事件消息时进行相应的处理。</p><p>事件处理器</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(event_handler)</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% API</span></span><br><span class="line"><span class="keyword">-export</span><span class="params">([make/<span class="number">1</span>, add_handler/<span class="number">2</span>, event/<span class="number">2</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 创建事件处理器Name 初始时不执行任何操作（返回void）</span></span><br><span class="line"><span class="function"><span class="title">make</span><span class="params">(Name)</span> -&gt;</span></span><br><span class="line">  register(Name, spawn(<span class="keyword">fun</span>() -&gt; my_handler(fun no_op/1) <span class="keyword">end</span>)).</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 为事件处理器添加一个处理函数Fun。这样当事件X发生时，事件处理器就会执行Fun(X)。</span></span><br><span class="line"><span class="function"><span class="title">add_handler</span><span class="params">(Name, Fun)</span> -&gt;</span></span><br><span class="line">  Name ! &#123;add, Fun&#125;.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 发送事件X到 名为Name的事件处理器</span></span><br><span class="line"><span class="function"><span class="title">event</span><span class="params">(Name, X)</span> -&gt;</span></span><br><span class="line">  Name ! &#123;event, X&#125;.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 服务逻辑</span></span><br><span class="line"><span class="function"><span class="title">my_handler</span><span class="params">(Fun)</span> -&gt;</span></span><br><span class="line">  <span class="keyword">receive</span></span><br><span class="line">    &#123;add, Fun1&#125; -&gt;</span><br><span class="line">      my_handler(Fun1);</span><br><span class="line">    &#123;event, Any&#125; -&gt;</span><br><span class="line">      (<span class="keyword">catch</span> Fun(Any)),</span><br><span class="line">      my_handler(Fun)</span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">no_op</span><span class="params">(_)</span> -&gt;</span> void.</span><br></pre></td></tr></table></figure><p>惯例，把处理函数Fun写在一个回调模块里，可以隐藏处理函数</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(motor_controller)</span>.</span><br><span class="line"><span class="comment">%% 回调模块</span></span><br><span class="line"><span class="comment">%% API</span></span><br><span class="line"><span class="keyword">-export</span><span class="params">([add_event_handler/<span class="number">0</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">add_event_handler</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  event_handler:add_handler(errors, fun controller/1).</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="function"><span class="title">controller</span><span class="params">(too_hot)</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;Turn off the motor~n&quot;</span>);</span><br><span class="line"><span class="function"><span class="title">controller</span><span class="params">(X)</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;~w ignored event: ~p~n&quot;</span>, [?MODULE, X]).</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">% 添加fun</span><br><span class="line">2&gt; event_handler:make(errors).</span><br><span class="line">true</span><br><span class="line">3&gt; event_handler:add_handler(errors, fun(Arg)-&gt;io:format(&quot;Arg is ~w~n&quot;,[Arg]) end).  </span><br><span class="line">add_handler&#123;add,#Fun&lt;erl_eval.44.65746770&gt;&#125;</span><br><span class="line">4&gt; event_handler:event(errors, 1).</span><br><span class="line">Arg is 1</span><br><span class="line">&#123;event,1&#125;</span><br><span class="line"></span><br><span class="line">% 添加回调模块</span><br><span class="line">6&gt; motor_controller:add_event_handler().</span><br><span class="line">add_handler&#123;add,#Fun&lt;motor_controller.0.12439643&gt;&#125;</span><br><span class="line">7&gt; event_handler:event(errors, cold).    </span><br><span class="line">motor_controller ignored event: cold</span><br><span class="line">&#123;event,cold&#125;</span><br><span class="line">8&gt; event_handler:event(errors, too_hot). </span><br><span class="line">Turn off the motor</span><br><span class="line">&#123;event,too_hot&#125;</span><br></pre></td></tr></table></figure><h1 id="gen-event-behaviour"><a href="#gen-event-behaviour" class="headerlink" title="gen_event behaviour"></a>gen_event behaviour</h1><h2 id="和gen-statem里的事件区别"><a href="#和gen-statem里的事件区别" class="headerlink" title="和gen_statem里的事件区别"></a>和gen_statem里的事件区别</h2><p>在Erlang中，事件（Event）是一个通用的概念，它可以用来描述发生在系统中的任何类型的动作或状态变化。在Erlang中，gen_event和gen_fsm都是基于事件驱动的框架，但它们处理事件的方式有所不同。</p><ol><li>gen_event：gen_event是Erlang中的一个事件处理器，用于处理异步事件。gen_event会在一组已注册的回调函数中寻找匹配的函数来处理事件。gen_event可以处理多个事件流，每个事件流都由一个或多个事件源产生。当事件源产生事件时，gen_event会将事件分派给已注册的回调函数进行处理。</li><li>gen_fsm：gen_fsm是Erlang中的一个有限状态机框架，它基于状态转换来处理事件。gen_fsm定义了一组状态和状态转换函数，每个状态都有一组可接受的事件。当事件发生时，gen_fsm会根据当前状态和事件类型来确定下一个状态，并执行相应的状态转换函数。</li></ol><p>总的来说，gen_event和gen_fsm都是基于事件的框架，但它们处理事件的方式有所不同。gen_event是一个通用的事件处理器，用于处理异步事件，而gen_fsm是一个有限状态机框架，用于处理基于状态转换的事件。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ul><li>start() -&gt; Result</li><li>start(EventMgrName | Options) -&gt; Result</li><li>start(EventMgrName, Options) -&gt; Result</li><li>start_link() -&gt; Result</li><li>start_link(EventMgrName | Options) -&gt; Result</li><li>start_link(EventMgrName, Options) -&gt; Result</li><li>start_monitor() -&gt; Result</li><li>start_monitor(EventMgrName | Options) -&gt; Result</li><li>start_monitor(EventMgrName, Options) -&gt; Result</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-spec</span><span class="params">(start_link() -&gt; &#123;ok, pid()&#125; | &#123;error, &#123;already_started, pid()&#125;&#125;)</span>.</span><br><span class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  gen_event:start_link(&#123;local, error_man&#125;).</span><br></pre></td></tr></table></figure><h2 id="添加、删除和替换事件管理器"><a href="#添加、删除和替换事件管理器" class="headerlink" title="添加、删除和替换事件管理器"></a>添加、删除和替换事件管理器</h2><ul><li><p>添加</p><ul><li><p>add_handler(EventMgrRef, Handler, Args) -&gt; Result</p></li><li><p>add_sup_handler(EventMgrRef, Handler, Args) -&gt; Result</p></li><li><p>delete_handler(EventMgrRef, Handler, Args) -&gt; Result</p></li></ul></li><li><p>删除</p><ul><li>delete_handler(EventMgrRef, Handler, Args) -&gt; Result</li></ul></li><li><p>替换</p><ul><li>swap_handler(EventMgrRef, {Handler1,Args1}, {Handler2,Args2}) -&gt; Result<br>* </li></ul></li></ul><h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><ul><li>call(EventMgrRef, Handler, Request) -&gt; Result</li><li>call(EventMgrRef, Handler, Request, Timeout) -&gt; Result</li><li>Module:handle_call(Request, State) -&gt; Result</li></ul><ul><li>sync_notify(EventMgrRef, Event) -&gt; ok</li><li>Module:handle_event(Event, State) -&gt; Result</li></ul><p>自定义alarm handler</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(my_alarm_handler)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-behaviour</span><span class="params">(gen_event)</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% API</span></span><br><span class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>, add_handler/<span class="number">0</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% gen_event callbacks</span></span><br><span class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>, handle_event/<span class="number">2</span>, handle_call/<span class="number">2</span>, handle_info/<span class="number">2</span>, terminate/<span class="number">2</span>,</span></span><br><span class="line"><span class="params">  code_change/<span class="number">3</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-define</span><span class="params">(SERVER, ?MODULE)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-record</span><span class="params">(my_alarm_handler_state, &#123;&#125;)</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% @doc Creates an event manager</span></span><br><span class="line"><span class="keyword">-spec</span><span class="params">(start_link() -&gt; &#123;ok, pid()&#125; | &#123;error, &#123;already_started, pid()&#125;&#125;)</span>.</span><br><span class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  gen_event:start_link(&#123;local, ?SERVER&#125;).</span><br><span class="line"></span><br><span class="line"><span class="comment">%% @doc Adds an event handler</span></span><br><span class="line"><span class="keyword">-spec</span><span class="params">(add_handler() -&gt; ok | &#123;&#x27;EXIT&#x27;, Reason :: term()&#125; | term())</span>.</span><br><span class="line"><span class="function"><span class="title">add_handler</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  gen_event:add_handler(?SERVER, ?MODULE, []).</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%===================================================================</span></span><br><span class="line"><span class="comment">%%% gen_event callbacks</span></span><br><span class="line"><span class="comment">%%%===================================================================</span></span><br><span class="line"><span class="function"><span class="title">init</span><span class="params">(Args)</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;*** my_alarm_handler init:~p~n&quot;</span>, [Args]),</span><br><span class="line">  &#123;ok, <span class="number">0</span>&#125;.</span><br><span class="line"><span class="function"><span class="title">handle_event</span><span class="params">(&#123;set_alarm, tooHot&#125;, N)</span> -&gt;</span></span><br><span class="line">  error_logger:error_msg(<span class="string">&quot;***Tell the Engineer to turn on the fan~n&quot;</span>),</span><br><span class="line">  &#123;ok, N + <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="title">handle_event</span><span class="params">(&#123;clear_alarm, tooHot&#125;, N)</span> -&gt;</span></span><br><span class="line">  error_logger:error_msg(<span class="string">&quot;*** Danger over. turn off the fan~n&quot;</span>),</span><br><span class="line">  &#123;ok, N&#125;;</span><br><span class="line"><span class="function"><span class="title">handle_event</span><span class="params">(Event, N)</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;*** unmatched event:~p~n&quot;</span>, [Event]),</span><br><span class="line">  &#123;ok, N&#125;.</span><br><span class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, N)</span> -&gt;</span></span><br><span class="line">  Reply = N,</span><br><span class="line">  &#123;ok, Reply, N&#125;.</span><br><span class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Info, N)</span> -&gt;</span></span><br><span class="line">  &#123;ok, N&#125;.</span><br><span class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, _N)</span> -&gt;</span> ok.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, State, _Extra)</span> -&gt;</span></span><br><span class="line">  &#123;ok, State&#125;.</span><br></pre></td></tr></table></figure><p>添加到alarm_handler</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\hz\Desktop\ErlangProject\learn-erlang\otp_example&gt; erl -boot start_sasl -config elog3</span><br><span class="line">=PROGRESS REPORT==== 3-Jul-2023::12:08:13.337000 ===</span><br><span class="line">    supervisor: &#123;local,logger_sup&#125;</span><br><span class="line">    started: [&#123;pid,&lt;0.81.0&gt;&#125;,</span><br><span class="line">              &#123;id,error_logger&#125;,</span><br><span class="line">              &#123;mfargs,&#123;error_logger,start_link,[]&#125;&#125;,</span><br><span class="line">              &#123;restart_type,transient&#125;,</span><br><span class="line">              &#123;significant,false&#125;,</span><br><span class="line">              &#123;shutdown,2000&#125;,</span><br><span class="line">              &#123;child_type,worker&#125;]</span><br><span class="line"></span><br><span class="line">=PROGRESS REPORT==== 3-Jul-2023::12:08:13.368000 ===</span><br><span class="line">    supervisor: &#123;local,sasl_safe_sup&#125;</span><br><span class="line">    started: [&#123;pid,&lt;0.84.0&gt;&#125;,</span><br><span class="line">              &#123;id,alarm_handler&#125;,</span><br><span class="line">              &#123;mfargs,&#123;alarm_handler,start_link,[]&#125;&#125;,</span><br><span class="line">              &#123;restart_type,permanent&#125;,</span><br><span class="line">              &#123;significant,false&#125;,</span><br><span class="line">              &#123;restart_type,permanent&#125;,</span><br><span class="line">              &#123;significant,false&#125;,</span><br><span class="line">              &#123;shutdown,2000&#125;,</span><br><span class="line">              &#123;child_type,worker&#125;]</span><br><span class="line"></span><br><span class="line">=PROGRESS REPORT==== 3-Jul-2023::12:08:13.368000 ===</span><br><span class="line">    application: sasl</span><br><span class="line">    started_at: nonode@nohost</span><br><span class="line"></span><br><span class="line">Eshell V12.3.2.2  (abort with ^G)</span><br><span class="line">1&gt; alarm_handler:set_alarm(tooHot).</span><br><span class="line">ok</span><br><span class="line">2&gt; =INFO REPORT==== 3-Jul-2023::12:22:13.423000 ===</span><br><span class="line">    alarm_handler: &#123;set,tooHot&#125;</span><br><span class="line">2&gt; gen_event:swap_handler(alarm_handler, &#123;alarm_handler, swap&#125;, &#123;my_alarm_handler, xyz&#125;).</span><br><span class="line">*** my_alarm_handler init:&#123;xyz,&#123;alarm_handler,[tooHot]&#125;&#125;</span><br><span class="line">ok</span><br><span class="line">3&gt; alarm_handler:set_alarm(tooHot).</span><br><span class="line">=ERROR REPORT==== 3-Jul-2023::12:22:39.079000 ===</span><br><span class="line">***Tell the Engineer to turn on the fan</span><br><span class="line"></span><br><span class="line">ok</span><br><span class="line">4&gt; alarm_handler:clear_alarm(tooHot). </span><br><span class="line">=ERROR REPORT==== 3-Jul-2023::12:22:44.065000 ===</span><br><span class="line">*** Danger over. turn off the fan</span><br><span class="line"></span><br><span class="line">ok</span><br></pre></td></tr></table></figure><h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><p>发送事件 </p><ul><li>notify(EventMgrRef, Event) -&gt; ok</li><li>sync_notify(EventMgrRef, Event) -&gt; ok</li><li>send_request(EventMgrRef :: emgr_ref(),<pre><code>Handler :: handler(),Request :: term()) -&gt;   ReqId :: request_id()</code></pre></li><li>send_request(EventMgrRef :: emgr_ref(),<pre><code>Handler :: handler(),Request :: term(),Label :: term(),ReqIdCollection :: request_id_collection()) -&gt;   NewReqIdCollection :: request_id_collection()</code></pre></li><li>wait_response(ReqId, WaitTime) -&gt; Result</li><li>wait_response(ReqIdCollection, WaitTime, Delete) -&gt; Result</li></ul><ul><li>直接调用函数（过时）</li><li>显示调用</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gen_event:notify(error_man, no_reply).</span><br></pre></td></tr></table></figure><p>处理事件 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module:handle_event(Event, State) -&gt; Result</span><br></pre></td></tr></table></figure><ul><li>Event是一个{EventType,Event-Arg}形式的<strong>二元组</strong>，其中EventType是<strong>set_event</strong>或<strong>clear_event</strong>（event是自定义的事件名），而EventArg是一个用户提供的参数。</li><li>返回 {ok, NewState}。</li></ul><p>实质上，事件表示系统状态的改变，事件管理器就是维护<code>&#123;Module, State&#125;</code>二元组列表。</p><p>注：Module is an event handler, and State is the internal state of that event handler.</p><h2 id="处理其他消息"><a href="#处理其他消息" class="headerlink" title="处理其他消息"></a>处理其他消息</h2><ul><li>Module:handle_info(Info, State) -&gt; Result</li></ul><h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><ul><li>stop(EventMgrRef) -&gt; ok</li><li>stop(EventMgrRef, Reason, Timeout) -&gt; ok</li><li>Module:terminate(Arg, State) -&gt; term()</li></ul><p>停止事件管理器 </p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gen_event:stop(error_man).</span><br></pre></td></tr></table></figure><h1 id="日志和警报"><a href="#日志和警报" class="headerlink" title="日志和警报"></a>日志和警报</h1><p><a href="https://www.erlang.org/doc/man/sasl_app.html">Erlang – sasl</a></p><p>日志和警报是sasl中实现的两个事件处理器。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>sasl的配置</p><ul><li>start_prg = string()</li><li>masters = [atom()]</li><li>client_directory = string()</li><li>static_emulator = true | false</li><li>releases_dir = string()</li></ul><p><code>elog1.config</code></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#123;sasl,[</span><br><span class="line">        &#123;sasl_error_logger, false&#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;].</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：Erlang/OTP 21.0中，日志采用新api：<a href="https://www.erlang.org/doc/apps/kernel/logger_chapter.html">Erlang – Logging</a>。erlang程序设计中提到的sasl_error_logger、errlog_type等配置已经过时。</p><p><a href="https://www.erlang.org/doc/man/alarm_handler.html">https://www.erlang.org/doc/man/alarm_handler.html</a>)</p><h2 id="旧日志"><a href="#旧日志" class="headerlink" title="旧日志"></a>旧日志</h2><p><a href="https://www.erlang.org/doc/man/error_logger.html">Erlang – error_logger</a></p><p><strong>已弃用</strong>，由<a href="https://www.erlang.org/doc/apps/kernel/logger_chapter.html">Erlang – Logging</a>代替</p><ul><li>添加，不再默认启动，需要通过以下两个函数添加<ul><li>add_report_handler(Handler) -&gt; any()<br> add_report_handler(Handler, Args) -&gt; Result</li></ul></li><li>删除<ul><li> delete_report_handler(Handler) -&gt; Result</li></ul></li><li>记录错误<ul><li> error_logger:error_msg(String)</li><li> error_logger:error_msg(Format, Data)</li><li> error_logger:error_report(Report)</li><li> 此外还有info和warning两种日志</li></ul></li><li>配置：错误记录器在何处以及如何保存数据； <ul><li> 显示在erlang shell （默认） </li><li> 文本文件 </li><li>滚动日志：新消息进来后会被附加到日志的末尾，如果日志满了，最早的条目就会被删除。<br> 极其有用。你决定日志应当占据多少个文件，以及每个日志文件能有多大，然后系统负责在一个大型循环缓冲区里删除旧日志文件和创建新文件。可以调整日志的大小来保存最近几天的操作记录 </li></ul></li></ul><p>分析日志：使用rb模块 </p><h2 id="新日志"><a href="#新日志" class="headerlink" title="新日志"></a>新日志</h2><p><a href="https://www.erlang.org/doc/apps/kernel/logger_chapter.html">Erlang – Logging</a></p><h2 id="alarm-handler"><a href="#alarm-handler" class="headerlink" title="alarm_handler"></a>alarm_handler</h2><ul><li>clear_alarm(AlarmId) -&gt; void()</li><li>get_alarms() -&gt; [alarm()]<br>返回已添加的警报处理器</li><li>set_alarm(alarm())<br>发送事件set_alarm到所有事件处理器<br>alarm() = {AlarmId, AlarmDescription}<br>AlarmId = term()<br>AlarmDescription = term()</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EUnit</title>
      <link href="/2023/06/27/%E6%B5%8B%E8%AF%95/"/>
      <url>/2023/06/27/%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>简单学习测试框架使用</p><span id="more"></span><p><a href="https://www.erlang.org/doc/apps/eunit/users_guide.html">https://www.erlang.org/doc/apps/eunit/users_guide.html</a><br><a href="https://www.erlang.org/doc/apps/common_test/users_guide.html">https://www.erlang.org/doc/apps/common_test/users_guide.html</a></p><h1 id="Eunit"><a href="#Eunit" class="headerlink" title="Eunit"></a>Eunit</h1><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>简单测试函数</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include_lib</span><span class="params">(<span class="string">&quot;eunit/include/eunit.hrl&quot;</span>)</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">reverse_test</span><span class="params">()</span> -&gt;</span></span><br><span class="line">lists:reverse([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">reverse_nil_test</span><span class="params">()</span> -&gt;</span> </span><br><span class="line">[] = lists:reverse([]).</span><br><span class="line"><span class="function"><span class="title">reverse_one_test</span><span class="params">()</span> -&gt;</span> </span><br><span class="line">[<span class="number">1</span>] = lists:reverse([<span class="number">1</span>]).</span><br><span class="line"><span class="function"><span class="title">reverse_two_test</span><span class="params">()</span> -&gt;</span> </span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>] = lists:reverse([<span class="number">1</span>, <span class="number">2</span>]).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">crash_test</span><span class="params">()</span>-&gt;</span></span><br><span class="line"><span class="number">1</span>/<span class="number">0</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">output_test</span><span class="params">()</span>-&gt;</span></span><br><span class="line">io:format(<span class="string">&quot;this is a wrong test&quot;</span>).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">length_test</span><span class="params">()</span> -&gt;</span> </span><br><span class="line">?assert(length([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) =:= <span class="number">3</span>).</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行Eunit</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eunit:test(module_name).</span><br><span class="line"></span><br><span class="line">module_name:test().</span><br></pre></td></tr></table></figure><p>Eunit的表示方式<br><a href="https://www.erlang.org/doc/apps/eunit/chapter.html#EUnit_test_representation">https://www.erlang.org/doc/apps/eunit/chapter.html#EUnit_test_representation</a></p><p>生成测试函数的函数<br>好处是不用起名</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">basic_test_</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="keyword">fun</span> () -&gt; ?assert(<span class="number">1</span> + <span class="number">1</span> =:= <span class="number">2</span>) <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">simple_test</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    ?assert(<span class="number">1</span> + <span class="number">1</span> =:= <span class="number">2</span>).</span><br></pre></td></tr></table></figure><p>使用Eunit宏可以写出更紧凑的测试</p><ul><li>?_test把里面的东西放到一个fun函数里<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">basic_test_</span><span class="params">()</span> -&gt;</span></span><br><span class="line">     ?_test(?assert(<span class="number">1</span> + <span class="number">1</span> =:= <span class="number">2</span>)).</span><br></pre></td></tr></table></figure></li></ul><p>还有更紧凑的写法是下划线开头的宏，会自动添加?_test的wrapper</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">basic_test_</span><span class="params">()</span> -&gt;</span></span><br><span class="line">     ?_assert(<span class="number">1</span> + <span class="number">1</span> =:= <span class="number">2</span>).</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  -module(fib).</span><br><span class="line">  -export([fib/<span class="number">1</span>]).</span><br><span class="line">  -include_lib(<span class="string">&quot;eunit/include/eunit.hrl&quot;</span>).</span><br><span class="line"></span><br><span class="line">  fib(<span class="number">0</span>) -&gt; <span class="number">1</span>;</span><br><span class="line">  fib(<span class="number">1</span>) -&gt; <span class="number">1</span>;</span><br><span class="line">  fib(N) <span class="keyword">when</span> N &gt; <span class="number">1</span> -&gt; fib(N-<span class="number">1</span>) + fib(N-<span class="number">2</span>).</span><br><span class="line"></span><br><span class="line">  fib_test_() -&gt;</span><br><span class="line">      [?_assert(fib(<span class="number">0</span>) =:= <span class="number">1</span>),</span><br><span class="line">?_assert(fib(<span class="number">1</span>) =:= <span class="number">1</span>),</span><br><span class="line">?_assert(fib(<span class="number">2</span>) =:= <span class="number">2</span>),</span><br><span class="line">?_assert(fib(<span class="number">3</span>) =:= <span class="number">3</span>),</span><br><span class="line">?_assert(fib(<span class="number">4</span>) =:= <span class="number">5</span>),</span><br><span class="line">?_assert(fib(<span class="number">5</span>) =:= <span class="number">8</span>),</span><br><span class="line">?_assertException(error, function_clause, fib(-<span class="number">1</span>)),</span><br><span class="line">?_assert(fib(<span class="number">31</span>) =:= <span class="number">2178309</span>)</span><br><span class="line">      ].</span><br></pre></td></tr></table></figure><h2 id="测试套件"><a href="#测试套件" class="headerlink" title="测试套件"></a>测试套件</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(my_module_test)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-include_lib</span><span class="params">(<span class="string">&quot;eunit/include/eunit.hrl&quot;</span>)</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">my_test_1</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="comment">% 这里写测试用例的代码</span></span><br><span class="line">    ok.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">my_test_2</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="comment">% 这里写测试用例的代码</span></span><br><span class="line">    ok.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">my_test_3</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="comment">% 这里写测试用例的代码</span></span><br><span class="line">    ok.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">suite</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    [ &#123;my_test_1, fun my_test_1/0&#125;,</span><br><span class="line">      &#123;my_test_2, fun my_test_2/0&#125;,</span><br><span class="line">      &#123;my_test_3, fun my_test_3/0&#125; ].</span><br><span class="line"></span><br><span class="line"><span class="keyword">-ifdef</span><span class="params">(TEST)</span>.</span><br><span class="line"><span class="function"><span class="title">main_test_</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    &#123;setup, fun setup/0, fun cleanup/0, fun suite/0&#125;.</span><br><span class="line"><span class="keyword">-endif</span>.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步和异步</title>
      <link href="/2023/06/27/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5/"/>
      <url>/2023/06/27/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>IO概念区分</p><span id="more"></span><p><a href="https://stackoverflow.com/questions/2625493/asynchronous-and-non-blocking-calls-also-between-blocking-and-synchronous">asynchronous and non-blocking calls? also between blocking and synchronous - Stack Overflow</a></p><p><a href="https://www.zhihu.com/question/19732473">怎样理解阻塞非阻塞与同步异步的区别？ - 知乎 (zhihu.com)</a></p><p>同步和异步是表示两个模块之间的关系，阻塞和非阻塞是描述一个模块的状态。</p><p>socket 中的三种IO模型</p><ul><li>同步=阻塞，线程会挂起直到调用的函数执行完成并返回结果</li><li>非阻塞，如果不能快速返回结果，就返回一个错误，需要提供某种方式查询（轮询）是否能够返回。</li><li>异步（异步非阻塞），总是立即返回，需要以某种方式来获取结果。</li></ul><p>阻塞和非阻塞</p><ul><li>阻塞式发送（blocking send）. 发送方进程会被一直阻塞， 直到消息被接受方进程收到。</li><li>非阻塞式发送（nonblocking send）。 发送方进程调用 send() 后， 立即就可以其他操作。</li><li>阻塞式接收（blocking receive） 接收方调用 receive() 后一直阻塞， 直到消息到达可用。</li><li>非阻塞式接受（nonblocking receive） 接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。</li></ul><p>同步通信和异步通信</p><p>同步通信是指通信双方在通信过程中必须按照一定的协议进行通信，必须同时在线并保持同步状态。在同步通信中，发送方必须等待接收方的响应，才能继续发送下一个数据包，而接收方在接收到数据包后必须及时响应，否则发送方会认为通信失败。</p><p>相比之下，异步通信则不存在这种同步状态的要求。在异步通信中，发送方可以在任何时候发送数据包，而接收方可以在任何时候接收数据包，也不需要立即响应。异步通信可以提高通信的效率和灵活性，但也可能导致数据的丢失或者乱序。</p><p>总的来说，同步通信适合于需要保证数据的可靠性和顺序的场景，而异步通信则适合于需要高效的通信和灵活性的场景。在实际应用中，通常需要根据具体的需求和场景来选择使用哪种通信方式。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fun的用法</title>
      <link href="/2023/06/25/Fun/"/>
      <url>/2023/06/25/Fun/</url>
      
        <content type="html"><![CDATA[<p>介绍erlang中Fun的用法和函数式编程的思想和技巧。</p><span id="more"></span><p><a href="https://www.erlang.org/doc/programming_examples/funs.html">Erlang – Funs</a></p><h1 id="函数式编程简介"><a href="#函数式编程简介" class="headerlink" title="函数式编程简介"></a>函数式编程简介</h1><p>函数式编程（Functional Programming）是一种编程范式，它将计算看作是数学函数的组合。函数式编程强调函数的纯洁性（pureness）、不可变性（immutability）和无副作用（side-effect free）。在函数式编程中，函数被视为一等公民（first-class citizen），可以像其他数据类型一样传递和操作。</p><p>比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。</p><h1 id="Erlang中的Fun"><a href="#Erlang中的Fun" class="headerlink" title="Erlang中的Fun"></a>Erlang中的Fun</h1><h2 id="Fun的作用"><a href="#Fun的作用" class="headerlink" title="Fun的作用"></a>Fun的作用</h2><ul><li>对列表里的每一个元素执行相同的操作。在这个案例里，将fun作为参数传递给lists:map/2和lists:filter/2等函数。fun的这种用法是极其普遍的。</li><li>创建自己的控制抽象。这一技巧极其有用。例如，Erlang没有for循环，但我们可以轻松创建自己的for循环。创建控制抽象的优点是可以让它们精确实现我们想要的做法，而不是依赖一组预定义的控制抽象，因为它们的行为可能不完全是我们想要的。</li><li>实现可重入解析代码（reentrant parsing code）、解析组合器（parser combinator）或惰性求值器（lazy evaluator）等事物。在这个案例里，我们编写返回fun的函数。这种技术很强大，但可能会导致程序难以调试。</li></ul><h2 id="创建Fun"><a href="#创建Fun" class="headerlink" title="创建Fun"></a>创建Fun</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fun = <span class="keyword">fun</span></span><br><span class="line">         () -&gt;</span><br><span class="line">          <span class="number">1</span>;</span><br><span class="line">         (arg) -&gt;</span><br><span class="line">          <span class="number">2</span></span><br><span class="line">      <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>从命名函数创建</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add</span><span class="params">(A, B)</span> -&gt;</span></span><br><span class="line">  A + B.</span><br><span class="line"></span><br><span class="line">Fun = <span class="keyword">fun</span> add/<span class="number">2</span>.</span><br><span class="line">Fun = <span class="keyword">fun</span> module:add/<span class="number">2</span>.</span><br></pre></td></tr></table></figure><p>变量绑定</p><ul><li>参数列表的变量是局部参数，和外部变量的值不同</li><li>函数体外已经定义的变量是全局的，函数体内的值和外部一致</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">print_list</span><span class="params">(File, List)</span> -&gt;</span></span><br><span class="line">  &#123;ok, Stream&#125; = file:open(File, write),</span><br><span class="line">  <span class="comment">% X未绑定 Stream已绑定</span></span><br><span class="line">  lists:foreach(<span class="keyword">fun</span>(X) -&gt; io:format(Stream,<span class="string">&quot;~p~n&quot;</span>,[X]) <span class="keyword">end</span>, List),</span><br><span class="line">  file:close(Stream).</span><br></pre></td></tr></table></figure><h2 id="以fun作为参数的函数"><a href="#以fun作为参数的函数" class="headerlink" title="以fun作为参数的函数"></a>以fun作为参数的函数</h2><p>通过自引用的技巧，可以写出递归的Fun</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 计算阶乘</span></span><br><span class="line"><span class="number">1</span>&gt;   Fun = <span class="keyword">fun</span> </span><br><span class="line">          (This, <span class="number">0</span>, Acc) -&gt;</span><br><span class="line">            Acc;           </span><br><span class="line">          (This, N, Acc) -&gt;</span><br><span class="line">            This(This, N - <span class="number">1</span>, Acc * N)</span><br><span class="line">        <span class="keyword">end</span>.                          </span><br><span class="line">#Fun&lt;erl_eval.<span class="number">18.118419387</span>&gt;</span><br><span class="line"><span class="number">2</span>&gt; Fun(Fun, <span class="number">4</span>, <span class="number">1</span>).         </span><br><span class="line"><span class="number">24</span> </span><br></pre></td></tr></table></figure><h2 id="返回fun的函数"><a href="#返回fun的函数" class="headerlink" title="返回fun的函数"></a>返回fun的函数</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span>&gt; Fruit = [apple, pear, orange].</span><br><span class="line">[apple,pear,orange]</span><br><span class="line"><span class="number">10</span>&gt; MakeTest = <span class="keyword">fun</span></span><br><span class="line">               (L) -&gt;</span><br><span class="line">                 (<span class="keyword">fun</span>(X) -&gt; lists:member(X, L) <span class="keyword">end</span>)</span><br><span class="line">             <span class="keyword">end</span>.</span><br><span class="line">#Fun&lt;erl_eval.<span class="number">6.118419387</span>&gt;</span><br><span class="line"><span class="number">11</span>&gt; IsFruit = MakeTest(Fruit). </span><br><span class="line">#Fun&lt;erl_eval.<span class="number">6.118419387</span>&gt;</span><br><span class="line"><span class="number">12</span>&gt; IsFruit(pear).</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>可用于实现以下应用</p><ul><li>抽象控制流程：返回函数的函数可以用来抽象控制流程，例如在循环中使用递归进行迭代。这可以使代码更加简单和易于理解。</li><li>延迟求值：返回函数的函数可以用于实现延迟求值。例如，在惰性求值器中，我们可以返回一个函数，该函数在需要时才计算结果。</li><li>动态代码生成：返回函数的函数可以用于动态生成代码。例如，在编写编译器或解析器时，我们可以返回一个函数，该函数用于生成解析树或代码。</li><li>部分应用：返回函数的函数可以用于部分应用。例如，我们可以返回一个函数，该函数接受一个参数并返回另一个函数，该函数接受另一个参数并返回结果。这可以用来生成特定的函数，例如增量器函数。</li></ul><h2 id="定义控制抽象"><a href="#定义控制抽象" class="headerlink" title="定义控制抽象"></a>定义控制抽象</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span><span class="params">(Max, Max, F)</span> -&gt;</span></span><br><span class="line">  [F(Max)];</span><br><span class="line"><span class="function"><span class="title">for</span><span class="params">(I, Max, F)</span> -&gt;</span></span><br><span class="line">  [F(I) | for(I + <span class="number">1</span>, Max, F)].</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="function"><span class="title">for</span><span class="params">(<span class="number">1</span>, <span class="number">10</span>, <span class="keyword">fun</span>(I) -&gt; I <span class="keyword">end</span>)</span>.</span></span><br><span class="line"><span class="function">[1,2,3,4,5,6,7,8,9,10]</span></span><br></pre></td></tr></table></figure><h2 id="可重入解析代码"><a href="#可重入解析代码" class="headerlink" title="可重入解析代码"></a>可重入解析代码</h2><p>可重入解析代码是指可以被多个线程同时调用的解析代码</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解析组合器"><a href="#解析组合器" class="headerlink" title="解析组合器"></a>解析组合器</h2><p><a href="https://juejin.cn/post/7165305514480369701">https://juejin.cn/post/7165305514480369701</a></p><p><a href="https://serokell.io/blog/parser-combinators-in-elixir">https://serokell.io/blog/parser-combinators-in-elixir</a></p><p>将小型解析器组合成更大解析器的技术</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="惰性求值器"><a href="#惰性求值器" class="headerlink" title="惰性求值器"></a>惰性求值器</h2><p>惰性求值器（lazy evaluator）是一种计算模型，它只在需要时才计算表达式的值。惰性求值器通常用于处理无限列表、大型数据集或需要计算代价很高的表达式的程序。Erlang中支持惰性求值，可以使用列表推导式或流（stream）来实现。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="深入函数式编程"><a href="#深入函数式编程" class="headerlink" title="深入函数式编程"></a>深入函数式编程</h1><p><a href="https://www.zhihu.com/question/28292740">https://www.zhihu.com/question/28292740</a></p><p><a href="https://tech.meituan.com/2022/10/13/dive-into-functional-programming-01.html">https://tech.meituan.com/2022/10/13/dive-into-functional-programming-01.html</a></p><p><a href="https://tech.meituan.com/2022/10/13/dive-into-functional-programming-02.html">https://tech.meituan.com/2022/10/13/dive-into-functional-programming-02.html</a></p><p><a href="https://www.ruanyifeng.com/blog/2012/04/functional_programming.html">https://www.ruanyifeng.com/blog/2012/04/functional_programming.html</a></p><p><a href="https://www.defmacro.org/2006/06/19/fp.html">https://www.defmacro.org/2006/06/19/fp.html</a></p><p>TODO：整理中</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gen_statem</title>
      <link href="/2023/06/24/gen_statem/"/>
      <url>/2023/06/24/gen_statem/</url>
      
        <content type="html"><![CDATA[<p>介绍四大行为模式之一的gen_statem</p><span id="more"></span><p><a href="https://www.erlang.org/doc/design_principles/statem.html">Erlang – gen_statem Behaviour</a></p><p><a href="https://zhuanlan.zhihu.com/p/46347732">https://zhuanlan.zhihu.com/p/46347732</a></p><p><a href="https://ruby-china.org/topics/33559">https://ruby-china.org/topics/33559</a></p><h1 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>有限状态机（FSM）是一种数学模型，用于描述一些系统或过程的行为。这些系统或过程可以被看作是由一系列<strong>状态</strong>和在这些状态之间进行<strong>转移的规则</strong>组成的，FSM 可以用来描述这些状态和规则的结构和行为。</p><p>FSM 通常包括一个有限状态集合、输入符号集合、输出符号集合、转移函数以及初始状态和终止状态。在 FSM 中，系统从一个状态开始，依照一定规则接受输入，并根据规则进行状态转移，最终到达某个终止状态。</p><p>状态机中的要素：</p><ul><li>现态：是指当前所处的状态。</li><li>条件：又称为“<strong>事件</strong>”，当一个条件被满足（接收输入或信号），可以触发一次状态的<strong>转移</strong>或执行一个<strong>动作</strong>。</li><li>动作（Action）：条件满足后执行的动作。动作执行完毕后，可以转移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接转移到新状态。</li><li>次态：条件满足后要转移的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。</li></ul><p>状态机在运行过程中，根据事件和当前状态，判断是否满足条件，如果满足条件，则执行相应的动作，并进行状态转移到次态；否则，保持现态等待下一个事件的到来。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>TCP（传输控制协议）是一个使用 FSM 的计算机网络协议的例子。TCP 是一种可靠的、面向连接的、基于字节流的传输协议，用于在计算机之间进行数据通信。</p><p>TCP 中的 FSM 用于描述 TCP 连接的建立、维护和关闭过程。在 TCP 连接的建立过程中，客户端和服务器通过交换 SYN 和 ACK 报文来协商连接参数，并建立一个连接。在连接建立后，TCP 使用 FSM 来维护连接状态，包括数据传输、流量控制和拥塞控制等。</p><p>TCP FSM 包括多个状态，如 CLOSED、LISTEN、SYN-SENT、SYN-RECEIVED、ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、CLOSE-WAIT、CLOSING、LAST-ACK 和 TIME-WAIT 等。每个状态具有一组规则，用于确定连接的下一步状态和行为。TCP FSM 的设计使得 TCP 协议能够在不同的网络环境下，如高延迟、高带宽、拥塞等情况下，保证数据的可靠传输和网络性能的优化。</p><h2 id="用erlang实现fsm"><a href="#用erlang实现fsm" class="headerlink" title="用erlang实现fsm"></a>用erlang实现fsm</h2><p>FSM （有限状态机）是一种抽象模型，它由有限数量的状态（ state ）以及事件（ event ）构成。当程序处于各个状态时，它可以从环境中接收一些特定的事件一一井且只接收这些事件。当事件抵达，而FSM 处于特定的状态时， 程序就会执行一些与当前状态对应的预先决定好的动作，使得当前状态转移为另一个新的状态。然后FSM 以此新状态、等待下一个新的事件。</p><p>在Erlang中，每个状态（ state ）以一个内含<strong>尾递归</strong>的函数表示，而事件（ event ）则以<strong>消息</strong>（ message ）表示。</p><p>实例</p><ul><li>状态<ul><li>白天<ul><li>事件<ul><li>eclipse</li><li>sunset</li></ul></li></ul></li><li>黑夜<ul><li>事件<ul><li>sunrise</li></ul></li></ul></li></ul></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">start</span><span class="params">()</span>-&gt;</span></span><br><span class="line">  spawn(?MODULE, init, []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">init</span><span class="params">()</span>-&gt;</span></span><br><span class="line">  create_earth(),</span><br><span class="line">  day().</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">day</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  <span class="keyword">receive</span></span><br><span class="line">    eclipse -&gt; day();</span><br><span class="line">    sunset  -&gt; night()</span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">night</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  <span class="keyword">receive</span></span><br><span class="line">    sunrise -&gt;</span><br><span class="line">      make_roosters_crow(),</span><br><span class="line">      day()</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><h1 id="gen-statem"><a href="#gen-statem" class="headerlink" title="gen_statem"></a>gen_statem</h1><p>由于gen_fsm已经过时，由gen_statem取代，因此本文介绍gen_statem的使用。</p><p>本文中的<strong>例子</strong>来自erlang官网上的一个<a href="https://www.erlang.org/doc/design_principles/statem.html#example">示例</a>，该示例的状态和事件如下：</p><p>状态</p><ul><li>locked</li><li>open</li></ul><p>事件</p><ul><li>collect_buttons()</li><li>clear_buttonss()</li><li>state_timeout(10)</li><li>do_lock()</li><li>do_unlock()</li></ul><h2 id="启动gen-statem"><a href="#启动gen-statem" class="headerlink" title="启动gen_statem"></a>启动gen_statem</h2><p>启动的函数基本和gen_server相同</p><ul><li>start(Module :: module(), Args :: term(), Opts :: [start_opt()]) -&gt;<pre><code>start_ret()</code></pre></li><li>start(ServerName :: server_name(),<pre><code>Module :: module(),Args :: term(),Opts :: [start_opt()]) -&gt;   start_ret()</code></pre></li><li>start_link(Module :: module(),<pre><code>Args :: term(),Opts :: [start_opt()]) -&gt;   start_ret()</code></pre></li><li>start_link(ServerName :: server_name(),<pre><code>Module :: module(),Args :: term(),Opts :: [start_opt()]) -&gt;   start_ret()</code></pre></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>Module:init(Args) -&gt; Result(StateType)<ul><li>Result(StateType) 可以是<ul><li>{ok, State :: StateType, Data :: DataType}<br>成功初始化，State是初始状态，Data是初始数据</li><li>{ok,<pre><code> State :: StateType, Data :: DataType, Actions :: [action()] | action()&#125;</code></pre></li><li>ignore</li><li>{stop, Reason :: term()}</li><li>{error, Reason :: term()}</li></ul></li></ul></li></ul><h3 id="回调模式（Callback-Modes）"><a href="#回调模式（Callback-Modes）" class="headerlink" title="回调模式（Callback Modes）"></a>回调模式（Callback Modes）</h3><p>gen_statem 支持两种回调模式</p><ul><li><a href="https://www.erlang.org/doc/man/gen_statem.html#type-callback_mode">state_functions</a>，每种状态都分别有一个回调函数处理，相当于有限状态机</li><li><a href="https://www.erlang.org/doc/man/gen_statem.html#type-callback_mode">handle_event_function</a>，所有事件都统一由一个回调函数处理。</li></ul><p>通过实现强制的回调函数<code>callback_mode/0</code>来选择回调模式，回调模式可能由于代码的升降级和更改回调模块而更改。</p><ul><li>Module:callback_mode() -&gt; CallbackMode<br>CallbackMode = callback_mode() | [ callback_mode() | state_enter() ]</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">callback_mode</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    state_functions.</span><br><span class="line"><span class="function"><span class="title">callback_mode</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    state_functions.</span><br><span class="line"><span class="function"><span class="title">callback_mode</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    [state_functions,state_enter].</span><br><span class="line"><span class="function"><span class="title">callback_mode</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    [handle_event_function,state_enter].</span><br></pre></td></tr></table></figure><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>启动进程，设置为state_functions模式</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-define</span><span class="params">(NAME, code_lock)</span>.</span><br><span class="line"><span class="function"><span class="title">start_link</span><span class="params">(Code)</span> -&gt;</span></span><br><span class="line">  gen_statem:start_link(&#123;local, ?NAME&#125;, ?MODULE, Code, []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">init</span><span class="params">(Code)</span> -&gt;</span></span><br><span class="line">  do_lock(),</span><br><span class="line">  Data = #&#123;code =&gt; Code, length =&gt; length(Code), buttons =&gt; []&#125;,</span><br><span class="line">  &#123;ok, locked, Data&#125;.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">callback_mode</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  state_functions.</span><br></pre></td></tr></table></figure><h2 id="发出事件"><a href="#发出事件" class="headerlink" title="发出事件"></a>发出事件</h2><h3 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h3><ul><li>cast(ServerRef :: server_ref(), Msg :: term()) -&gt; ok</li><li>send_request(ServerRef :: server_ref(), Request :: term()) -&gt; ReqId :: request_id()</li><li>send_request(ServerRef :: server_ref(), Request :: term(), Label :: term(), ReqIdCollection :: request_id_collection()) -&gt; NewReqIdCollection :: request_id_collection()</li><li>check_response(Msg, ReqId) -&gt; Result</li><li>check_response(Msg, ReqIdCollection, Delete) -&gt; Result</li><li>receive_response(ReqId, Timeout) -&gt; Result</li></ul><p>cast方法用于向状态机发送不需要响应的异步消息。这类消息通常用于状态机内部的事件通知，例如通知状态机启动一个新的异步任务或者通知状态机进行某个操作。cast方法不会阻塞发送方，因为它不需要等待状态机的响应。</p><p>send_request方法用于向状态机发送需要响应的异步消息。这类消息通常用于向状态机请求某些操作的执行结果，例如请求状态机执行某个查询操作并返回结果。send_request方法会阻塞发送方，直到状态机响应了消息并返回结果，或者消息超时。send_request方法通常与handle_info回调函数一起使用，以处理状态机的异步消息。</p><h3 id="同步事件"><a href="#同步事件" class="headerlink" title="同步事件"></a>同步事件</h3><p>TODO</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">button</span><span class="params">(Button)</span> -&gt;</span></span><br><span class="line">  gen_statem:cast(?NAME, &#123;button, Button&#125;).</span><br></pre></td></tr></table></figure><h2 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h2><h3 id="状态回调（State-Callback）"><a href="#状态回调（State-Callback）" class="headerlink" title="状态回调（State Callback）"></a>状态回调（State Callback）</h3><p><strong>处理</strong>现态下的事件的回调<strong>函数</strong>，具体是哪个函数取决于回调模式：</p><ul><li>state_functions 模式，由<code>StateName</code>处理（StateName是自定义的处理函数名）<ul><li>EventType有三种<ul><li><strong><a href="https://www.erlang.org/doc/man/gen_statem.html#type-external_event_type">external</a></strong><ul><li>cast，Generated by gen_statem:cast(ServerRef, Msg)，Msg是EventContent </li><li>{call,From}，Generated by gen_statem:call(ServerRef, Request)，Request是EventContent </li><li>info，Generated by any regular process message sent to the gen_statem process. 进程传过来的是EventContent </li></ul></li><li><strong><a href="https://www.erlang.org/doc/man/gen_statem.html#type-timeout_event_type">timeout</a></strong><ul><li>state_timeout，Generated by transition action {state_timeout,Time,EventContent}</li><li>{timeout,Name}，Generated by transition action { {timeout,Name},Time,EventContent} generic timer timing out.</li><li>timeout，Generated by transition action {timeout,Time,EventContent} (or its short form Time) event timer timing out. </li></ul></li><li>internal，Generated by transition action {next_event,internal,EventContent}</li><li>所有事件类型还可以由{next_event,EventType,EventContent}生成</li></ul></li></ul></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module:StateName(EventType, EventContent, Data) -&gt; StateFunctionResult</span><br></pre></td></tr></table></figure><ul><li>handle_event_function模式，由<code>handle_event</code>处理</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module:handle_event(EventType, EventContent, State, Data) -&gt; HandleEventResult</span><br></pre></td></tr></table></figure><h3 id="进入回调（State-Enter-Calls）"><a href="#进入回调（State-Enter-Calls）" class="headerlink" title="进入回调（State Enter Calls）"></a>进入回调（State Enter Calls）</h3><p>特殊的回调函数，每次状态改变时（进入一个状态）会被调用</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module:StateName(enter, OldState, Data) -&gt; StateEnterResult(StateName) </span><br></pre></td></tr></table></figure><h3 id="过渡动作（Transition-Actions）"><a href="#过渡动作（Transition-Actions）" class="headerlink" title="过渡动作（Transition Actions）"></a>过渡动作（Transition Actions）</h3><p>TODO</p><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>从状态回调退出时开始计算，三种超时：</p><ul><li>state_timeout</li><li>{timeout, Name}</li><li>timeout</li></ul><h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>前面定义的是state_functions模式，这里用 <code>StateName</code> 的回调来处理。</p><ul><li>在lock状态下需要接收按键，最大长度是正确密码的长度</li><li>open状态，用state_timeout的方式停留10秒，转移到lock状态</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">locked</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    cast, &#123;button, Button&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    #&#123;code := Code, length := Length, buttons := Buttons&#125; = Data)</span> -&gt;</span></span><br><span class="line">  NewButtons =</span><br><span class="line">    <span class="keyword">if</span></span><br><span class="line">      length(Buttons) &lt; Length -&gt;</span><br><span class="line">        Buttons;</span><br><span class="line">      <span class="literal">true</span> -&gt;</span><br><span class="line">        tl(Buttons)</span><br><span class="line">    <span class="keyword">end</span> ++ [Button],</span><br><span class="line">  <span class="keyword">if</span></span><br><span class="line">    NewButtons =:= Code -&gt; <span class="comment">% Correct</span></span><br><span class="line">      do_unlock(),</span><br><span class="line">      &#123;next_state, open, Data#&#123;buttons := []&#125;,</span><br><span class="line">        [&#123;state_timeout, <span class="number">10000</span>, lock&#125;]&#125;; <span class="comment">% Time in milliseconds</span></span><br><span class="line">    <span class="literal">true</span> -&gt; <span class="comment">% Incomplete | Incorrect</span></span><br><span class="line">      &#123;next_state, locked, Data#&#123;buttons := NewButtons&#125; &#125;</span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">open</span><span class="params">(state_timeout, lock, Data)</span> -&gt;</span></span><br><span class="line">  do_lock(),</span><br><span class="line">  &#123;next_state, locked, Data&#125;;</span><br><span class="line"><span class="function"><span class="title">open</span><span class="params">(cast, &#123;button, _&#125;, Data)</span> -&gt;</span></span><br><span class="line">  &#123;next_state, open, Data&#125;.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">do_lock</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;Lock~n&quot;</span>, []).</span><br><span class="line"><span class="function"><span class="title">do_unlock</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;Unlock~n&quot;</span>, []).</span><br></pre></td></tr></table></figure><h2 id="例子的完整代码"><a href="#例子的完整代码" class="headerlink" title="例子的完整代码"></a>例子的完整代码</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(code_lock)</span>.</span><br><span class="line"><span class="keyword">-behaviour</span><span class="params">(gen_statem)</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% API</span></span><br><span class="line"><span class="keyword">-define</span><span class="params">(NAME, code_lock)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">1</span>])</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([button/<span class="number">1</span>])</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>, callback_mode/<span class="number">0</span>, terminate/<span class="number">3</span>])</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([locked/<span class="number">3</span>, open/<span class="number">3</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">start_link</span><span class="params">(Code)</span> -&gt;</span></span><br><span class="line">  gen_statem:start_link(&#123;local, ?NAME&#125;, ?MODULE, Code, []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">button</span><span class="params">(Button)</span> -&gt;</span></span><br><span class="line">  gen_statem:cast(?NAME, &#123;button, Button&#125;).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">init</span><span class="params">(Code)</span> -&gt;</span></span><br><span class="line">  do_lock(),</span><br><span class="line">  Data = #&#123;code =&gt; Code, length =&gt; length(Code), buttons =&gt; []&#125;,</span><br><span class="line">  &#123;ok, locked, Data&#125;.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">callback_mode</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  state_functions.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">locked</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    cast, &#123;button, Button&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    #&#123;code := Code, length := Length, buttons := Buttons&#125; = Data)</span> -&gt;</span></span><br><span class="line">  NewButtons =</span><br><span class="line">    <span class="keyword">if</span></span><br><span class="line">      length(Buttons) &lt; Length -&gt;</span><br><span class="line">        Buttons;</span><br><span class="line">      <span class="literal">true</span> -&gt;</span><br><span class="line">        tl(Buttons)</span><br><span class="line">    <span class="keyword">end</span> ++ [Button],</span><br><span class="line">  <span class="keyword">if</span></span><br><span class="line">    NewButtons =:= Code -&gt; <span class="comment">% Correct</span></span><br><span class="line">      do_unlock(),</span><br><span class="line">      &#123;next_state, open, Data#&#123;buttons := []&#125;,</span><br><span class="line">        [&#123;state_timeout, <span class="number">10000</span>, lock&#125;]&#125;; <span class="comment">% Time in milliseconds</span></span><br><span class="line">    <span class="literal">true</span> -&gt; <span class="comment">% Incomplete | Incorrect</span></span><br><span class="line">      &#123;next_state, locked, Data#&#123;buttons := NewButtons&#125; &#125;</span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">open</span><span class="params">(state_timeout, lock, Data)</span> -&gt;</span></span><br><span class="line">  do_lock(),</span><br><span class="line">  &#123;next_state, locked, Data&#125;;</span><br><span class="line"><span class="function"><span class="title">open</span><span class="params">(cast, &#123;button, _&#125;, Data)</span> -&gt;</span></span><br><span class="line">  &#123;next_state, open, Data&#125;.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">do_lock</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;Lock~n&quot;</span>, []).</span><br><span class="line"><span class="function"><span class="title">do_unlock</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;Unlock~n&quot;</span>, []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, State, _Data)</span> -&gt;</span></span><br><span class="line">  State =/= locked <span class="keyword">andalso</span> do_lock(),</span><br><span class="line">  ok.</span><br></pre></td></tr></table></figure><p>运行方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1&gt; c(code_lock).                  </span><br><span class="line">&#123;ok,code_lock&#125;</span><br><span class="line">2&gt; code_lock:start_link([1,2,3]).</span><br><span class="line">Lock</span><br><span class="line">&#123;ok,&lt;0.62.0&gt;&#125;</span><br><span class="line">3&gt; code_lock:button(1). </span><br><span class="line">ok</span><br><span class="line">4&gt; code_lock:button(2). </span><br><span class="line">ok</span><br><span class="line">5&gt; code_lock:button(3). </span><br><span class="line">Unlock</span><br><span class="line">ok</span><br><span class="line">6&gt; Lock</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gen_server</title>
      <link href="/2023/06/24/gen_server/"/>
      <url>/2023/06/24/gen_server/</url>
      
        <content type="html"><![CDATA[<p>介绍四大行为模式之一的gen_server</p><span id="more"></span><p><a href="https://www.erlang.org/doc/design_principles/gen_server_concepts.html">Erlang – gen_server Behaviour</a></p><h1 id="gen-server开发步骤"><a href="#gen-server开发步骤" class="headerlink" title="gen_server开发步骤"></a>gen_server开发步骤</h1><p>gen_server用于实现<strong>客户端/服务器</strong>模型，代码包括三部分：api，回调函数，实现函数（Internal functions）</p><p>回调模块的编写步骤：</p><ol><li> 确定回调模块名。 </li><li> 编写接口函数。 </li><li>在回调模块里编写六个必需的回调函数。 <ul><li> init 服务器初始化 </li><li> handle_call 处理同步请求 </li><li> handle_cast 处理异步请求 </li><li> handle_info 处理其他请求时必须实现 </li><li> terminate 终止服务器 </li><li> code_change 处理其他请求时必须实现 </li></ul></li><li> 回调函数更多是处理请求的发送和回复，具体的逻辑要编写一些私有函数（Internal functions）来实现。 </li></ol><h1 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h1><p><code>gen_server</code> 进程维护一个称为“状态”（state）的内部数据结构，它代表了服务器进程在某一时刻的状态，客户端可以通过向服务器发送请求来查询或修改这个状态。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-record</span><span class="params">(area_server_state, </span></span><br><span class="line"><span class="params">        &#123;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        &#125;)</span>.</span><br></pre></td></tr></table></figure><h1 id="启动gen-server"><a href="#启动gen-server" class="headerlink" title="启动gen_server"></a>启动gen_server</h1><ul><li><strong>start</strong><br> 启动独立的gen_server，standalone ，不包括在监督树的一部分。 <ul><li>start(Module :: module(),Args :: term(), Options :: [start_opt()]) -&gt; start_ret()</li><li>start(ServerName :: server_name(), Module :: module(), Args :: term(), Options :: [start_opt()]) -&gt; start_ret()</li></ul></li><li><strong>start_link</strong><br> 启动一个在监控树中的gen_server，这个函数应该直接或间接<strong>被supervision调用</strong> <ul><li> start_link(Module :: module(), Args :: term(), Options :: [start_opt()]) -&gt; start_ret() </li><li>start_link(ServerName :: server_name(), Module :: module(), Args :: term(), Options :: [start_opt()]) -&gt; start_ret() <ul><li>server_name() =<pre><code> &#123;local, LocalName :: atom()&#125; | &#123;global, GlobalName :: term()&#125; | &#123;via, RegMod :: module(), ViaName :: term()&#125;</code></pre> 和三参相比会<strong>注册</strong>进程，按ServerName注册到local或global </li><li> Module 是<strong>回调模块</strong>的名字，其中应当包含各种<strong>回调函数</strong>以及与server相关的代码 </li><li> Args 可以是任意Term，会被传递给<code>Module:init</code>用于初始化server 状态。 </li><li> Opts 是一列表，其中包括与进程和调试相关的各种选项 </li><li>start_ret() =<pre><code> &#123;ok, Pid :: pid()&#125; | ignore | &#123;error, Reason :: term()&#125;</code></pre></li></ul></li></ul></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  gen_server:start_link(&#123;local, ?SERVER&#125;, ?MODULE, [], []).</span><br></pre></td></tr></table></figure><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><ul><li>Module:init(Args) -&gt; Result<ul><li>Args对应start_link中的Args</li><li>Result = <ul><li>{ok,State} 成功返回</li><li>{ok,State,Timeout}<br>| {ok,State,hibernate}<br>| {ok,State,{continue,Continue}}<br>| {stop,Reason}<br>| {error,Reason}<br>| ignore</li></ul></li></ul></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></span><br><span class="line">  process_flag(trap_exit, true),</span><br><span class="line">  io:format(<span class="string">&quot;~p starting~n&quot;</span>, [?MODULE]),</span><br><span class="line">  &#123;ok, <span class="number">0</span>&#125;.</span><br></pre></td></tr></table></figure><h1 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h1><p>api使用call函数，实现远程过程调用，将所有的数据包装成Request来发送</p><ul><li><p>gen_server:call(ServerRef :: server_ref(), Request :: term()) -&gt; Reply :: term()</p></li><li><p>gen_server:call(ServerRef :: server_ref(), Request :: term(), Timeout :: timeout()) -&gt; Reply :: term()<br>发出同步请求</p><ul><li>ServerRef是Pid或注册名</li><li>Timeout 单位为ms</li></ul></li><li><p>Module:handle_call(Request, From, State) -&gt; Result<br>处理同步请求</p><ul><li><p>Result</p><ul><li><p>Reply会返回客户端，成为gen_server:call的返回值。NewState则是服务器接下来的状态。</p><ul><li>{reply,Reply,NewState}</li><li>{reply,Reply,NewState,Timeout}</li><li>{reply,Reply,NewState,hibernate}</li><li>{reply,Reply,NewState,{continue,Continue}}</li></ul></li><li><p>no reply会让服务器继续工作，但客户端会等待一个回复，所以服务器必须把回复的任务委派给其他进程</p><ul><li>{noreply,NewState} </li><li>{noreply,NewState,Timeout}</li><li>{noreply,NewState,hibernate}</li><li>{noreply,NewState,{continue,Continue}}</li></ul></li><li><p>用适当的参数调用stop会停止服务器</p><ul><li>{stop,Reason,Reply,NewState}</li><li>{stop,Reason,NewState}</li></ul></li></ul></li></ul></li></ul><p>复杂程度更高的应用程序经常会让gen_server回复一个noreply返回值，并把真正的回复任务委派给另一个进程。要了解更多这方面的信息，请阅读“Design Principles”①（设计原则）文档，以及sys和proc_lib模块的手册页。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">area</span><span class="params">(Thing)</span> -&gt;</span></span><br><span class="line">  gen_server:call(?MODULE, &#123;area, Thing&#125;).</span><br></pre></td></tr></table></figure><h1 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h1><p>实现了一个播发（cast），也就是没有返回值的调用（实际上就是一个消息，但习惯上称它为播发来与远程过程调用相区分）。异步请求是<strong>不期待回应</strong>的，因此handle_cast没有From参数。</p><ul><li>cast(ServerRef :: server_ref(), Request :: term()) -&gt; ok<br>发起异步请求</li><li>Module:handle_cast(Request, State) -&gt; Result <ul><li>Result<ul><li>{noreply, NewState} 改变服务器状态<ul><li>{noreply,NewState}</li><li>{noreply,NewState,Timeout}</li><li>{noreply,NewState,hibernate}</li><li>{noreply,NewState,{continue,Continue}}</li></ul></li><li>{stop, …} 停止服务器<ul><li>stop,Reason,NewState}</li></ul></li></ul></li></ul></li></ul><h1 id="处理自发性消息"><a href="#处理自发性消息" class="headerlink" title="处理自发性消息"></a>处理自发性消息</h1><p>回调函数handle_info(Info, State)被用来处理发给服务器的自发性消息。自发性消息是一切未经显式调用gen_server:call或gen_server:cast而到达服务器的消息。</p><ul><li><p>Module:handle_info(Info, State) -&gt; Result</p><ul><li><p>Result</p><ul><li><p>{noreply, NewState} 改变服务器状态</p><ul><li>{noreply,NewState}</li><li>{noreply,NewState,Timeout}</li><li>{noreply,NewState,hibernate}</li><li>{noreply,NewState,{continue,Continue}}</li></ul></li><li><p>{stop, …} 停止服务器</p><ul><li>stop,Reason,NewState}</li></ul></li></ul></li></ul></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handle_call</span><span class="params">(&#123;area, Thing&#125;, _From, N)</span> -&gt;</span></span><br><span class="line">  &#123;reply, compute_area(Thing), N + <span class="number">1</span>&#125;.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">compute_area</span><span class="params">(&#123;square, X&#125;)</span> -&gt;</span> X * X;</span><br><span class="line"><span class="function"><span class="title">compute_area</span><span class="params">(&#123;rectangle, X, Y&#125;)</span> -&gt;</span> X * Y.</span><br></pre></td></tr></table></figure><h1 id="停止gen-server"><a href="#停止gen-server" class="headerlink" title="停止gen_server"></a>停止gen_server</h1><p>若gen_server是监控树的一部分，不需要关闭，由监控者的关闭策略来关闭。</p><p>如果是独立的gen_server，使用terminate函数关闭</p><ul><li>Module:terminate(Reason, State)</li></ul><p>当我们从单个服务器转向系统时，就会用到很多服务器。我们希望能以一致的方式监视它们、重启退出的服务器以及记录错误。这就是下一章的主题</p><p>构建系统</p><ul><li>当服务器崩溃时，需要一种机制来检测这种情况并重启它，为此将用到监控树（supervisiontree）这个概念。创建一个<strong>监控</strong>器来管理服务器，如果服务器崩溃就重启它们。</li><li>如果服务器确实崩溃了，我们希望知道它崩溃的原因，这样就能在未来修复这个问题。<br>为了记录所有错误，可以使用OTP的错误记录器。我们会展示<strong>如何配置错误记录器</strong>，以及如何根据错误日志生成错误报告。</li><li>计算质数（特别是大质数）时，CPU可能会过热，这就需要开启一个强力风扇来避免这种情况。要做到这一点，需要考虑警报。我们会用OTP<strong>事件处理框架</strong>来生成和处理警报</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, _State = #area_server_state&#123;&#125;)</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;~p stopping~n&quot;</span>, [?MODULE]),</span><br><span class="line">  ok.</span><br></pre></td></tr></table></figure><h1 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h1><ul><li>Module:code_change(OldVsn, State, Extra) -&gt; {ok, NewState} | {error, Reason}<br>在代码更改时转换进程状态</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, State = #area_server_state&#123;&#125;, _Extra)</span> -&gt;</span></span><br><span class="line">  &#123;ok, State&#125;.</span><br></pre></td></tr></table></figure><p>TODO：深入了解热更新再来看</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start_link() -&gt;</span><br><span class="line">  gen_server:start_link(&#123;local, ?SERVER&#125;, ?MODULE, [], []).</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3&gt; c(area_server).</span><br><span class="line">&#123;ok,area_server&#125;</span><br><span class="line">4&gt; area_server:start_link().</span><br><span class="line">area_server starting</span><br><span class="line">&#123;ok,&lt;0.66.0&gt;&#125;</span><br><span class="line">5&gt; area_server:area(&#123;square, 2&#125;).</span><br><span class="line">4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>erlang中的容器</title>
      <link href="/2023/06/24/erlang%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/2023/06/24/erlang%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>介绍erlang中各种容器的用法。</p><span id="more"></span><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>容器，存储可变数量数据，类似是带头节点的单链表，所有操作从头开始。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[area,<span class="number">100</span>,<span class="number">200</span>,<span class="string">&quot;你好&quot;</span>]</span><br></pre></td></tr></table></figure><h2 id="模式匹配的列表操作"><a href="#模式匹配的列表操作" class="headerlink" title="模式匹配的列表操作"></a>模式匹配的列表操作</h2><p>列表的第一个元素被称为列表头（head），把列表头去掉，剩下的就被称为列表尾（tail）。<br>[H|T] ，其中一个是元素，一个是列表，并且前面必须是元素，后面是列表，开头可以有多个元素</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThingsToBuy = [&#123;apples, <span class="number">10</span>&#125;,&#123;pears,<span class="number">6</span>&#125;,&#123;milk,<span class="number">3</span>&#125;].</span><br><span class="line">ThingsToBuy1 = [&#123;oranges,<span class="number">4</span>&#125;,&#123;newspaper,<span class="number">1</span>&#125;|ThingsToBuy]</span><br></pre></td></tr></table></figure><h2 id="列表推导（list-comprehension）"><a href="#列表推导（list-comprehension）" class="headerlink" title="列表推导（list comprehension）"></a>列表推导（list comprehension）</h2><p>能够生成元素并对生成的元素做测试的表达式。</p><ul><li>语法：<code>[X || Qualifier1, Qualifier2, ... ]</code><br>Qualifier1可以是生成器、位串生成器或过滤器 <ul><li>生成器（generator），<code>Pattern &lt;- ListExpr</code></li><li>位串（bitstring）生成器，<code>BitStringPattern &lt;= BitStringExpr</code></li><li>过滤器（filter）<br>判断函数（返回true或false）或布尔表达式，只有true的值会被加入列表</li></ul></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].</span><br><span class="line"><span class="comment">% 从L中提取X，并加倍</span></span><br><span class="line">[<span class="number">2</span>*X || X &lt;- L].</span><br><span class="line"></span><br><span class="line"><span class="comment">%</span></span><br><span class="line">[ &#123;X,Y&#125; || x&lt;-[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], y &lt;- [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ].</span><br><span class="line"></span><br><span class="line"><span class="comment">% 强制判断</span></span><br><span class="line">[throw(<span class="string">&quot;this_fun_not_use_uid_prop&quot;</span>) || z_prop_kit:get_prop_max(EncodeProp) =:= <span class="number">1</span>],</span><br></pre></td></tr></table></figure><h2 id="归集器"><a href="#归集器" class="headerlink" title="归集器"></a>归集器</h2><p>尾递归优化方法，程序<strong>只遍历列表一次</strong>，把奇偶参数分别添加到合适的列表里。这些列表被称为归集器（accumulator）。<br>区别在于：奇偶列表里的元素顺序是反转的</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">odds_and_evens</span><span class="params">(L)</span>-&gt;</span></span><br><span class="line">  odds_and_evens_acc(L, [], []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">odds_and_evens_acc</span><span class="params">([H|T],Odds, Events)</span>-&gt;</span></span><br><span class="line">  <span class="keyword">case</span> (H <span class="keyword">rem</span> <span class="number">2</span>) <span class="keyword">of</span></span><br><span class="line">    <span class="number">1</span>-&gt;</span><br><span class="line">      odds_and_evens_acc(T, [H|Odds], Events);</span><br><span class="line">    <span class="number">0</span>-&gt;</span><br><span class="line">      odds_and_evens_acc(T, Odds, [H|Events])</span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="title">odds_and_evens_acc</span><span class="params">([],Odds, Events)</span>-&gt;</span></span><br><span class="line">  &#123;Odds, Events&#125;.</span><br></pre></td></tr></table></figure><h2 id="常用BIF"><a href="#常用BIF" class="headerlink" title="常用BIF"></a>常用BIF</h2><ul><li>hd(List) -&gt; term()<br>取列表头</li><li>tl(List) -&gt; term()<br>取除列表头的部分</li><li>length(List) -&gt; integer() &gt;= 0<br>列表长度</li></ul><h2 id="lists模块提供的处理函数"><a href="#lists模块提供的处理函数" class="headerlink" title="lists模块提供的处理函数"></a>lists模块提供的处理函数</h2><ul><li>member(Elem, List) -&gt; boolean()<br>是否是成员</li><li>append(ListOfLists) -&gt; List1</li><li>append(List1, List2) -&gt; List3<br>调的也是++，++是复制左边，append是复制List1</li><li>reverse(List1) -&gt; List2</li><li>reverse(List1, Tail) -&gt; List2<br>反转List1并将Tail插入到列表尾</li><li>delete(Elem, List1) -&gt; List2</li><li>filter(Pred, List1) -&gt; List2<br>List2是Pred函数返回True的结果</li><li>sort(List1) -&gt; List2</li><li>sort(Fun, List1) -&gt; List2<br>使用自定义排序函数Fun来排序<br>对fun(A,B)，当A&lt;=B返回true，否则返回false</li><li>nth(N, List) -&gt; Elem</li><li>nthtail(N, List) -&gt; Tail</li><li>sublist(List1, Len) -&gt; List2</li><li>sublist(List1, Start, Len) -&gt; List2</li><li>search(Pred, List) -&gt; {value, Value} | false</li></ul><p>遍历，基本都是用匿名函数</p><ul><li>foldl(Fun, Acc0, List) -&gt; Acc1<br>对List里的元素连续调用Fun(Elem, AccIn)，Acc0是累加器的初始值</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  Fun = <span class="keyword">fun</span></span><br><span class="line">          (Elem, Acc) -&gt;</span><br><span class="line">            [Elem | Acc]</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">  lists:foldl(Fun, [], [a, b]).</span><br><span class="line"><span class="comment">% [b,a]</span></span><br></pre></td></tr></table></figure><ul><li>foldr(Fun, Acc0, List) -&gt; Acc1<br>和foldl的遍历顺序相反，是从右到左</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  Fun = <span class="keyword">fun</span></span><br><span class="line">          (Elem, Acc) -&gt;</span><br><span class="line">            [Elem | Acc]</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">  lists:foldr(Fun, [], [a, b]).</span><br><span class="line"><span class="comment">% [a,b]</span></span><br></pre></td></tr></table></figure><ul><li>map(Fun, List1) -&gt; List2<br>获取映射</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  Fun = <span class="keyword">fun</span></span><br><span class="line">          (a) -&gt;</span><br><span class="line">            x;</span><br><span class="line">          (b)-&gt;</span><br><span class="line">            y</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">  lists:map(Fun, [a,b]).</span><br><span class="line"><span class="comment">% [x,y]</span></span><br></pre></td></tr></table></figure><ul><li>mapfoldl(Fun, Acc0, List1) -&gt; {List2, Acc1}<br>结合map和foldl</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  Fun = <span class="keyword">fun</span></span><br><span class="line">          (X, Acc) -&gt;</span><br><span class="line">            &#123;<span class="number">2</span>*X, [X + <span class="number">1</span> | Acc]&#125;</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">  lists:mapfoldl(Fun, [], [<span class="number">1</span>, <span class="number">2</span>]).</span><br><span class="line"><span class="comment">% &#123;[2,4],[3,2]&#125;</span></span><br></pre></td></tr></table></figure><ul><li>mapfoldr(Fun, Acc0, List1) -&gt; {List2, Acc1}<br>结合map和foldr</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  Fun = <span class="keyword">fun</span></span><br><span class="line">          (X, Acc) -&gt;</span><br><span class="line">            &#123;<span class="number">2</span>*X, [X + <span class="number">1</span> | Acc]&#125;</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">  lists:mapfoldl(Fun, [], [<span class="number">1</span>, <span class="number">2</span>]).</span><br><span class="line"><span class="comment">% &#123;[2,4],[2,3]&#125;</span></span><br></pre></td></tr></table></figure><ul><li>foreach(Fun, List) -&gt; ok<br>对List的每个元素执行Fun操作</li></ul><p>元组列表的操作</p><ul><li>keydelete(Key, N, TupleList1) -&gt; TupleList2</li><li>keyfind(Key, N, TupleList) -&gt; Tuple | false</li><li>keymap(Fun, N, TupleList1) -&gt; TupleList2</li><li>keymember(Key, N, TupleList) -&gt; boolean()</li><li>keymerge(N, TupleList1, TupleList2) -&gt; TupleList3</li><li>keyreplace(Key, N, TupleList1, NewTuple) -&gt; TupleList2</li><li>keysearch(Key, N, TupleList) -&gt; {value, Tuple} | false</li><li>keysort(N, TupleList1) -&gt; TupleList2</li><li>keystore(Key, N, TupleList1, NewTuple) -&gt; TupleList2</li><li>keytake(Key, N, TupleList1) -&gt; {value, Tuple, TupleList2} | false</li></ul><h2 id="z-lib提供的处理函数"><a href="#z-lib提供的处理函数" class="headerlink" title="z_lib提供的处理函数"></a>z_lib提供的处理函数</h2><ul><li>get_list_range/1<br>get_list_range(List::[term()]) -&gt; return() where return() = {Len::integer(), Min::term(), Max::term()} | false.<br>获得列表的最大最小值</li><li>get_value(List, Key, Default) -&gt; any()<br>从元组列表或Tree中，获得指定的键值，如果键不存在，使用默认值</li><li>get_value(List, Key, ValuePos, Default) -&gt; any()<br>从元组列表或Tree中，获得指定的键值，如果键不存在，使用默认值，可以指定值的位置</li><li>get_value(List, Key, KeyPos, ValuePos, Default)<br>可以指定键和值的位置</li><li>get_values(KVList, KeyDefaultList)<br>从元组列表或Tree中，获得指定的键值，如果键不存在，使用默认值</li><li>get_values(KVList, ValuePos,KeyDefaultList)</li><li>get_values(KVList, KeyPos, ValuePos, KeyDefaultList)</li></ul><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>容器，存放固定数目的数据，类似于数组，可随机存取。用元组管理的项数不宜超过五六项。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;area,<span class="number">100</span>,<span class="number">200</span>,<span class="string">&quot;你好&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="常用BIF-1"><a href="#常用BIF-1" class="headerlink" title="常用BIF"></a>常用BIF</h2><ul><li>element(N, Tuple) -&gt; term()<br>获取指定位置数据</li><li>size(Item) -&gt; integer() &gt;= 0<br>获取元组长度</li><li>erlang:insert_element(Index, Tuple1, Term) -&gt; Tuple2<br>在Index位置插入Term</li><li>erlang:append_element(Tuple1, Term) -&gt; Tuple2<br>在尾部插入</li><li>erlang:delete_element(Index, Tuple1) -&gt; Tuple2<br>删除指定位置元素</li><li>setelement(Index, Tuple1, Value) -&gt; Tuple2<br>将Index位置更新为Value，返回新元组</li><li>erlang:make_tuple(Arity, InitialValue) -&gt; tuple()<br>创建具有Arity个InitialValue的元组</li><li>erlang:make_tuple(Arity, DefaultValue, InitList) -&gt; tuple()<br>创建具有Arity个DefaultValue的元组，并以InitList指定<br>如下指定第5个元素为zz，第2个元素（多次出现以最后一个为准）为aa</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; erlang:make_tuple(<span class="number">5</span>, [], [&#123;<span class="number">2</span>,ignored&#125;,&#123;<span class="number">5</span>,zz&#125;,&#123;<span class="number">2</span>,aa&#125;]).</span><br><span class="line">&#123;[],aa,[],[],zz&#125;</span><br></pre></td></tr></table></figure><p>遍历元组的方法，核心是传入索引</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">foreach</span><span class="params">(Tuple, F, A)</span> -&gt;</span></span><br><span class="line">  foreach(Tuple, <span class="number">1</span>, tuple_size(Tuple), F, A).</span><br><span class="line"><span class="function"><span class="title">foreach</span><span class="params">(Tuple, I, N, F, A)</span> <span class="title">when</span> I =&lt; N -&gt;</span></span><br><span class="line">  F(A, element(I, Tuple)),</span><br><span class="line">  foreach(Tuple, I + <span class="number">1</span>, N, F, A);</span><br><span class="line"><span class="function"><span class="title">foreach</span><span class="params">(_Tuple, _I, _N, _F, A)</span> -&gt;</span></span><br><span class="line">  A.</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>元组可用于实现字典</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MY_Dict = dict:new(),</span><br><span class="line">MY_Dict1 = dict:append(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>, MY_Dict),</span><br><span class="line">dict:fetch_keys(MY_Dict1).</span><br></pre></td></tr></table></figure><h1 id="映射组"><a href="#映射组" class="headerlink" title="映射组"></a>映射组</h1><p>和记录一样也是键值对结构，但key可以不是原子，用于当<strong>键不能预先知道</strong>时用来表示键-值数据结构；</p><ul><li>当存在大量不同的键时用来表示数据；</li><li>当方便使用很重要而效率无关紧要时作为万能的数据结构使用；</li><li>用作“自解释型”的数据结构，也就是说，用户容易从键名猜出值的含义；</li><li>用来表示键-值解析树，例如XML或配置文件；</li><li>用JSON来和其他编程语言通信。</li></ul><ol><li><p>操作符</p><ul><li><code>=&gt;</code>，更新现有键或创建新键</li><li><code>:=</code>，更新现有键    </li></ul></li><li><p>原生操作</p><ul><li>创建映射组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&gt; #&#123;a=&gt;1,b=&gt;2&#125;.   #&#123;a =&gt; 1,b =&gt; 2&#125;</span><br></pre></td></tr></table></figure><ul><li>更新映射组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F1 = #&#123;a=&gt;1,b=&gt;2&#125;. F2 = #&#123;b=&gt;2,a=&gt;1&#125;. %F1=F2. F3 = F1#&#123;c=&gt;xx&#125; F4 = F3#&#123;c:=3&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用api操作</p><ul><li>创建映射组<br>maps:new().</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&gt; MapGroup = maps:new().</span><br><span class="line">#&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>向映射组中添加映射<br>put(Key, Value, Map1) -&gt; Map2</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2&gt; MapGroup1 = maps:put(a, 1, MapGroup).</span><br><span class="line">#&#123;a =&gt; 1&#125;</span><br></pre></td></tr></table></figure><ul><li>从映射组中获取<strong>值</strong><ul><li>get(Key, Map) -&gt; Value</li><li>get(Key, Map, Default) -&gt; Value | Default</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3&gt; Value = maps:get(a, MapGroup1). </span><br><span class="line">1</span><br><span class="line">4&gt; Value1 = maps:get(c, MapGroup1, 1).</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li><p>更新</p><ul><li><p>update(Key, Value, Map1) -&gt; Map2<br>Map1不是Map抛badmap<br>Key不存在抛badkey</p></li><li><p>update_with(Key, Fun, Map1) -&gt; Map2</p></li><li><p>update_with(Key, Fun, Init, Map1) -&gt; Map2</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MapGroup2 = maps:update(a, <span class="number">2</span>, MapGroup1).</span><br></pre></td></tr></table></figure></li></ul></li><li><p>从映射组中删除映射</p><ul><li><p>remove(Key, Map1) -&gt; Map2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5&gt; MapGroup2= maps:remove(a, MapGroup1).</span><br><span class="line">#&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>遍历</strong>映射组，打印每个映射</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6&gt; Fun = fun(Key, Value, Acc) -&gt;</span><br><span class="line">                io:format(&quot;Key: ~p, Value: ~p~n&quot;, [Key, Value]), Acc       </span><br><span class="line">          end,</span><br><span class="line">maps:fold(Fun, [], MapGroup).</span><br><span class="line">[]</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>模式匹配<br>和列表一样，在函数<strong>参数</strong>中使用映射组可以提取相应的字段</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_puid(#login&#123;puid=V&#125;) -&gt; V.</span><br></pre></td></tr></table></figure><p>、</p></li></ol><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>构造队列</p><ul><li>new() -&gt; queue(none())</li><li>from_list(L :: [Item]) -&gt; queue(Item)</li></ul><p>访问元素</p><ul><li>in(Item, Q1 :: queue(Item)) -&gt; Q2 :: queue(Item)<br>队尾入</li><li>in_r(Item, Q1 :: queue(Item)) -&gt; Q2 :: queue(Item)<br>队头入</li><li>out(Q1 :: queue(Item)) -&gt;<pre><code>&#123;&#123;value, Item&#125;, Q2 :: queue(Item)&#125; |&#123;empty, Q1 :: queue(Item)&#125;</code></pre>队头出</li><li>out_r(Q1 :: queue(Item)) -&gt;<pre><code>&#123;&#123;value, Item&#125;, Q2 :: queue(Item)&#125; |&#123;empty, Q1 :: queue(Item)&#125;</code></pre>队尾出</li><li>get(Q :: queue(Item)) -&gt; Item</li><li>get_r(Q :: queue(Item)) -&gt; Item</li><li>head(Q :: queue(Item)) -&gt; Item</li><li>last(Q :: queue(Item)) -&gt; Item</li></ul><p>其他</p><ul><li><code>queue:len(Queue)</code>：返回队列中元素的数量</li><li><code>queue:is_empty(Queue)</code>：检查队列是否为空</li><li><code>queue:reverse(Queue)</code>：返回一个反转顺序的队列副本</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt; Q=queue:new().</span><br><span class="line">&#123;[],[]&#125;</span><br><span class="line"><span class="number">2</span>&gt; Q1 = queue:in(a, Q). </span><br><span class="line">&#123;[a],[]&#125;</span><br><span class="line"><span class="number">3</span>&gt; Q2 = queue:in(b, Q1). </span><br><span class="line">&#123;[b],[a]&#125;</span><br><span class="line"><span class="number">4</span>&gt; Q3 = queue:out(Q2).   </span><br><span class="line">&#123;&#123;value,a&#125;,&#123;[],[b]&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并发和分布式编程</title>
      <link href="/2023/06/23/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/06/23/%E5%B9%B6%E5%8F%91%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.erlang.org/doc/reference_manual/processes.html">https://www.erlang.org/doc/reference_manual/processes.html</a><br><a href="https://www.erlang.org/doc/reference_manual/distributed.html">https://www.erlang.org/doc/reference_manual/distributed.html</a></p><p>erlang中关于并发和分布式编程的内容。</p><span id="more"></span><h1 id="Erlang中的通信"><a href="#Erlang中的通信" class="headerlink" title="Erlang中的通信"></a>Erlang中的通信</h1><p>在Erlang中，通信通过相互传递异步信号实现，通信的对象有进程和端口，进程用于内部通信，端口用于外部通信，常见的信号有exit, link, unlink, monitor, and demonitor signals等。</p><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>Erlang中的并发是基于进程的并发，每个进程都带有一个邮箱，这个邮箱是和进程同步创建的。</p><ul><li>self(). % 显示当前进程号</li><li>i() % 显示所有进程信息</li></ul><p>在erlang中进行并发编程有三类基本并发函数：创建进程、发送消息和接受消息。</p><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><p>进程是自包含、独立的计算单元，单节点的创建方式有以下两种</p><ul><li>spawn(Fun) -&gt; pid()<br>不关心动态代码升级，或者确定程序不会在未来进行修改时用</li><li>spawn(Module, Function, Args) -&gt; pid()<br>支持热更新，确保运行进程能够正确 升级为新版模块代码</li></ul><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>向一个进程发送消息有三种方式：Pid、注册名和别名</p><ul><li><p>Pid</p></li><li><p>注册名</p><ul><li>register(RegName, PidOrPort) -&gt; true<br>注册进程，注册名必须是atom类型</li><li>registered()<br>返回所有已注册的名字</li><li>whereis(Name)<br>通过注册名获取Pid<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt; c(area_server_final).</span><br><span class="line">&#123;ok,area_server_final&#125;</span><br><span class="line"><span class="number">2</span>&gt; Pid = spawn(area_server_final, loop, []).      </span><br><span class="line">&lt;<span class="number">0.62</span>.<span class="number">0</span>&gt;</span><br><span class="line"><span class="number">3</span>&gt; register(area,Pid).</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="number">4</span>&gt; area!&#123;rectangle,<span class="number">4</span>,<span class="number">5</span>&#125;.</span><br><span class="line">&#123;rectangle,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="number">9</span>&gt; erlang:send(Pid, &#123;circle, <span class="number">2</span>&#125;). </span><br></pre></td></tr></table></figure></li></ul></li><li><p>别名<br>进程别名本质上是一种引用类型，别名设计的典型用例是请求/回复场景。发送回复时使用进程别名可以使回复接收方在操作超时或进程之间的连接丢失时防止回复到达其消息队列。</p></li></ul><h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p>进程实际上隐藏了信息，我们无法直接访问这个函数的执行信息，但是可以通过发送和接受消息来进行交互，这点和服务器很像。在Fun中递归调用自身实现重复发送和接受消息。</p><ul><li>start 隐藏spawn和rpc</li><li>rpc 隐藏通信过程</li><li>loop 处理逻辑，要导出才能被spawn调用<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-export</span><span class="params">([start/<span class="number">0</span>, area/<span class="number">2</span>, loop/<span class="number">0</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">start</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    spawn(area_server, loop, []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">area</span><span class="params">(Pid, What)</span> -&gt;</span></span><br><span class="line">    rpc(Pid, What).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Request)</span> -&gt;</span></span><br><span class="line">    Pid ! &#123;self(), Request&#125;,</span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">     &#123;Pid, Response&#125; -&gt;</span><br><span class="line">         Response</span><br><span class="line"> <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">loop</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">     &#123;From, &#123;rectangle, Width, Height&#125;&#125; -&gt;</span><br><span class="line">         From ! &#123;self(), Width * Height&#125;,</span><br><span class="line">         loop();</span><br><span class="line">     &#123;From, &#123;circle, R&#125;&#125; -&gt;</span><br><span class="line">         From ! &#123;self(), <span class="number">3.14159</span> * R * R&#125;,</span><br><span class="line">         loop();</span><br><span class="line">     &#123;From, Other&#125; -&gt;</span><br><span class="line">         From ! &#123;self(), &#123;error, Other&#125;&#125;,</span><br><span class="line">         loop()</span><br><span class="line"> <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>&gt; area_server:start().  </span><br><span class="line">&lt;<span class="number">0.89</span>.<span class="number">0</span>&gt;</span><br><span class="line"><span class="number">13</span>&gt; Server=area_server:start().   </span><br><span class="line">&lt;<span class="number">0.91</span>.<span class="number">0</span>&gt;</span><br><span class="line"><span class="number">14</span>&gt; area_server:area(Server, &#123;rectangle, <span class="number">1</span>,<span class="number">2</span>&#125;).</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="接收高级选项"><a href="#接收高级选项" class="headerlink" title="接收高级选项"></a>接收高级选项</h3><ol><li> 带超时的接收 </li></ol><ul><li>使用after指定</li><li>超时值为0，立即执行</li><li>超时值为原子<code>infinity</code>，永远不会超时<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">receive</span></span><br><span class="line">    &#123;From, Message&#125;-&gt;</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">after</span> Time-&gt;</span><br><span class="line">    Expressions</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li> 选择性接收 </li></ol><h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><ol><li>当指定的函数执行完毕，进程正常终止，退出原因是原子 normal</li><li>异常终止，在erlang中，将运行时错误和生成错误表示为以下三类：<ul><li>exit(Reason)</li><li>erlang:error(Reason)</li><li>erlang:error(Reason, Args)</li></ul></li></ol><h2 id="顺序代码的错误处理"><a href="#顺序代码的错误处理" class="headerlink" title="顺序代码的错误处理"></a>顺序代码的错误处理</h2><h3 id="错误的分类"><a href="#错误的分类" class="headerlink" title="错误的分类"></a>错误的分类</h3><p>程序的错误大致可分为以下四类：</p><ul><li><strong>Compile-time errors</strong>，编译产生的错误，例如一些语法错误，可以借助编译器和静态代码分析器找出错误。</li><li><strong>Logical errors</strong>，程序的行为与预想中的不同，例如点击按钮没有反应。</li><li><strong>Run-time errors</strong>，使程序发生崩溃的严重错误，例如运算符作用在错误的类型，也可以用error(Reason)来生成。</li><li><strong>Generated errors</strong>，在代码中调用 <a href="https://www.erlang.org/doc/man/erlang.html#exit-1">exit/1</a>和<code>[throw/1](https://www.erlang.org/doc/man/erlang.html#throw-1)</code>来生成错误。</li></ul><p>Erlang中，将<strong>Run-time errors</strong>和<strong>Generated errors</strong>表示为三类：error、exit、throw。</p><h3 id="用try-catch处理异常"><a href="#用try-catch处理异常" class="headerlink" title="用try catch处理异常"></a>用try catch处理异常</h3><p>程序结构：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> FuncOrExpressionSeq <span class="keyword">of</span></span><br><span class="line">    Patern1 [<span class="keyword">when</span> Guard1] -&gt; Expressions1;</span><br><span class="line">    Patern1 [<span class="keyword">when</span> Guard2] -&gt; Expressions2;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">ExceptionType1: ExPattern1 [<span class="keyword">when</span> ExGuard1] -&gt; ExExpressions1;</span><br><span class="line">ExceptionType2: ExPattern2 [<span class="keyword">when</span> ExGuard2] -&gt; ExExpressions2;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">after</span></span><br><span class="line">    AfterExpressions</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol><li> 捕获错误，在try中编写可能出错的代码，可以使用可选的of进行分支选择。 </li><li> 匹配错误 </li></ol><ul><li> 冒号前的ExceptionType取值为error、exit、throw中一种。 </li><li> 冒号后的ExPattern用于匹配<strong>catch的返回值</strong>，一般是错误的原因，以便进行处理。 </li><li>可选的Stacktrace用于匹配exit类型错误的堆栈信息</li></ul><ol start="3"><li> 处理错误，若模式匹配成功可以在-&gt;后处理，处理完成后执行after子句的内容。 </li></ol><p>实例</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">try</span></span><br><span class="line"><span class="comment">%%    exit(basketball),</span></span><br><span class="line"><span class="comment">%%    error(football),</span></span><br><span class="line">    throw(&#123;my_exception, <span class="string">&quot;Something happened&quot;</span>&#125;)</span><br><span class="line">  <span class="keyword">catch</span></span><br><span class="line">    exit:Reason -&gt;</span><br><span class="line">      io:format(<span class="string">&quot;error Reason:~w~n&quot;</span>, [Reason]);</span><br><span class="line">    error: Reason -&gt;</span><br><span class="line">      io:format(<span class="string">&quot;error Reason:~w~n&quot;</span>, [Reason]);</span><br><span class="line">    throw:&#123;my_exception, Desc&#125; -&gt;</span><br><span class="line">      io:format(standard_error, <span class="string">&quot;Error: ~s~n&quot;</span>, [Desc])</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>常见错误原因</p><table><thead><tr><th><strong>Reason</strong></th><th><strong>Type of Error</strong></th></tr></thead><tbody><tr><td>badarg</td><td>Bad argument. The argument is of wrong data type, or is otherwise badly formed.</td></tr><tr><td>badarith</td><td>Bad argument in an arithmetic expression.</td></tr><tr><td>{badmatch,V}</td><td>Evaluation of a match expression failed. The value V did not match.</td></tr><tr><td>function_clause</td><td>No matching function clause is found when evaluating a function call.</td></tr><tr><td>{case_clause,V}</td><td>No matching branch is found when evaluating a case expression. The value V did not match.</td></tr><tr><td>if_clause</td><td>No true branch is found when evaluating an if expression.</td></tr><tr><td>{try_clause,V}</td><td>No matching branch is found when evaluating the of-section of a try expression. The value V did not match.</td></tr><tr><td>undef</td><td>The function cannot be found when evaluating a function call.</td></tr><tr><td>{badfun,F}</td><td>Something is wrong with a fun F.</td></tr><tr><td>{badarity,F}</td><td>A fun is applied to the wrong number of arguments. F describes the fun and the arguments.</td></tr><tr><td>timeout_value</td><td>The timeout value in a receive..after expression is evaluated to something else than an integer or infinity.</td></tr><tr><td>noproc</td><td>Trying to link or monitor to a non-existing process or port.</td></tr><tr><td>noconnection</td><td>A link or monitor to a remote process was broken because a connection between the nodes could not be established or was severed.</td></tr><tr><td>{nocatch,V}</td><td>Trying to evaluate a throw outside a catch. V is the thrown term.</td></tr><tr><td>system_limit</td><td>A system limit has been reached. See <a href="https://www.erlang.org/doc/efficiency_guide/advanced.html">Efficiency Guide</a></td></tr><tr><td>for information about system limits.</td><td></td></tr></tbody></table><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">try</span></span><br><span class="line"><span class="comment">%%    1 / 0,</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> <span class="keyword">of</span></span><br><span class="line">      <span class="number">0</span>-&gt;</span><br><span class="line">        ok</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">catch</span></span><br><span class="line">    error: badarith -&gt;</span><br><span class="line">      io:format(<span class="string">&quot;arith error&quot;</span>);</span><br><span class="line">    error:&#123;case_clause,V&#125;-&gt;</span><br><span class="line">      io:format(<span class="string">&quot;Unmatch Pattern: ~w~n&quot;</span>,[V])</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><h3 id="用catch处理异常"><a href="#用catch处理异常" class="headerlink" title="用catch处理异常"></a>用catch处理异常</h3><p>使用catch语句捕获异常，<strong>单独的catch语句和try catch里的catch的使用方式不同</strong>，会将错误转换为元组或Term。</p><ul><li>catch exit(Reason)-&gt; {‘EXIT’,Reason}</li><li>catch error(Reason) -&gt; {‘EXIT’,{Reason,Stack}} </li><li>catch throw(Any) -&gt; Any<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span>&gt; exit(foobar).</span><br><span class="line">** exception exit: foobar</span><br><span class="line"><span class="number">19</span>&gt; <span class="keyword">catch</span> exit(foobar).</span><br><span class="line">&#123;&#x27;EXIT&#x27;,foobar&#125;</span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="number">20</span>&gt; error(football).     </span><br><span class="line">** exception error: football</span><br><span class="line"><span class="number">21</span>&gt; <span class="keyword">catch</span> error(foobar). </span><br><span class="line">&#123;&#x27;EXIT&#x27;,&#123;foobar,[&#123;shell,apply_fun,<span class="number">3</span>,</span><br><span class="line">                        [&#123;file,<span class="string">&quot;shell.erl&quot;</span>&#125;,&#123;line,<span class="number">899</span>&#125;]&#125;,</span><br><span class="line">                 &#123;erl_eval,do_apply,<span class="number">6</span>,[&#123;file,<span class="string">&quot;erl_eval.erl&quot;</span>&#125;,&#123;line,<span class="number">674</span>&#125;]&#125;,</span><br><span class="line">                 &#123;erl_eval,expr,<span class="number">5</span>,[&#123;file,<span class="string">&quot;erl_eval.erl&quot;</span>&#125;,&#123;line,<span class="number">431</span>&#125;]&#125;,</span><br><span class="line">                 &#123;shell,exprs,<span class="number">7</span>,[&#123;file,<span class="string">&quot;shell.erl&quot;</span>&#125;,&#123;line,<span class="number">686</span>&#125;]&#125;,</span><br><span class="line">                 &#123;shell,eval_exprs,<span class="number">7</span>,[&#123;file,<span class="string">&quot;shell.erl&quot;</span>&#125;,&#123;line,<span class="number">641</span>&#125;]&#125;,</span><br><span class="line">                 &#123;shell,eval_loop,<span class="number">3</span>,[&#123;file,<span class="string">&quot;shell.erl&quot;</span>&#125;,&#123;line,<span class="number">626</span>&#125;]&#125;]&#125;&#125;</span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="number">22</span>&gt; throw(test).         </span><br><span class="line">** exception throw: test</span><br><span class="line"><span class="number">23</span>&gt; <span class="keyword">catch</span> throw(test). </span><br><span class="line">test</span><br></pre></td></tr></table></figure></li></ul><h2 id="并发中的异常处理"><a href="#并发中的异常处理" class="headerlink" title="并发中的异常处理"></a>并发中的异常处理</h2><blockquote><p>让其他进程修复错误”和“任其崩溃”</p></blockquote><p>基本思想是用一个进程监视另一个进程，发生错误时修复错误。<br>监视关系有两种，Link和monitor，进程间可以建立link关系，对<strong>进程、端口</strong>和节点的<strong>时间偏移量</strong> 可以建立monitor关系。</p><ul><li>连接（link）<ul><li>link(PidOrPort) -&gt; true</li><li>链接进程退出，收到的是退出信号，这意味着只有<strong>系统进程</strong>能够处理错误，普通进程会<strong>传递退出信号</strong>并一同退出<br>转换为系统进程的函数：process_flag(trap_exit, true)</li></ul></li><li>监视（monitor）<ul><li>monitor(Type :: process, Item :: monitor_process_identifier()) -&gt; MonitorRef</li><li>monitor(Type :: port, Item :: monitor_port_identifier()) -&gt; MonitorRef</li><li>monitor(Type :: time_offset, Item :: clock_service) -&gt; MonitorRef</li><li>监视进程收到的是DOWN<strong>消息</strong>而不是退出信号，通常会被服务器用来监视客户端的行为<br>DOWN信号：{‘DOWN’, Ref, process, Pid2, Reason}</li></ul></li></ul><p>案例</p><ul><li><p>退出时监控者执行某些计算</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">on_exit</span><span class="params">(Pid, Fun)</span> -&gt;</span></span><br><span class="line">spawn(<span class="keyword">fun</span>() -&gt;</span><br><span class="line">Ref = monitor(process, Pid),</span><br><span class="line"><span class="keyword">receive</span></span><br><span class="line">&#123;&#x27;DOWN&#x27;, Ref, process, Pid, Why&#125; -&gt;</span><br><span class="line">Fun(Why)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>).</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建工作者进程</span></span><br><span class="line"><span class="number">2</span>&gt; Fun = <span class="keyword">fun</span>() -&gt;</span><br><span class="line">            <span class="keyword">receive</span></span><br><span class="line">            X -&gt; list_to_atom(X)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">          <span class="keyword">end</span>.</span><br><span class="line">#Fun&lt;erl_eval.<span class="number">20.118419387</span>&gt;</span><br><span class="line"><span class="number">3</span>&gt; Pid = spawn(Fun).</span><br><span class="line"></span><br><span class="line"><span class="comment">% 监控进程</span></span><br><span class="line"><span class="number">8</span>&gt; tt:on_exit(Pid,<span class="keyword">fun</span>(Why)-&gt;io:format(<span class="string">&quot;~p died with: ~p~n&quot;</span>, [Pid, Why])<span class="keyword">end</span>).</span><br><span class="line">&lt;<span class="number">0.79</span>.<span class="number">0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 使进程发送错误</span></span><br><span class="line"><span class="number">9</span>&gt; Pid ! hello.</span><br><span class="line">&lt;<span class="number">0.64</span>.<span class="number">0</span>&gt; died with: &#123;badarg,[&#123;erlang,list_to_atom,[hello],[]&#125;]&#125;</span><br></pre></td></tr></table></figure></li><li><p>让一组进程共同终止</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">start</span><span class="params">(Fs)</span> -&gt;</span></span><br><span class="line">  spawn(<span class="keyword">fun</span>() -&gt;</span><br><span class="line">    [spawn_link(F) || F &lt;- Fs],</span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">    <span class="keyword">after</span></span><br><span class="line">      infinity -&gt; <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span>).</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">67</span>&gt;  Fun1 = <span class="keyword">fun</span>()-&gt;<span class="number">1</span><span class="keyword">end</span>.</span><br><span class="line">#Fun&lt;erl_eval.<span class="number">20.118419387</span>&gt;</span><br><span class="line"><span class="number">68</span>&gt; Fun2 = <span class="keyword">fun</span>()-&gt;<span class="number">2</span><span class="keyword">end</span>.</span><br><span class="line">#Fun&lt;erl_eval.<span class="number">20.118419387</span>&gt;</span><br><span class="line"><span class="number">69</span>&gt; Pid=spawn_test:start([Fun1,Fun2]). </span><br><span class="line">&lt;<span class="number">0.231</span>.<span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建永不终止的进程（退出时重启进程）</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">keep_alive</span><span class="params">(Name, Fun)</span> -&gt;</span></span><br><span class="line">register(Name, Pid = spawn(Fun)),</span><br><span class="line">on_exit(Pid, <span class="keyword">fun</span>(_Why) -&gt; keep_alive(Name, Fun) <span class="keyword">end</span>).</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>&gt; tt:keep_alive(worker,Fun).    </span><br><span class="line">&lt;<span class="number">0.64</span>.<span class="number">0</span>&gt;</span><br><span class="line"><span class="number">5</span>&gt; worker!hello.</span><br><span class="line">hello</span><br><span class="line"><span class="number">6</span>&gt;</span><br><span class="line">=ERROR REPORT==== <span class="number">21</span>-Jun-<span class="number">2023</span>::<span class="number">17</span>:<span class="number">35</span>:<span class="number">47</span> ===</span><br><span class="line">Error in process &lt;<span class="number">0.63</span>.<span class="number">0</span>&gt; with exit value:</span><br><span class="line">&#123;badarg,[&#123;erlang,list_to_atom,[hello],[]&#125;]&#125;</span><br><span class="line"><span class="number">6</span>&gt; worker!hello.</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>&gt; worker!hello.</span><br><span class="line">=ERROR REPORT==== <span class="number">21</span>-Jun-<span class="number">2023</span>::<span class="number">17</span>:<span class="number">35</span>:<span class="number">51</span> ===</span><br><span class="line">Error in process &lt;<span class="number">0.69</span>.<span class="number">0</span>&gt; with exit value:</span><br><span class="line">&#123;badarg,[&#123;erlang,list_to_atom,[hello],[]&#125;]&#125;</span><br><span class="line">hello</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2></li></ul><p>TODO</p><h2 id="链接Link"><a href="#链接Link" class="headerlink" title="链接Link"></a>链接Link</h2><p>TODO</p><h2 id="监督Monitor"><a href="#监督Monitor" class="headerlink" title="监督Monitor"></a>监督Monitor</h2><p>TODO</p><h2 id="进程字典"><a href="#进程字典" class="headerlink" title="进程字典"></a>进程字典</h2><p>进程字典是一个属于<strong>本进程</strong>的键值对数据结构，每个进程都存在一个进程区域存放进程字典。</p><ul><li><code>put(Key,value)-&gt;OldValue</code><br>注意会返回旧值</li><li><code>get(Key-&gt;Value)</code></li><li><code>get()-[&#123;Key,Value&#125;]</code></li><li><code>erase(Key)-&gt;Value</code></li><li><code>erase()-&gt;[&#123;Key,Value&#125;]</code><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>&gt; put(a,<span class="number">1</span>).</span><br><span class="line">undefined</span><br><span class="line"><span class="number">8</span>&gt; get(a).</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">9</span>&gt; put(a,<span class="number">2</span>). </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">10</span>&gt; get().</span><br><span class="line">[&#123;a,<span class="number">2</span>&#125;]</span><br></pre></td></tr></table></figure>注意：进程字典在实际中较少用，因为可能会给程序引入不易察觉的bug（有时会忘记使用了进程字典），让调试变得困难。<br>建议使用进程字典来保存“<strong>一次性写入</strong>”的变量。如果某个键一次性获得一个值而且不会改变它，那么将其保存在进程字典里在某些时候还是可以接受的。</li></ul><h1 id="分布式编程"><a href="#分布式编程" class="headerlink" title="分布式编程"></a>分布式编程</h1><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>分布式erlang以节点为中心，节点是一个命名的ERTS，可以在同一台机器或在不同机器上，许多个节点组成一个分布式系统。</p><ul><li><p>节点命名，在一个分布式系统内，所有节点都必须使用同种命名模式，例如全是短命名，或者全是长命名。</p><ul><li><p>命名格式：<a href="mailto:&#110;&#97;&#109;&#x65;&#x40;&#104;&#x6f;&#x73;&#x74;&#x2e;&#x6e;&#97;&#109;&#x65;">&#110;&#97;&#109;&#x65;&#x40;&#104;&#x6f;&#x73;&#x74;&#x2e;&#x6e;&#97;&#109;&#x65;</a></p><ul><li>name为<code>-sname</code>或<code>-name</code>指定的节点名</li><li>host.name为主机标识，例如：”<a href="http://www.example.com&quot;或&quot;server1&quot;/">www.example.com&quot;或&quot;server1&quot;</a><br>配置hostname</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hostname</span><br><span class="line">sudo hostnamectl set-hostname your-new-hostname</span><br><span class="line">sudo systemctl restart NetworkManager</span><br><span class="line">%%</span><br><span class="line">sudo hostname new-hostname</span><br></pre></td></tr></table></figure></li></ul></li><li><p>节点间通信，为了能够相互通信， Erlang 的节点问必须共享一个私密的cookie 值。</p><ul><li><p>本机通信，可以使用短命名</p></li><li><p>局域网通信，可以使用短命名</p></li><li><p>外网通信</p><p>为了找到host，需要配置host文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost</span><br><span class="line">::1         localhost</span><br><span class="line"></span><br><span class="line">192.168.142.129 server.com server</span><br><span class="line">192.168.142.130 client.com client</span><br></pre></td></tr></table></figure></li><li><p>检测连通性<br><code>net_adm:ping(&#39;gandalf@server.com&#39;).</code></p></li></ul></li><li><p>连接节点，采用松散连接的方式，会在第一次用到节点名时连接：spawn(Node,M,F,A) or net_adm:ping(Node)</p></li></ul><p>注意事项：</p><p>hostname必须有点，单独一个server会报错，必须是<a href="http://www.server.com的形式/">www.server.com的形式</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(bilbo@client)1&gt; rpc:call(&#x27;gandalf@server&#x27;, kvs, store, [weather, cold]).</span><br><span class="line">=ERROR REPORT==== 24-Jun-2023::15:57:51.579811 ===</span><br><span class="line">** System running to use fully qualified hostnames **</span><br><span class="line">** Hostname server is illegal **</span><br></pre></td></tr></table></figure><h2 id="防火墙和端口"><a href="#防火墙和端口" class="headerlink" title="防火墙和端口"></a>防火墙和端口</h2><p>关闭防火墙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><p>打开所有端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure><h2 id="局域网通信"><a href="#局域网通信" class="headerlink" title="局域网通信"></a>局域网通信</h2><p>服务器</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[hz@server socket_dist]$ erl -name gandalf -setcookie abc</span><br><span class="line">Erlang/OTP <span class="number">25</span> [erts-<span class="number">13.2</span>.<span class="number">1</span>] [source] [<span class="number">64</span>-bit] [smp:<span class="number">4</span>:<span class="number">4</span>] [ds:<span class="number">4</span>:<span class="number">4</span>:<span class="number">10</span>] [async-threads:<span class="number">1</span>] [jit:ns]</span><br><span class="line"></span><br><span class="line">Eshell V13.<span class="number">2.1</span>  (abort with ^G)</span><br><span class="line">(gandalf@server.com)<span class="number">1</span>&gt; kvs:start().</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[hz@client ~]$ erl -name bilbo -setcookie abc</span><br><span class="line">Erlang/OTP 25 [erts-13.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [jit:ns]</span><br><span class="line"></span><br><span class="line">Eshell V13.2.1  (abort with ^G)</span><br><span class="line">(bilbo@client.com)1&gt; net_adm:ping(&#x27;gandalf@server.com&#x27;).</span><br><span class="line">pong</span><br><span class="line">(bilbo@client.com)2&gt; rpc:call(&#x27;gandalf@server.com&#x27;, kvs, store, [weather, cold]).</span><br><span class="line">true</span><br><span class="line">(bilbo@client.com)3&gt; rpc:call(&#x27;gandalf@server.com&#x27;, kvs, lookup, [weather]). </span><br><span class="line">&#123;ok,cold&#125;</span><br></pre></td></tr></table></figure><h2 id="外网通信"><a href="#外网通信" class="headerlink" title="外网通信"></a>外网通信</h2><ol><li><p>确保4369端口对TCP和UDP流量，都开放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -L</span><br><span class="line"># 如果防火墙规则中没有针对4369端口的条目，则新增</span><br><span class="line">sudo iptables -A INPUT -p tcp --dport 4369 -j ACCEPT</span><br><span class="line">sudo iptables -A INPUT -p udp --dport 4369 -j ACCEPT</span><br><span class="line"># 让设置生效</span><br><span class="line">sudo yum install iptables-services</span><br><span class="line">sudo systemctl enable iptables</span><br><span class="line">sudo service iptables save</span><br><span class="line"># </span><br><span class="line">sudo iptables -L</span><br></pre></td></tr></table></figure></li><li><p>选择一个或一段连续端口给分布式Erlang使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">erl -name gandalf -setcookie abc -kernel inet_dist_listen_min 1024 \ inet_dist_listen_max 65536</span><br></pre></td></tr></table></figure></li></ol><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>在阿里云的ecs上测试，用net_adm:ping不通，暂不知道是端口还是host设置有问题，待解决。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制型与位语法</title>
      <link href="/2023/06/22/%E4%BD%8D%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/06/22/%E4%BD%8D%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>二进制型与位语法（bit-syntax）<span id="more"></span></p><p>[<a href="https://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax">https://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax</a></p><h1 id="二进制型"><a href="#二进制型" class="headerlink" title="二进制型"></a>二进制型</h1><p>二进制型就是由尖括号 <strong>&lt;&lt;** 和 **&gt;&gt;</strong> 包围的整数（0-255）或字符串。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span>&gt; &lt;&lt;<span class="number">1</span>,<span class="string">&quot;abc&quot;</span>&gt;&gt;.     </span><br><span class="line">&lt;&lt;<span class="number">1</span>,<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&gt;&gt;</span><br><span class="line"><span class="number">7</span>&gt; &lt;&lt;<span class="number">256</span>,<span class="string">&quot;abc&quot;</span>&gt;&gt;. </span><br><span class="line">&lt;&lt;<span class="number">0</span>,<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&gt;&gt;</span><br></pre></td></tr></table></figure><p>IoList是包含字符列表和二进制型的列表，可以嵌套来标识复杂的结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5&gt; [&quot;hello&quot;, [32], &lt;&lt;&quot;world&quot;&gt;&gt;].</span><br><span class="line">[&quot;hello&quot;,&quot; &quot;,&lt;&lt;&quot;world&quot;&gt;&gt;]</span><br><span class="line">6&gt; iolist_to_binary([&quot;hello&quot;, [32], &lt;&lt;&quot;world&quot;&gt;&gt;]). </span><br><span class="line">&lt;&lt;&quot;hello world&quot;&gt;&gt;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/iteye_13453/article/details/82343274">https://blog.csdn.net/iteye_13453/article/details/82343274</a></p><p>BIF</p><ul><li><p>list_to_binary(IoList) -&gt; binary()<br>将IOList拍扁为一个大二进制数据</p></li><li><p>split_binary(Bin, Pos) -&gt; {binary(), binary()}</p></li><li><p>term_to_binary(Term) -&gt; ext_binary()</p></li><li><p>term_to_binary(Term, Options) -&gt; ext_binary()</p></li><li><p>binary_to_term(Binary) -&gt; term()</p></li><li><p>binary_to_term(Binary, Opts) -&gt; term() | {term(), Used}</p></li><li><p>bit_size(Bitstring) -&gt; integer() &gt;= 0<br>返回所占字节数</p></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建包含两个字节的二进制</span></span><br><span class="line">&lt;&lt;<span class="number">16</span>, <span class="number">32</span>&gt;&gt;.</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建包含字符 &#x27;A&#x27; 和 &#x27;B&#x27; 的二进制</span></span><br><span class="line">&lt;&lt;<span class="number">65</span>, <span class="number">66</span>&gt;&gt;.</span><br><span class="line">&lt;&lt;$A, $B&gt;&gt;.  <span class="comment">% 使用字符表示</span></span><br><span class="line"><span class="comment">%  &lt;&lt;&quot;abc&quot;&gt;&gt;实际上是 `&lt;&lt;$a,$b,$c&gt;&gt;`的语法糖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建包含字符串 &quot;Hello&quot; 的二进制</span></span><br><span class="line">&lt;&lt;<span class="string">&quot;Hello&quot;</span>&gt;&gt;.</span><br><span class="line"></span><br><span class="line"><span class="comment">% 嵌套二进制</span></span><br><span class="line">&lt;&lt;<span class="number">1</span>, &lt;&lt;<span class="number">2</span>, <span class="number">3</span>&gt;&gt;, <span class="number">4</span>&gt;&gt;.</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建具有变量的二进制</span></span><br><span class="line">Value = <span class="number">42</span>,</span><br><span class="line">&lt;&lt;Value&gt;&gt;.</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建二进制的部分片段</span></span><br><span class="line">Binary = &lt;&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt;&gt;,</span><br><span class="line">SubBinary = &lt;&lt;Binary/binary, <span class="number">3</span>:<span class="number">1</span>&gt;&gt;.  <span class="comment">% 从 Binary 的第 3 字节开始，取 1 字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 对应大于255的整数似乎会截断</span></span><br><span class="line"><span class="number">1</span>&gt; byte_size(&lt;&lt;<span class="number">999999999999999999999999999999999999999999999999999999999999999</span>&gt;&gt;).   </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span>&gt; byte_size(term_to_binary(<span class="number">999999999999999999999999999999999999999999999999999999999999999</span>)). </span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="number">3</span>&gt; split_binary(list_to_binary(<span class="string">&quot;0123456789&quot;</span>),<span class="number">3</span>). </span><br><span class="line">&#123;&lt;&lt;<span class="string">&quot;012&quot;</span>&gt;&gt;,&lt;&lt;<span class="string">&quot;3456789&quot;</span>&gt;&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：二进制是<strong>不可变</strong>的数据类型，一旦创建，就不能直接修改其中的字节或位。但可以使用模式匹配和一些函数来提取和处理二进制数据。<br> 操作二进制型，可以使用以下两种方式： </p><ul><li> 内置函数 </li><li> 位语法 </li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%X占3位 Y占7位 Z占6位 共16位</span></span><br><span class="line">M = &lt;&lt;X:<span class="number">3</span>, Y:<span class="number">7</span>, Z:<span class="number">6</span>&gt;&gt;.</span><br><span class="line"></span><br><span class="line">Red=<span class="number">2</span>.</span><br><span class="line">Green=<span class="number">61</span>.</span><br><span class="line">Blue=<span class="number">20</span>.</span><br><span class="line">Mem=&lt;&lt;Red:<span class="number">5</span>,Green:<span class="number">6</span>,Blue:<span class="number">5</span>&gt;&gt;.</span><br><span class="line">&lt;&lt;R1:<span class="number">5</span>,G2:<span class="number">6</span>,B3:<span class="number">5</span>&gt;&gt;=Mem.</span><br><span class="line">binary作为**模式**时，没有指定size的binary必须放在最后，&lt;&lt;Char, Rest/binary&gt;&gt;</span><br><span class="line">用于构造二进制型时，binary可以在任意位置，&lt;&lt;Acc/binary, Char&gt;&gt;</span><br></pre></td></tr></table></figure><p>type还是建议标上，否则容易发生segment的格式错误</p><p>关于位数有以下几种</p><ul><li>bit_size(Bitstring)<br>字节数乘以八</li><li>byte_size(Bitstring)</li><li>iolist_size(Item)</li><li>map_size(Map)</li><li>size(Item) -&gt; integer() &gt;= 0<br>返回字节数</li></ul><h1 id="位语法"><a href="#位语法" class="headerlink" title="位语法"></a>位语法</h1><p>用于从二进制数据里<strong>提取</strong>或<strong>加入</strong>单独的位或者位串，语法如下：</p><p>位串由一系列的段（segment）组成，每个segment用逗号 <strong>,</strong> 分隔。<br>segment的表示如下，size和type是可选的：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;E1,...,En&gt;&gt;</span><br><span class="line"></span><br><span class="line">Ei = Value |</span><br><span class="line">     Value:Size |</span><br><span class="line">     Value/TypeSpecifierList |</span><br><span class="line">     Value:Size/TypeSpecifierList</span><br></pre></td></tr></table></figure><ul><li><p>整数段<br>bit=size*units<br>高位会被截断，<code>&lt;&lt;16#ff:4&gt;&gt;</code>变成<code>&lt;&lt;15:4&gt;&gt;</code></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;<span class="number">1</span>:<span class="number">1</span>, <span class="number">0</span>:<span class="number">7</span>&gt;&gt;.</span><br></pre></td></tr></table></figure></li><li><p>浮点段<br>bits=size*units，size必须是16,32,64<br>构造位串时<br>位串匹配时</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>&gt; &lt;&lt;<span class="number">3.14159</span>:<span class="number">64</span>/float&gt;&gt;.</span><br><span class="line">&lt;&lt;<span class="number">64</span>,<span class="number">9</span>,<span class="number">33</span>,<span class="number">249</span>,<span class="number">240</span>,<span class="number">27</span>,<span class="number">134</span>,<span class="number">110</span>&gt;&gt;</span><br><span class="line"><span class="number">23</span>&gt; &lt;&lt;<span class="number">3.14159</span>:<span class="number">64</span>/float&gt;&gt; =:= &lt;&lt;<span class="number">3.14159</span>:<span class="number">64</span>/float&gt;&gt;. </span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>二进制段<br>type可以是binary, bitstring, bytes, and bits任意一种<br>binary类型长度必须是整字节</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt; &lt;&lt;(&lt;&lt;<span class="string">&quot;abc&quot;</span>&gt;&gt;)/bitstring&gt;&gt;.</span><br><span class="line">&lt;&lt;<span class="string">&quot;abc&quot;</span>&gt;&gt;</span><br><span class="line"><span class="number">2</span>&gt; &lt;&lt;(&lt;&lt;<span class="string">&quot;abc&quot;</span>&gt;&gt;)/binary-unit:<span class="number">1</span>&gt;&gt;.</span><br><span class="line">&lt;&lt;<span class="string">&quot;abc&quot;</span>&gt;&gt;</span><br><span class="line"><span class="number">3</span>&gt; &lt;&lt;(&lt;&lt;<span class="string">&quot;abc&quot;</span>&gt;&gt;)/binary&gt;&gt;.</span><br><span class="line">&lt;&lt;<span class="string">&quot;abc&quot;</span>&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt; &lt;&lt;(&lt;&lt;<span class="number">1</span>:<span class="number">1</span>&gt;&gt;)/binary&gt;&gt;.</span><br><span class="line">** exception error: bad argument</span><br><span class="line"><span class="number">2</span>&gt; &lt;&lt;(&lt;&lt;<span class="number">1</span>:<span class="number">1</span>&gt;&gt;)/bitstring&gt;&gt;.</span><br><span class="line">&lt;&lt;<span class="number">1</span>:<span class="number">1</span>&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p>Unicode段<br>type为utf8, utf16, and utf32</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><p>TODO：具体使用还是不熟悉</p><h1 id="位串"><a href="#位串" class="headerlink" title="位串"></a>位串</h1><p>位串（bitstring），位数不是8的整数倍的二进制型，可用于简化网络编程</p><p>获取size</p><ul><li>bit_size(Bitstring) -&gt; integer() &gt;= 0<br>返回比特数</li><li>byte_size(Bitstring) -&gt; integer() &gt;= 0<br>返回字节数</li><li>size(Item) -&gt; integer() &gt;= 0<br>获取元组或binary中的字节数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>erlang运行过程</title>
      <link href="/2023/06/22/Erlang%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/06/22/Erlang%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>erlang的编译运行过程</p><span id="more"></span><p><a href="https://www.erlang.org/doc/apps/kernel/users_guide.html">https://www.erlang.org/doc/apps/kernel/users_guide.html</a><br><a href="https://www.erlang.org/doc/apps/erts/users_guide.html">https://www.erlang.org/doc/apps/erts/users_guide.html</a><br><a href="https://www.erlang.org/doc/man/code.html">https://www.erlang.org/doc/man/code.html</a></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p><a href="https://www.erlang.org/doc/apps/compiler/internal_docs.html">https://www.erlang.org/doc/apps/compiler/internal_docs.html</a></p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p><a href="https://www.erlang.org/doc/reference_manual/modules.html">https://www.erlang.org/doc/reference_manual/modules.html</a></p><p>模块是编译的最小单位</p><ul><li>预定义模块属性，需要放在函数定义前<ul><li>-compile(Options).</li><li>-vsn(Vsn)</li><li>-on_load(Function)</li><li>-nifs(Functions)</li></ul></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>, stop/<span class="number">0</span>])</span>.</span><br></pre></td></tr></table></figure><ul><li>行为属性，指定本模块是一个行为的回调模块</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-behaviour</span><span class="params">(gen_server)</span>.</span><br></pre></td></tr></table></figure><ul><li>定义记录</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-record</span><span class="params">(Record,Fields)</span>.</span><br></pre></td></tr></table></figure><ul><li>预处理器</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include</span><span class="params">(<span class="string">&quot;SomeFile.hrl&quot;</span>)</span>.</span><br><span class="line"><span class="keyword">-define</span><span class="params">(Macro,Replacement)</span>.</span><br></pre></td></tr></table></figure><ul><li>设置预定义宏<code>?FILE</code>和<code>LINE</code></li></ul><p>用于获取当前代码所在源文件路径和行数</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(example)</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([test/<span class="number">0</span>])</span>.</span><br><span class="line"><span class="function"><span class="title">test</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;This code is in file ~p\n&quot;</span>, [?FILE]),</span><br><span class="line">  io:format(<span class="string">&quot;This code is on line ~p\n&quot;</span>, [?LINE]).</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>&gt; test:t().</span><br><span class="line">This code is in file <span class="string">&quot;test.erl&quot;</span></span><br><span class="line">This code is on line <span class="number">18</span></span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>获取模块信息</p><ul><li>Module:module_info/0<br>获取全部</li><li>Module:module_info/1<br>获取指定</li></ul><p>既可以在内部调用，也可以在外部调用</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">test</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;module_info(): ~w~n&quot;</span>, [module_info()]),</span><br><span class="line">  io:format(<span class="string">&quot;module_info(exports): ~w~n&quot;</span>, [module_info(exports)]).</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>&gt; test:test().</span><br><span class="line"><span class="function"><span class="title">module_info</span><span class="params">()</span>: [&#123;<span class="title">module</span>,<span class="title">test</span>&#125;,&#123;<span class="title">exports</span>,[&#123;<span class="title">t</span>,0&#125;,&#123;<span class="title">module_info</span>,0&#125;,&#123;<span class="title">module_info</span>,1&#125;]&#125;,&#123;<span class="title">attributes</span>,[&#123;<span class="title">vsn</span>,[143092041070811311060369436838556452033]&#125;,&#123;<span class="title">author</span>,[104,122]&#125;]&#125;,&#123;<span class="title">compile</span>,[&#123;<span class="title">options</span>,[]&#125;</span></span><br><span class="line"><span class="function">,&#123;<span class="title">version</span>,[55,46,48,46,52]&#125;,&#123;<span class="title">source</span>,[99,58,47,85,115,101,114,115,47,104,122,47,68,101,115,107,116,111,112,47,69,114,108,97,110,103,80,114,111,106,101,99,116,47,108,101,97,114,110,45,10</span></span><br><span class="line"><span class="function">1,114,108,97,110,103,47,116,101,115,116,46,101,114,108]&#125;]&#125;,&#123;<span class="title">md5</span>,&lt;&lt;107,166,134,80,200,224,177,195,62,104,95,214,83,233,196,193&gt;&gt;&#125;]</span></span><br><span class="line"><span class="function"><span class="title">module_info</span><span class="params">(exports)</span>: [&#123;<span class="title">t</span>,0&#125;,&#123;<span class="title">module_info</span>,0&#125;,&#123;<span class="title">module_info</span>,1&#125;]</span></span><br><span class="line"><span class="function">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="function">14&gt; <span class="title">test</span>:<span class="title">module_info</span><span class="params">()</span>.</span></span><br><span class="line"><span class="function">[&#123;<span class="title">module</span>,<span class="title">test</span>&#125;,</span></span><br><span class="line"><span class="function"> &#123;<span class="title">exports</span>,[&#123;<span class="title">t</span>,0&#125;,&#123;<span class="title">module_info</span>,0&#125;,&#123;<span class="title">module_info</span>,1&#125;]&#125;,</span></span><br><span class="line"><span class="function"> &#123;<span class="title">attributes</span>,[&#123;<span class="title">vsn</span>,[143092041070811311060369436838556452033]&#125;,</span></span><br><span class="line"><span class="function">              &#123;<span class="title">author</span>,&quot;<span class="title">hz</span>&quot;&#125;]&#125;,</span></span><br><span class="line"><span class="function"> &#123;<span class="title">compile</span>,[&#123;<span class="title">options</span>,[]&#125;,</span></span><br><span class="line"><span class="function">           &#123;<span class="title">version</span>,&quot;7.0.4&quot;&#125;,</span></span><br><span class="line"><span class="function">           &#123;<span class="title">source</span>,&quot;<span class="title">c</span>:/U<span class="title">sers</span>/<span class="title">hz</span>/D<span class="title">esktop</span>/E<span class="title">rlangProject</span>/<span class="title">learn</span>-<span class="title">erlang</span>/<span class="title">test</span>.<span class="title">erl</span>&quot;&#125;]&#125;,</span></span><br><span class="line"><span class="function"> &#123;<span class="title">md5</span>,&lt;&lt;107,166,134,80,200,224,177,195,62,104,95,214,83,</span></span><br><span class="line"><span class="function">        233,196,193&gt;&gt;&#125;]</span></span><br></pre></td></tr></table></figure><p>其他接口</p><ul><li>code: get_object_code(Module) -&gt; {Module, Binary, Filename} | error<br>获取指定模块的BEAM字节码</li><li>which(Module) -&gt; Which<br>获取指定模块的文件路径</li></ul><h2 id="Compile-Server"><a href="#Compile-Server" class="headerlink" title="Compile Server"></a>Compile Server</h2><p>编译服务器可以避免为每个要编译的文件启动 Erlang 系统，从而潜在地加速多文件项目的构建。是否会加快构建速度取决于项目的性质和构建机器。</p><p>默认情况下编译服务器是关闭的，需要用指定 -server选项或者把环境变量ERLC_USE_SERVER 设置为yes or true</p><h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h1><h2 id="Code-Server"><a href="#Code-Server" class="headerlink" title="Code Server"></a>Code Server</h2><p>Code Server负责将已编译的代码加载到运行时系统（ERTS）中。</p><h2 id="ERTS启动模式"><a href="#ERTS启动模式" class="headerlink" title="ERTS启动模式"></a>ERTS启动模式</h2><p>有interactive和embedded两种启动方式</p><ul><li>interactive，启动时加载ERTS需要的模块，其他代码使用时在搜索路径尝试搜索和加载</li><li>embedded，不会自动加载代码，使用引导脚本加载全部模块时使用这种方式启动。</li></ul><p>可以看到embedded模式下搜索路径只有kernel和stdlib。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">erl -mode embedded </span><br><span class="line"><span class="number">1</span>&gt; code:get_path().</span><br><span class="line">[<span class="string">&quot;c:/Program Files/erl8.3/lib/kernel-5.2/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/stdlib-3.3/ebin&quot;</span>]</span><br><span class="line"></span><br><span class="line">erl -mode interactive </span><br><span class="line"><span class="number">1</span>&gt; code:get_path().</span><br><span class="line">[<span class="string">&quot;.&quot;</span>,<span class="string">&quot;c:/Program Files/erl8.3/lib/kernel-5.2/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/stdlib-3.3/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/xmerl-1.3.13/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/wx-1.8/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/typer-0.9.12/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/tools-2.9.1/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/syntax_tools-2.1.1/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/ssl-8.1.1/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/ssh-4.4.1/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/snmp-5.2.5/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/sasl-3.0.3/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/runtime_tools-1.11.1/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/reltool-0.7.3/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/public_key-1.4/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/percept-0.9/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/parsetools-2.1.4/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/otp_mibs-1.1.1/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/os_mon-2.4.2/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/orber-3.8.2/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/odbc-2.12/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/mnesia-4.14.3/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/megaco-3.18.1/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/jinterface-1.7.1/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/inets-6.3.6/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/ic-4.4.2/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/hipe-3.15.4/ebin&quot;</span>,</span><br><span class="line"> [...]|...]</span><br></pre></td></tr></table></figure><h2 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h2><p>interactive模式下Code Server维护一个搜索路径，称为<strong>code path，</strong>用于实现代码的按需加载。<br>添加路径的方式</p><ul><li>add_patha(Dir) -&gt; add_path_ret()<br>向载入路径的开头添加一个新目录Dir</li><li>add_pathz(Dir) -&gt; add_path_ret()<br>向载入路径的末端添加一个新目录Dir</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt; code:get_path().</span><br><span class="line">[<span class="string">&quot;c:/Program Files/erl8.3/lib/kernel-5.2/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/stdlib-3.3/ebin&quot;</span>]</span><br><span class="line"><span class="number">2</span>&gt; code:add_patha(<span class="string">&quot;.&quot;</span>).</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="number">3</span>&gt; code:get_path().     </span><br><span class="line">[<span class="string">&quot;.&quot;</span>,<span class="string">&quot;c:/Program Files/erl8.3/lib/kernel-5.2/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/stdlib-3.3/ebin&quot;</span>]</span><br></pre></td></tr></table></figure><h2 id="热更新（动态代码载入）"><a href="#热更新（动态代码载入）" class="headerlink" title="热更新（动态代码载入）"></a>热更新（动态代码载入）</h2><h3 id="热更新简介"><a href="#热更新简介" class="headerlink" title="热更新简介"></a>热更新简介</h3><p>a是主模块，b是被调用的回调模块<br><code>a.erl</code></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">start</span><span class="params">(Tag)</span> -&gt;</span></span><br><span class="line">spawn(<span class="keyword">fun</span>()-&gt;loop(Tag)<span class="keyword">end</span>).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">loop</span><span class="params">(Tag)</span> -&gt;</span></span><br><span class="line">sleep(),</span><br><span class="line">Val = b:get_value(),</span><br><span class="line">io:format(<span class="string">&quot;Vsn1 (~p) Val is ~p~n&quot;</span>,[Tag, Val]),</span><br><span class="line">loop(Tag).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sleep</span><span class="params">()</span> -&gt;</span> <span class="keyword">receive</span></span><br><span class="line"> <span class="keyword">after</span></span><br><span class="line"> <span class="number">3000</span> -&gt;</span><br><span class="line"> ok</span><br><span class="line"> <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p><code>b.erl</code></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">get_value</span><span class="params">()</span> -&gt;</span></span><br><span class="line"><span class="number">1</span>.</span><br></pre></td></tr></table></figure><p>实验1<br>把b模块get_value返回值改为9，<strong>回调模块重新编译，旧程序会调用新的函数</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>&gt; a:start(one).</span><br><span class="line">&lt;<span class="number">0.67</span>.<span class="number">0</span>&gt;</span><br><span class="line"><span class="number">4</span>&gt; Vsn1 (one) Val is <span class="number">1</span></span><br><span class="line"><span class="number">4</span>&gt; Vsn1 (one) Val is <span class="number">1</span></span><br><span class="line"><span class="number">5</span>&gt; Vsn1 (one) Val is <span class="number">9</span></span><br></pre></td></tr></table></figure><p>实验2<br>把a模块中loop中的Vsn1改为Vsn2，<strong>主模块重新编译启动，两个程序同时存在</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>&gt; c(a).</span><br><span class="line"><span class="number">6</span>&gt; a:start(two).</span><br><span class="line">&lt;<span class="number">0.79</span>.<span class="number">0</span>&gt;</span><br><span class="line"><span class="number">7</span>&gt; Vsn1 (one) Val is <span class="number">9</span></span><br><span class="line"><span class="number">7</span>&gt; Vsn2 (two) Val is <span class="number">9</span></span><br></pre></td></tr></table></figure><p>实验3<br>把a模块中loop中的Vsn2改为Vsn3，<strong>主模块再次重新编译启动，Vsn1已经消失，即只会存在两个版本的程序，添加第三个以后的版本会终止第一个版本的程序</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span>&gt; c(a).</span><br><span class="line"><span class="number">9</span>&gt; a:start(two).</span><br><span class="line">&lt;<span class="number">0.86</span>.<span class="number">0</span>&gt;</span><br><span class="line"><span class="number">9</span>&gt; Vsn2 (two) Val is <span class="number">9</span></span><br><span class="line"><span class="number">9</span>&gt; Vsn3 (three) Val is <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="热更新原理"><a href="#热更新原理" class="headerlink" title="热更新原理"></a>热更新原理</h3><p>TODO</p><h1 id="编译和运行程序"><a href="#编译和运行程序" class="headerlink" title="编译和运行程序"></a>编译和运行程序</h1><ol><li> Erlang shell中编译运行 </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c(hello).</span><br><span class="line">hello:hello().</span><br></pre></td></tr></table></figure><ol start="2"><li>命令行中编译运行 </li></ol><ul><li><ul><li>-noshell 以不带交互式shell的方式启动Erlang（因此不会看到Erlang的“徽标”，也就是通常系统启动时首先显示的那些信息）。</li></ul></li><li><ul><li>-s hello start 运行hello:start()函数。注意：使用-s Mod …选项时，Mod必须是已编译的。</li></ul></li><li><ul><li>-s init stop 在之前的命令完成后执行init:stop()函数，从而停止系统。</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">erlc hello.erl</span><br><span class="line">erl -noshell -s hello start -s init stop</span><br></pre></td></tr></table></figure><ol start="3"><li>作为Escript运行 </li></ol><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env escript</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(Args)</span>-&gt;</span></span><br><span class="line">    io:format(<span class="string">&quot;hello world ~n&quot;</span>).</span><br></pre></td></tr></table></figure><h1 id="erl和erlc使用"><a href="#erl和erlc使用" class="headerlink" title="erl和erlc使用"></a>erl和erlc使用</h1><h2 id="erl"><a href="#erl" class="headerlink" title="erl"></a>erl</h2><p><a href="https://www.erlang.org/doc/man/erl.html">Erlang – erl</a></p><p><strong>emulator flags</strong></p><p>+开头，模拟器选项，指定一些，如异步线程池中线程的建议堆栈大小、ETS表数量上限等。</p><p><strong>flags</strong></p><p>传入ERTS中的init系统进程</p><p><strong>plain arguments</strong>:</p><p>也传入到init进程中，不会以任何方式解析，可以用<code>init:get_plain_arguments/0 </code>获取，个人理解是作为类似常量的方式使用。</p><ul><li>-noshell </li><li>-pa<br>将指定目录加入到搜索路径</li><li>-s Mod [Func [Arg1, Arg2, …]] (init flag)<br>初始化要处理MFA，例如 <code>-s z_compile compile_change ../boot/Emakefile</code> 表示让init进程调用z_compile模块的compile_change/1 方法，参数为一个Emakefile文件位置</li></ul><h2 id="erlc"><a href="#erlc" class="headerlink" title="erlc"></a>erlc</h2><p>TODO</p><h1 id="Erts"><a href="#Erts" class="headerlink" title="Erts"></a>Erts</h1><p>TODO</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统监控</title>
      <link href="/2023/06/22/Linux%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/"/>
      <url>/2023/06/22/Linux%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<p>Linux中系统监控的工具，进程、IO、网络等。</p><span id="more"></span><h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><ul><li><p>ps：显示当前所有<strong>进程</strong>的运行情况。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">13316 pts/0    00:00:00 bash</span><br><span class="line">16999 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure></li><li><p>top：<strong>实时显示</strong>当前所有<strong>任务</strong>的资源占用情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                </span><br><span class="line"> 1173 root      10 -10  166140  49928  10452 S   1.7  2.8   2:24.79 AliYunDunMonito                                                                        </span><br><span class="line">13233 hz        20   0  709408  46020  15864 S   1.0  2.6   0:06.84 node                                                                                   </span><br><span class="line"> 1109 root      20   0  815440  14616   7292 S   0.3  0.8   0:08.32 aliyun-service                                                                         </span><br><span class="line">    1 root      20   0   43628   4000   2600 S   0.0  0.2   0:00.77 systemd                                                                                </span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kthreadd                                                                               </span><br><span class="line">    4 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H                                                                           </span><br><span class="line">    6 root      20   0       0      0      0 S   0.0  0.0   0:00.12 ksoftirqd/0             </span><br></pre></td></tr></table></figure></li><li><p>pstree 以树状的模式输出进程列表，该模式显示了进程间的父/子关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ pstree</span><br><span class="line">systemd─┬─AliYunDun───9*[&#123;AliYunDun&#125;]</span><br><span class="line">        ├─AliYunDunMonito───25*[&#123;AliYunDunMonito&#125;]</span><br><span class="line">        ├─AliYunDunUpdate───6*[&#123;AliYunDunUpdate&#125;]</span><br><span class="line">        ├─2*[agetty]</span><br><span class="line">        ├─aliyun-service───7*[&#123;aliyun-service&#125;]</span><br><span class="line">        ├─assist_daemon───7*[&#123;assist_daemon&#125;]</span><br><span class="line">        ├─atd</span><br><span class="line">        ├─auditd───&#123;auditd&#125;</span><br><span class="line">        ├─chronyd</span><br><span class="line">        ├─crond</span><br><span class="line">        ├─dbus-daemon</span><br><span class="line">        ├─dhclient</span><br><span class="line">        ├─epmd</span><br><span class="line">        ├─gssproxy───5*[&#123;gssproxy&#125;]</span><br><span class="line">        ├─master─┬─pickup</span><br><span class="line">        │        └─qmgr</span><br><span class="line">        ├─polkitd───6*[&#123;polkitd&#125;]</span><br><span class="line">        ├─rpcbind</span><br><span class="line">        ├─rsyslogd───2*[&#123;rsyslogd&#125;]</span><br><span class="line">        ├─sshd───sshd───sshd───bash─┬─sh───node─┬─node─┬─bash─┬─pstree</span><br><span class="line">        │                           │           │      │      └─python3</span><br><span class="line">        │                           │           │      ├─bash</span><br><span class="line">        │                           │           │      └─12*[&#123;node&#125;]</span><br><span class="line">        │                           │           ├─node─┬─node───6*[&#123;node&#125;]</span><br><span class="line">        │                           │           │      └─11*[&#123;node&#125;]</span><br><span class="line">        │                           │           ├─node───12*[&#123;node&#125;]</span><br><span class="line">        │                           │           └─10*[&#123;node&#125;]</span><br><span class="line">        │                           └─sleep</span><br><span class="line">        ├─systemd-journal</span><br><span class="line">        ├─systemd-logind</span><br><span class="line">        ├─systemd-udevd</span><br><span class="line">        └─tuned───4*[&#123;tuned&#125;]</span><br></pre></td></tr></table></figure></li><li><p>vmstat<br>虚拟内存统计，报告有关进程、内存、分页、块 IO、中断和 CPU 活动等信息。<br>如果想要持续查看输出，可以在命令后面加上一个间隔时间（以秒为单位），命令将按照间隔时间来动态更新显示的内容（比如，vmstat 5）。按下Ctrl-C键可以终止输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ vmstat 5</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 1  0      0 158636  49584 1228320    0    0    38    52  936 1747  2  1 98  0  0</span><br></pre></td></tr></table></figure></li><li><p>jobs：列出所有活动作业的状态信息。</p></li></ul><h3 id="控制进程"><a href="#控制进程" class="headerlink" title="控制进程"></a>控制进程</h3><h4 id="暂停和中断进程"><a href="#暂停和中断进程" class="headerlink" title="暂停和中断进程"></a>暂停和中断进程</h4><p>按下<strong>Ctrl-Z</strong>键，程序将会暂停，此时可以用fg和bg让其继续工作。</p><p>在终端里按下<strong>Ctrl-C</strong>键将会中断（interrupt）一个程序，它意味着我们委婉地<strong>请求程序结束</strong>。许多（但不是所有）命令行程序都可以使用这种方法来实现中断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ jobs</span><br><span class="line">[hz@aliyun erlang-project]$ python3</span><br><span class="line">Python 3.6.8 (default, Nov 16 2020, 16:55:22) </span><br><span class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-44)] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">[1]+  Stopped                 python3</span><br><span class="line">[hz@aliyun erlang-project]$ jobs</span><br><span class="line">[1]+  Stopped                 python3</span><br></pre></td></tr></table></figure><h4 id="使进程后台运行"><a href="#使进程后台运行" class="headerlink" title="使进程后台运行"></a>使进程后台运行</h4><p>在命令后面加上和号字符（&amp;）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit &amp;</span><br></pre></td></tr></table></figure><h4 id="使进程回到前台运行"><a href="#使进程回到前台运行" class="headerlink" title="使进程回到前台运行"></a>使进程回到前台运行</h4><p>使用fg设置在前台中运行作业，要用到作业编号（jobspec选项），一般先用jobs命令查看挂起的进程的作业号，再用fg命令使其运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fg</span> %1</span><br></pre></td></tr></table></figure><h4 id="在后台运行"><a href="#在后台运行" class="headerlink" title="在后台运行"></a>在后台运行</h4><p>此时可以用fg命令设置在前台中运行作业，也可以用bg命令设置在后台中运行作业。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bg</span> %1</span><br></pre></td></tr></table></figure><h2 id="IO相关"><a href="#IO相关" class="headerlink" title="IO相关"></a>IO相关</h2><ul><li><p>iostat CPU 的使用情况，以及设备、分区和网络文件系统（NFS）的 IO 统计信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ iostat </span><br><span class="line">Linux 3.10.0-1160.90.1.el7.x86_64 (aliyun.ecs)  06/24/2023      _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           1.58    0.00    0.60    0.06    0.00   97.76</span><br><span class="line"></span><br><span class="line">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line">vda               5.12        68.74        95.46     593791     824644</span><br></pre></td></tr></table></figure></li><li><p>iotop 命令利用 Linux 内核监控 I/O 使用情况，它按进程或线程的顺序显示 I/O 使用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> sudo iotop</span><br><span class="line"> </span><br><span class="line"> TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND                                                                                     </span><br><span class="line">13312 be/4 hz          0.00 B/s    0.00 B/s  0.00 %  0.00 % node /home/hz/.vscode-server/bin/97dec172d3256f~onServerMain --node-ipc --clientProcessId=13267</span><br><span class="line">    1 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % systemd --switched-root --system --deserialize 22</span><br><span class="line">    2 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kthreadd]</span><br><span class="line">13315 be/4 hz          0.00 B/s    0.00 B/s  0.00 %  0.00 % node /home/hz/.vscode-server/bin/97dec172d3256f~onServerMain --node-ipc --clientProcessId=13267</span><br><span class="line">    4 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kworker/0:0H]</span><br><span class="line"> 1029 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % python2 -Es /usr/sbin/tuned -l -P</span><br><span class="line">    6 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/0]</span><br></pre></td></tr></table></figure></li></ul><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><ul><li><p>ping：向网络主机发送ICMP ECHO_REQUEST数据包。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ ping youkia.com</span><br><span class="line">PING youkia.com (117.78.38.96) 56(84) bytes of data.</span><br><span class="line">64 bytes from ecs-117-78-38-96.compute.hwclouds-dns.com (117.78.38.96): icmp_seq=1 ttl=46 time=55.3 ms</span><br><span class="line">64 bytes from ecs-117-78-38-96.compute.hwclouds-dns.com (117.78.38.96): icmp_seq=2 ttl=46 time=55.3 ms</span><br><span class="line">64 bytes from ecs-117-78-38-96.compute.hwclouds-dns.com (117.78.38.96): icmp_seq=3 ttl=46 time=55.3 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>traceroute：显示数据包到网络主机的路由路径。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ traceroute youkia.com</span><br><span class="line">traceroute to youkia.com (117.78.38.96), 30 hops max, 60 byte packets</span><br><span class="line"> 1  11.63.116.46 (11.63.116.46)  1.122 ms  1.124 ms  1.137 ms</span><br><span class="line"> 2  11.63.116.113 (11.63.116.113)  1.233 ms 10.124.228.125 (10.124.228.125)  1.290 ms 10.124.228.81 (10.124.228.81)  1.281 ms</span><br><span class="line"> 3  11.88.168.49 (11.88.168.49)  1.557 ms 11.48.239.121 (11.48.239.121)  1.137 ms 11.48.239.197 (11.48.239.197)  0.825 ms</span><br><span class="line"> 4  45.112.220.65 (45.112.220.65)  1.807 ms 45.112.220.89 (45.112.220.89)  1.356 ms 45.112.220.13 (45.112.220.13)  1.865 ms</span><br><span class="line"> 5  117.49.54.102 (117.49.54.102)  9.292 ms  9.277 ms 117.49.54.50 (117.49.54.50)  5.757 ms</span><br><span class="line"> 6  11.94.166.53 (11.94.166.53)  45.763 ms * 11.94.136.185 (11.94.136.185)  60.216 ms</span><br><span class="line"> 7  45.112.223.250 (45.112.223.250)  50.328 ms 10.102.154.246 (10.102.154.246)  41.797 ms 45.112.216.34 (45.112.216.34)  44.119 ms</span><br><span class="line"> 8  103.216.40.49 (103.216.40.49)  43.525 ms  43.945 ms  43.536 ms</span><br></pre></td></tr></table></figure></li><li><p>netstat：显示网络连接、路由表、网络接口数据、伪连接以及多点传送成员等信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ netstat -ie</span><br><span class="line">Kernel Interface table</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.173.142  netmask 255.255.240.0  broadcast 172.17.175.255</span><br><span class="line">        inet6 fe80::216:3eff:fe0d:5a2f  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:16:3e:0d:5a:2f  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 24134  bytes 7211877 (6.8 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 24984  bytes 14476371 (13.8 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 28338  bytes 5183587 (4.9 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 28338  bytes 5183587 (4.9 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>ss 获取套接字统计信息，可以显示类似于 netstat 的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 显示所有 TCP 或 UDP 套接字</span><br><span class="line">[hz@aliyun erlang-project]$ ss -t -a</span><br><span class="line">State       Recv-Q Send-Q                              Local Address:Port                                               Peer Address:Port                </span><br><span class="line">LISTEN      0      128                                             *:sunrpc                                                        *:*                    </span><br><span class="line">LISTEN      0      128                                             *:epmd                                                          *:*                   </span><br></pre></td></tr></table></figure></li><li><p>tcpdump</p><ul><li><p><strong>-i</strong> : 选择要捕获的接口，通常是以太网卡或无线网卡，也可以是 <code>vlan</code> 或其他特殊接口。如果该系统上只有一个网络接口，则无需指定。<br>注意：当是本机内部通信时, 走的是lo，此时是抓不到包的，必须指定网卡。</p></li><li><p><strong>-nn</strong> : 单个 n 表示不解析域名，直接显示 IP；两个 n 表示不解析域名和端口。这样不仅方便查看 IP 和端口号，而且在抓取大量数据时非常高效，因为域名解析会降低抓取速度。</p></li><li><p><strong>-s0</strong> : tcpdump 默认只会截取前 <code>96</code> 字节的内容，要想截取所有的报文内容，可以使用 <code>-s number</code>， <code>number</code> 就是你要截取的报文字节数，如果是 0 的话，表示截取报文全部内容。</p></li><li><p><strong>-v</strong> : 使用 <code>-v</code>，<code>-vv</code> 和 <code>-vvv</code> 来显示更多的详细信息，通常会显示更多与特定协议相关的信息。</p></li><li><p><code>port 80</code> : 这是一个常见的端口过滤器，表示仅抓取 <code>80</code> 端口上的流量，通常是 HTTP。</p></li><li><p>-A 以 ASCII 格式打印每个数据包</p></li></ul></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -nn -s0 -v port 80</span><br><span class="line">tcpdump -A -s0 port 80 <span class="comment"># 以ASCII字符串 打印数据包</span></span><br><span class="line">tcpdump -i eth0 udp <span class="comment"># 指定协议</span></span><br><span class="line">tcpdump -i eth0 proto 17 <span class="comment"># 同上一条命令</span></span><br><span class="line">tcpdump -i eth0 -s0 -w test.pcap <span class="comment"># 写入文件</span></span><br><span class="line">tcpdump -i eth0 -s0 -l port 80 | grep <span class="string">&#x27;Server:&#x27;</span> <span class="comment"># 要实时将抓取到的数据通过管道传递给其他工具来处理 需要使用行缓冲模式</span></span><br></pre></td></tr></table></figure><ul><li><p>过滤器</p><ul><li><p>过滤host</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host 1.2.3.4 # 指定主机 </span><br><span class="line">tcpdump -i eth0 dst 10.10.1.20 # src和dst是可选项=</span><br></pre></td></tr></table></figure></li><li><p>过滤网段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tcpdump net 192.168.1 # 三元组 192.168.1.x 发出或发往</span><br><span class="line">tcpdump src net 10 # 一元组 表示子网掩码255.0.0.0</span><br><span class="line"># 二元组 255.255.0.0</span><br><span class="line"># 四元组 某主机</span><br><span class="line">tcpdump src net 172.16.0.0/12 # CIDR</span><br></pre></td></tr></table></figure></li><li><p>过滤协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -n proto \\icmp# 保留字用双斜杠</span><br></pre></td></tr></table></figure></li><li><p>过滤端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump port 389</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="综合工具"><a href="#综合工具" class="headerlink" title="综合工具"></a>综合工具</h2><ul><li><p>dstat 显示 CPU 使用率、内存使用率、磁盘 I/O、网络流量等系统资源的情况</p><ul><li>-l ：显示负载统计量</li><li>-m ：显示内存使用率（包括used，buffer，cache，free值）</li><li>-r ：显示I/O统计</li><li>-s ：显示交换分区使用情况</li><li>-t ：将当前时间显示在第一行</li><li>–fs ：显示文件系统统计数据（包括文件总数量和inodes值）</li><li>–nocolor ：不显示颜色（有时候有用）</li><li>–socket ：显示网络统计数据</li><li>–tcp ：显示常用的TCP统计</li><li>–udp ：显示监听的UDP接口及其当前用量的一些动态数据</li><li>附带插件<ul><li>-–disk-util ：显示某一时间磁盘的忙碌状况</li><li>-–freespace ：显示当前磁盘空间使用率</li><li>-–proc-count ：显示正在运行的程序数量</li><li>-–top-bio ：指出块I/O最大的进程</li><li>-–top-cpu ：图形化显示CPU占用最大的进程</li><li>-–top-io ：显示正常I/O最大的进程</li><li>-–top-mem ：显示占用最多内存的进程</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ dstat</span><br><span class="line">You did not select any stats, using -cdngy by default.</span><br><span class="line">----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--</span><br><span class="line">usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw </span><br><span class="line">  2   1  98   0   0   0|  71k   98k|   0     0 |   0     0 |1851  3457 </span><br><span class="line">  1   1  98   0   0   0|   0     0 | 840B 3842B|   0     0 |2021  3567 </span><br><span class="line">  1   1  98   0   0   0|   0     0 | 120B  260B|   0     0 |1854  3420 </span><br><span class="line">  2   1  97   0   0   0|   0     0 | 460B  500B|   0     0 |1955  3532 </span><br><span class="line">  1   1  99   0   0   0|   0     0 | 120B  122B|   0     0 |1798  3296 </span><br><span class="line"> </span><br><span class="line"># 监控swap，process，sockets，filesystem并显示监控的时间</span><br><span class="line">[hz@aliyun erlang-project]$ dstat -tsp --socket --fs</span><br><span class="line">----system---- ----swap--- ---procs--- ------sockets------ --filesystem-</span><br><span class="line">     time     | used  free|run blk new|tot tcp udp raw frg|files  inodes</span><br><span class="line">24-06 23:39:21|   0     0 |0.0   0 5.5|223  11   4   0   0| 1280  49802 </span><br><span class="line">24-06 23:39:22|   0     0 |  0   0 8.0|229  11   4   0   0| 1344  49823 </span><br><span class="line">24-06 23:39:23|   0     0 |  0   0 7.0|223  11   4   0   0| 1344  49804 </span><br><span class="line">24-06 23:39:24|   0     0 |  0   0   0|223  11   4   0   0| 1344  49804 ^C</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 Hexo 和 Github Pages 搭建博客</title>
      <link href="/2021/07/22/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/07/22/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>首先需要安装 node.js 和 git，网上有安装教程</p><p><strong>使用Hexo的常用命令先放在开头</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s <span class="comment"># 调试</span></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">hexo clean &amp;&amp; hexo deploy <span class="comment"># 发布</span></span><br><span class="line"> <span class="comment"># 新建一博客</span></span><br></pre></td></tr></table></figure><hr><p>正式开始开始搭建博客 <span id="more"></span></p><h2 id="Hexo本地设置"><a href="#Hexo本地设置" class="headerlink" title="Hexo本地设置"></a>Hexo本地设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo clean   <span class="comment">#清除缓存文件 db.json 和已生成的静态文件 public</span></span><br><span class="line">hexo g       <span class="comment">#生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span></span><br><span class="line">hexo s <span class="comment"># 启动服务器查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hexo d # 自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span></span><br></pre></td></tr></table></figure><h3 id="一键部署到GitHub"><a href="#一键部署到GitHub" class="headerlink" title="一键部署到GitHub"></a>一键部署到GitHub</h3><p>安装 <strong>deployer</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>打开 <strong>_config.yml</strong> 文件，加上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/honghangzhi/honghangzhi.github.io  #你的仓库网址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>在命令行执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:honghangzhi/honghangzhi.github.io.git</span><br><span class="line">hexo clean &amp;&amp; hexo deploy</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>在 <a href="https://xxx.github.io/">https://xxx.github.io</a> 打开</p><h3 id="更新博客"><a href="#更新博客" class="headerlink" title="更新博客"></a>更新博客</h3><p>更新博客每次都重新<strong>部署</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>修改 <strong>_config.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><p>选择主题 - /themes/next/_config.yml - chemes</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scheme:</span> <span class="string">Muse</span></span><br></pre></td></tr></table></figure><h3 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/next</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="友情链接：几个热门的主题"><a href="#友情链接：几个热门的主题" class="headerlink" title="友情链接：几个热门的主题"></a>友情链接：几个热门的主题</h3><ul><li><a href="https://github.com/theme-next/hexo-theme-next">next</a></li><li><a href="http://theme-next.iissnan.com/">老版next文档</a></li><li><a href="https://github.com/litten/hexo-theme-yilia">yilia</a></li></ul><h2 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h2><p>两个配置文件：</p><ul><li>站点配置文件，根目录下的 <strong>_config.yml</strong> 文件</li><li>主题配置文件，\root\themes\next 下的 <strong>_config.yml</strong>  文件</li></ul><h3 id="显示文章字数和阅读时长"><a href="#显示文章字数和阅读时长" class="headerlink" title="显示文章字数和阅读时长"></a>显示文章字数和阅读时长</h3><p>在站点配置文件，根目录下的 <strong>_config.yml</strong> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: <span class="literal">true</span> <span class="comment"># 文章字数</span></span><br><span class="line">  time: <span class="literal">true</span> <span class="comment"># 阅读时长</span></span><br><span class="line">  total_symbols: <span class="literal">false</span> <span class="comment"># 所有文章总字数</span></span><br><span class="line">  total_time: <span class="literal">false</span> <span class="comment"># 所有文章阅读中时长</span></span><br></pre></td></tr></table></figure><p><strong>以下的设置均在主题配置文件中设置</strong></p><h3 id="设置菜单栏"><a href="#设置菜单栏" class="headerlink" title="设置菜单栏"></a>设置菜单栏</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span>                      <span class="comment">#首页</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span>       <span class="comment">#分类</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span>                 <span class="comment">#标签</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span>      <span class="comment">#归档</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span>               <span class="comment">#关于</span></span><br><span class="line">  <span class="comment"># resources: /resources/ || download   #资源</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar    #日历</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap    #站点地图，供搜索引擎爬取</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat      #腾讯公益404</span></span><br></pre></td></tr></table></figure><p>此时菜单栏并没有页面，在根目录执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;about&quot;</span><br><span class="line">hexo new page &quot;resources&quot;</span><br></pre></td></tr></table></figure><p>来生成页面，sources文件夹下会生成categories、tags、about、resources四个文件，每个文件中有一个<code>index.md</code>文件，修改内容分别如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2020-02-10 22:07:08</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2020-02-10 22:07:08</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 关于</span><br><span class="line">date: 2020-02-10 22:07:08</span><br><span class="line">type: &quot;about&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 资源</span><br><span class="line">date: 2020-02-10 22:07:08</span><br><span class="line">type: &quot;resources&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="菜单栏添加搜索框（Local-Search）"><a href="#菜单栏添加搜索框（Local-Search）" class="headerlink" title="菜单栏添加搜索框（Local Search）"></a>菜单栏添加搜索框（Local Search）</h3><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search</span><br></pre></td></tr></table></figure><p>主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><p>将图片 avatar.gif 移动到 \root\themes\next\source\images 目录下，在主题配置文件配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: /images/avatar.gif   #图片的位置，也可以是http://xxx.com/avatar.png</span><br><span class="line">  # If true, the avatar will be dispalyed in circle.</span><br><span class="line">  rounded: true   #头像展示在圈里</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: false  #头像随光标旋转</span><br></pre></td></tr></table></figure><h3 id="社交网站链接"><a href="#社交网站链接" class="headerlink" title="社交网站链接"></a>社交网站链接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/honghangzhi || fab fa-github</span><br></pre></td></tr></table></figure><h3 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16.png</span><br><span class="line">  medium: /images/favicon-32x32.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  #android_manifest: /images/manifest.json</span><br><span class="line">  #ms_browserconfig: /images/browserconfig.xml</span><br></pre></td></tr></table></figure><h3 id="暗夜模式-新版next主题内置"><a href="#暗夜模式-新版next主题内置" class="headerlink" title="暗夜模式 - 新版next主题内置"></a>暗夜模式 - 新版next主题内置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dark Mode</span></span><br><span class="line"><span class="attr">darkmode:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="设置博文内链接为蓝色"><a href="#设置博文内链接为蓝色" class="headerlink" title="设置博文内链接为蓝色"></a>设置博文内链接为蓝色</h3><p>在 themes/next/source/css/_common/components/post/post.styl文件中末尾加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line">     color: #0593d3;</span><br><span class="line">     border-bottom: none;</span><br><span class="line">     &amp;:hover &#123;</span><br><span class="line">       color: #0477ab;</span><br><span class="line">       text-decoration: underline;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="设置文章末尾”本文结束”标记"><a href="#设置文章末尾”本文结束”标记" class="headerlink" title="设置文章末尾”本文结束”标记"></a>设置文章末尾”本文结束”标记</h3><p>在路径 /themes/next/layout/_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:24px;&quot;&gt;（完）&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>接着打开/themes/next/layout/_macro/post.swig文件，在post-footer前添加代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if not is_index and theme.passage_end_tag.enabled %&#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;% include &#x27;passage-end-tag.swig&#x27; %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>在主题配置文件中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure><h3 id="设置建站时间"><a href="#设置建站时间" class="headerlink" title="设置建站时间"></a>设置建站时间</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup. If not defined, current year will be used.</span><br><span class="line">  since: 2020-02   #建站时间</span><br></pre></td></tr></table></figure><h3 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h3><h4 id="（1）安装插件"><a href="#（1）安装插件" class="headerlink" title="（1）安装插件"></a>（1）安装插件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure><h4 id="（2）设置置顶标志"><a href="#（2）设置置顶标志" class="headerlink" title="（2）设置置顶标志"></a>（2）设置置顶标志</h4><p>打开blog/themes/next/layout/_macro目录下的post.swig文件，定位到 <code>&lt;div class=&quot;post-meta&quot;&gt;</code> 标签下，插入如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;font color=7D26CD&gt;置顶&lt;/font&gt;</span><br><span class="line">  &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h4 id="（3）在文章中添加top"><a href="#（3）在文章中添加top" class="headerlink" title="（3）在文章中添加top"></a>（3）在文章中添加top</h4><p>然后在需要置顶的文章的Front-matter中加上top: true即可，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">top: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="添加评论（使用valine）"><a href="#添加评论（使用valine）" class="headerlink" title="添加评论（使用valine）"></a>添加评论（使用valine）</h3><p>可以参考这篇<a href="https://blog.csdn.net/blue_zy/article/details/79071414?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162688580716780265414057%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162688580716780265414057&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-79071414.first_rank_v2_pc_rank_v29&utm_term=hexo+%E8%AF%84%E8%AE%BA">文章</a>，步骤</p><h4 id="（1）注册Leancloud"><a href="#（1）注册Leancloud" class="headerlink" title="（1）注册Leancloud"></a>（1）注册Leancloud</h4><p>① <a href="https://console.leancloud.cn/apps">LeanCloud</a>注册<br>② 创建应用<br>③ 应用 - 设置 - 应用凭证，复制<strong>AppID</strong>和<strong>AppKey</strong></p><h4 id="（2）修改主题配置文件"><a href="#（2）修改主题配置文件" class="headerlink" title="（2）修改主题配置文件"></a>（2）修改主题配置文件</h4><p>将复制的<strong>AppID</strong>和<strong>AppKey</strong>添加到配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">comments:</span><br><span class="line">  # Available values: tabs | buttons</span><br><span class="line">  style: tabs</span><br><span class="line">  # Choose a comment system to be displayed by default.</span><br><span class="line">  # Available values: changyan | disqus | disqusjs | gitalk | livere | valine</span><br><span class="line">  active: valine</span><br><span class="line">  </span><br><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid: # Your leancloud application appid</span><br><span class="line">  appkey # Your leancloud application appkey</span><br></pre></td></tr></table></figure><h3 id="添加多级分类"><a href="#添加多级分类" class="headerlink" title="添加多级分类"></a>添加多级分类</h3><p>next 内置多级分类，在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories: </span><br><span class="line">- 父目录</span><br><span class="line">- 子目录</span><br></pre></td></tr></table></figure><p>此时查看博文将显示 <code>父目录，子目录</code></p><h4 id="设置多级分类只显示子类别"><a href="#设置多级分类只显示子类别" class="headerlink" title="设置多级分类只显示子类别"></a>设置多级分类只显示子类别</h4><p>搜索 <code>post.in</code> 将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;%- if post.categories and post.categories.length and theme.post_meta.categories %&#125;</span><br><span class="line">  &lt;span class=&quot;post-meta-item&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;far fa-folder&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&#x27;post.in&#x27;) &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &#123;%- for cat in post.categories.toArray() %&#125;</span><br><span class="line">      &lt;span itemprop=&quot;about&quot; itemscope itemtype=&quot;http://schema.org/Thing&quot;&gt;</span><br><span class="line">        &lt;a href=&quot;&#123;&#123; url_for(cat.path) &#125;&#125;&quot; itemprop=&quot;url&quot; rel=&quot;index&quot;&gt;&lt;span itemprop=&quot;name&quot;&gt;&#123;&#123; cat.name &#125;&#125;&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line"></span><br><span class="line">      &#123;%- set cat_length = post.categories.length %&#125;</span><br><span class="line">      &#123;%- if cat_length &gt; 1 and loop.index !== cat_length %&#125;</span><br><span class="line">        &#123;&#123; __(&#x27;symbol.comma&#x27;) &#125;&#125;</span><br><span class="line">      &#123;%- endif %&#125;</span><br><span class="line">    &#123;%- endfor %&#125;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure><p>替换如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;%- if post.categories and post.categories.length and theme.post_meta.categories %&#125;</span><br><span class="line">  &lt;span class=&quot;post-meta-item&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;far fa-folder&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&#x27;post.in&#x27;) &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &#123;%- for cat in post.categories.toArray() %&#125;</span><br><span class="line"></span><br><span class="line">      &#123;%- if loop.last %&#125;</span><br><span class="line">        &lt;span itemprop=&quot;about&quot; itemscope itemtype=&quot;http://schema.org/Thing&quot;&gt;</span><br><span class="line">          &lt;a href=&quot;&#123;&#123; url_for(cat.path) &#125;&#125;&quot; itemprop=&quot;url&quot; rel=&quot;index&quot;&gt;&lt;span itemprop=&quot;name&quot;&gt;&#123;&#123; cat.name &#125;&#125;&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">      &#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    &#123;%- endfor %&#125;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure><h4 id="启用fancybox：点击查看图片大图"><a href="#启用fancybox：点击查看图片大图" class="headerlink" title="启用fancybox：点击查看图片大图"></a>启用fancybox：点击查看图片大图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fancybox: true</span><br></pre></td></tr></table></figure><h2 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h2><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><ul><li><p>免费域名：<a href="https://www.freenom.com/zh/index.html?lang=zh">https://www.freenom.com/zh/index.html?lang=zh</a></p></li><li><p>付费域名</p><ul><li><p>阿里云：<a href="https://wanwang.aliyun.com/">https://wanwang.aliyun.com/</a></p></li><li><p>腾讯云：<a href="https://dnspod.cloud.tencent.com/">https://dnspod.cloud.tencent.com/</a></p></li></ul></li></ul><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>TODO</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Context-Dump-Ends"><a href="#Context-Dump-Ends" class="headerlink" title="Context Dump Ends"></a>Context Dump Ends</h3><p><a href="https://blog.csdn.net/liuarmyliu/article/details/107737361">https://blog.csdn.net/liuarmyliu/article/details/107737361</a></p><p>在<code>hexo g</code>的时候报错，因为我在文章里写了<code>&#123;&#123;&#125;&#125;</code>。</p><p><a href="https://so.csdn.net/so/search?q=hexo&spm=1001.2101.3001.7020">hexo</a> 的文章渲染使用的是 <code>Nunjucks</code> ，因为在使用<code>mathjax</code>公式，造成了<code>&#123; &#123;</code>重叠，而它会在生成文章时将那几个大括号识别成自己的语法，这样就会报错。</p><p><strong>用空格隔开就好</strong>；</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://hexo.io/docs/one-command-deployment">Hexo</a></li><li><a href="https://hexo.io/zh-cn/">Hexo中文</a></li><li><a href="https://docs.github.com/cn/pages">Github Pages</a></li></ul><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><ul><li><p><a href="https://blog.csdn.net/wapchief/article/details/54602515?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162677118916780262589207%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162677118916780262589207&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-1-54602515.pc_v2_rank_blog_default&utm_term=hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2">搭建教程</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/106060640">主题美化参考</a></p></li><li><p><a href="https://hexo.io/zh-cn/docs/configuration.html">关于写作</a></p></li><li><p><a href="https://juejin.cn/post/6844903720296120328">https://juejin.cn/post/6844903720296120328</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
