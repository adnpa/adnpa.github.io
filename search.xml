<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>垃圾回收基础</title>
      <link href="/2024/05/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2024/05/25/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<p>垃圾回收的基本概念和算法</p><span id="more"></span><h1 id="垃圾回收基本概念"><a href="#垃圾回收基本概念" class="headerlink" title="垃圾回收基本概念"></a>垃圾回收基本概念</h1><ul><li>对象，分为头和域<ul><li>头，保存对象本身信息，对象大小、种类等</li><li>域，对象中可访问的部分：分为指针和非指针，指针是指向内存空间中某块区域的值，非指针是值本身。</li></ul></li><li>指针，是GC销毁或保留对象的关键</li><li>mutator（赋值器）<br>In computer science, a mutator method is a method used to control changes to a variable. They are also widely known as setter methods.<ul><li>生成对象</li><li>更新指针</li></ul></li><li>堆，动态存放对象的内存空间<br>GC 是管理堆中已分配对象的机制，需要时从堆里分配内存空间给mutator</li><li>活动对象/ 非活动对象<br>分配到内存空间，能通过mutator 引用的对象称为“活动对象”<br>非活动对象=垃圾</li><li>chunk，为利用对象而事先准备出来的空间<br>分块→活动对象→垃圾（非活动对象）→ 分块→ ……</li><li>赋值器根，指针集合，直接由赋值器根引用的对象称为根对象。</li></ul><p>GC算法评价</p><ul><li>吞吐量</li><li>最大暂停时间，因执行GC 而暂停执行mutator 的最长时间</li><li>堆使用效率<br>GC 复制算法中将堆二等分，每次只使用一半，交替进行，因此总是只能利用堆的一半</li><li>访问的局部性</li></ul><h1 id="标记-清除法"><a href="#标记-清除法" class="headerlink" title="标记-清除法"></a>标记-清除法</h1><p>标记-清除算法是一种用于垃圾回收（Garbage Collection）的算法。它的主要思想是通过<strong>标记对象是否可达</strong>来判断哪些对象是垃圾，然后将这些垃圾对象进行清除。</p><p>具体来说，标记-清除算法将堆内存中的所有对象分为两类，即可达对象和不可达对象。首先，从根节点开始，遍历整个对象图，将所有可达的对象打上标记。随后，遍历整个堆内存，将未标记的对象视为不可达对象，即垃圾对象，将它们进行清除。清除后，将剩余可达对象进行整理，将它们压缩到堆内存的一端。</p><p>标记-清除算法的主要优点是可以有效地回收不连续的内存，因为它不需要进行内存的移动。但是，它也有一些缺点。首先，它会产生内存碎片，因为被清除的对象留下了空洞。这会导致内存分配时需要进行更多的内存搜索和分配，从而影响性能。此外，标记-清除算法在执行垃圾回收时会暂停程序运行，这可能会影响实时性应用程序的性能。</p><p>因此，在实际应用中，标记-清除算法通常需要与其他垃圾回收算法结合使用，以达到更好的效果。</p><h2 id="标记阶段"><a href="#标记阶段" class="headerlink" title="标记阶段"></a>标记阶段</h2><p>标记所有可达对象。具体来说，标记阶段从一组根对象开始，通过遍历对象图来<strong>标记所有可达对象</strong>。通常使用深度优先搜索或广度优先搜索算法来遍历对象图，一般来说，深度优先搜索更节约内存。</p><p>概念</p><ul><li>根对象通常是程序中的全局变量、活动线程的栈和寄存器等，它们是已知的、永远不会被回收的对象。</li><li>能够从程序的根对象到达的对象，并且仍然可以被程序访问到的对象</li></ul><p>步骤</p><ol><li>标记通过根直接引用的对象</li><li>递归地标记通过指针数组能访问到的对象</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mark_phase()&#123;</span><br><span class="line">    for(r : $roots)</span><br><span class="line">        mark(*r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mark(obj)&#123;</span><br><span class="line">    if(obj.mark == FALSE)</span><br><span class="line">    obj.mark = TRUE</span><br><span class="line">    for(child : children(obj))</span><br><span class="line">    mark(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="清除阶段"><a href="#清除阶段" class="headerlink" title="清除阶段"></a>清除阶段</h2><p><strong>清除所有未被标记的对象</strong>。具体来说，在标记阶段中未被标记的对象都被认为是垃圾对象，需要在清除阶段进行清除。</p><p>从堆首地址$heap_start开始遍历堆</p><ul><li>活动对象，将标记取消</li><li>非活动对象，将分块加入空闲链表</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sweep_phase()&#123;</span><br><span class="line">    sweeping = $heap_start</span><br><span class="line">    while(sweeping &lt; $heap_end)</span><br><span class="line">    if(sweeping.mark == TRUE)</span><br><span class="line">    sweeping.mark = FALSE</span><br><span class="line">    else</span><br><span class="line">    sweeping.next = $free_list</span><br><span class="line">    $free_list = sweeping</span><br><span class="line">    sweeping += sweeping.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的清除，会产生碎片化现象，优化需要用后面的压缩法或BiBOP法</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>实现简单，可以和其他算法结合</li><li>和保守式GC 算法兼容</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>碎片化<br>改进：压缩存活对象，BiBOP 法</li><li>分配速度，每次分配都要遍历空闲链表<br>改进：多个空闲链表，BiBOP 法</li><li>与写时复制技术不兼容<br>UNIX 操作系统中复制进程，也就是使用fork() 函数时，大部分内存空间都不会被复制，而是共享内存，在对共享内存空间进行写入时，复制自己私有空间的数据。<br>改进：位图标记法</li></ul><h2 id="多个空闲链表"><a href="#多个空闲链表" class="headerlink" title="多个空闲链表"></a>多个空闲链表</h2><p>创建只连接大分块的空闲链表和只连接小分块的空闲链表，按照mutator 所申请的分块大小选择空闲链表，就能在短时间内找到符合条件的分块了。</p><p>分配算法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)&#123;</span><br><span class="line">    index = size / (WORD_LENGTH / BYTE_LENGTH)</span><br><span class="line">    if(index &lt;= 100)</span><br><span class="line">        if($free_list[index] != NULL)</span><br><span class="line">            chunk = $free_list[index]</span><br><span class="line">            $free_list[index] = $free_list[index].next</span><br><span class="line">            return chunk</span><br><span class="line">    else</span><br><span class="line">        chunk = pickup_chunk(size, $free_list[101])</span><br><span class="line">        if(chunk != NULL)</span><br><span class="line">        return chunk</span><br><span class="line">    allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BiBOP法"><a href="#BiBOP法" class="headerlink" title="BiBOP法"></a>BiBOP法</h2><p>Big Bag Of Pages，将大小相近的对象整理成固定大小的块进行管理。</p><p>碎片化的原因之一就是堆上杂乱散布着大小各异的对象，类似分段的缺点。BiBOP 类似于分页，组织成大小相同的块。</p><h2 id="位图标记"><a href="#位图标记" class="headerlink" title="位图标记"></a>位图标记</h2><p>位图标记法即只收集各个对象的标志位并表格化，不跟对象一起管理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mark(obj)&#123;</span><br><span class="line">    obj_num = (obj - $heap_start) / WORD_LENGTH</span><br><span class="line">    index = obj_num / WORD_LENGTH</span><br><span class="line">    offset = obj_num % WORD_LENGTH</span><br><span class="line">    if(($bitmap_tbl[index] &amp; (1 &lt;&lt; offset)) == 0)</span><br><span class="line">        $bitmap_tbl[index] |= (1 &lt;&lt; offset)</span><br><span class="line">        for(child : children(obj))</span><br><span class="line">        mark(*child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延迟清除法（懒惰清扫）"><a href="#延迟清除法（懒惰清扫）" class="headerlink" title="延迟清除法（懒惰清扫）"></a>延迟清除法（懒惰清扫）</h2><p>不统一清除非活动对象，而是分配时清除</p><p>分配，调用清除函数获取分块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)&#123;</span><br><span class="line">chunk = lazy_sweep(size)</span><br><span class="line">if(chunk != NULL)</span><br><span class="line">return chunk</span><br><span class="line">mark_phase()</span><br><span class="line">chunk = lazy_sweep(size)</span><br><span class="line">if(chunk != NULL)</span><br><span class="line">return chunk</span><br><span class="line">allocation_fail()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>清除函数，返回需要的分块</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">lazy_sweep(size)&#123;</span><br><span class="line">    while($sweeping &lt; $heap_end)</span><br><span class="line">    if($sweeping.mark == TRUE)</span><br><span class="line">    $sweeping.mark = FALSE</span><br><span class="line">    else if($sweeping.size &gt;= size)</span><br><span class="line">        chunk = $sweeping</span><br><span class="line">        $sweeping += $sweeping.size</span><br><span class="line">        return chunk</span><br><span class="line">    $sweeping += $sweeping.size</span><br><span class="line">    $sweeping = $heap_start</span><br><span class="line">    return NULL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h1><p>引用计数法是一种垃圾回收算法,它是通过跟踪每个对象被引用的次数来确定哪些对象可以被安全地回收。具体工作原理如下:</p><ol><li><p>每个对象都有一个引用计数器,记录着有多少个引用指向该对象。</p></li><li><p>当一个新对象被创建时,它的引用计数被初始化为1。</p></li><li><p>每次有一个新的引用指向该对象,它的引用计数就会加1。</p></li><li><p>每当一个引用失效(例如变量被赋值为新的对象),它的引用计数就会减1。</p></li><li><p>当一个对象的引用计数变为0时,说明没有任何引用指向它了,这个对象就可以被安全地回收了。</p></li></ol><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>从空闲链表分配数据库，若没有合适的内存块则失败</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new_obj(size)&#123;</span><br><span class="line">    obj = pickup_chunk(size, $free_list)</span><br><span class="line">    if(obj == NULL)</span><br><span class="line">    allocation_fail()</span><br><span class="line">    else</span><br><span class="line">    obj.ref_cnt = 1</span><br><span class="line">    return obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新指针"><a href="#更新指针" class="headerlink" title="更新指针"></a>更新指针</h2><p>先对指针新引用的对象计数器++，再对之前指向的老对象–，并判断是否失效等操作，最后改变指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">update_ptr(ptr, obj)&#123;</span><br><span class="line">    inc_ref_cnt(obj)</span><br><span class="line">    dec_ref_cnt(*ptr)</span><br><span class="line">    *ptr = obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>基本思想</strong>:<ul><li>每个对象都维护一个引用计数器,记录当前有多少个引用指向该对象。</li><li>当创建一个新对象时,它的引用计数初始化为 1。</li><li>每当有新的引用指向该对象时,引用计数加 1。</li><li>每当一个引用失效时,引用计数减 1。</li><li>当一个对象的引用计数降到 0 时,说明没有任何引用指向它,该对象就可以被回收了。</li></ul></li></ol><h2 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h2><ul><li>可以及时回收无用对象，计数成为0时马上就回收，减少内存占用。</li><li>最大暂停时间短，只有当通过mutator 更新指针时程序才会执行垃圾回收</li><li>不需要沿指针查找，如在分布式环境下，沿各个计算节点间指针查找，成本会增大，这种情况可以减少沿指针查找次数。</li></ul><h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><ul><li>计数器值的增减处理繁重，因为指针的更新往往比较频繁。<br>解决方法：延迟引用计数法</li><li>计数器需要占用很多位，因为要数完所有的对象，使内存空间使用效率大大降低<br>解决方法：Sticky 引用计数法</li><li>实现繁琐</li><li>循环引用问题，当A引用了B，B也引用了A，就形成了循环引用。因为双方的计数器都是1，因此永远无法回收。<br>解决方法：部分标记- 清除算法</li></ul><h2 id="延迟引用计数法"><a href="#延迟引用计数法" class="headerlink" title="延迟引用计数法"></a>延迟引用计数法</h2><p>延迟引用计数法是对传统引用计数法的一种改进。它的主要思想是尽量推迟对引用计数的更新,从而降低更新引用计数的开销。这种方法具体包括以下几个方面:</p><ol><li>延迟引用计数的更新:当一个对象的引用计数减少时,并不立即更新计数,而是将其记录在一个延迟更新列表中。</li><li>批量更新引用计数:定期对延迟更新列表中的对象进行批量处理,一次性更新它们的引用计数。这样可以大幅降低更新引用计数的频率。</li><li>优化引用计数的检查:在进行垃圾回收时,只需检查延迟更新列表中的对象,而不需要扫描所有对象。</li></ol><p>这种延迟的方式可以大大降低引用计数更新的开销,从而提高整体的垃圾回收效率。但同时也引入了一些新的问题,比如需要处理延迟更新列表,以及如何确保正确性等。</p><p>因此,延迟引用计数法是对基本引用计数法的一种改进,在一些需要高性能的应用中会被使用。它通过推迟引用计数的更新来减少开销,并可以与其他算法结合使用。</p><h2 id="Sticky-引用计数法"><a href="#Sticky-引用计数法" class="headerlink" title="Sticky 引用计数法"></a>Sticky 引用计数法</h2><p>Sticky 引用计数法是一种引用计数垃圾回收算法的变体，它结合了标记-清楚法，解决了计数器溢出的问题。</p><p>Sticky 引用计数法的主要思想是:</p><ol><li>计数器溢出时，将所有对象的计数器都设为0，进入标记-清除阶段</li><li>标记阶段：首先把由根直接引用的对象堆到标记栈里，然后按顺序从标记栈取出对象，对计数器进行增量操作</li><li>清除阶段：搜索整个堆，清除计数器仍为0的对象</li></ol><p>这样，即使计数器溢出了，也会在适当的时候，执行标记-清除算法来安全地回收。</p><p>不过,Sticky 引用计数法也有一些缺点:</p><ol><li>需要维护额外的 Sticky 标记表,增加了实现的复杂度。</li><li>可能会导致一些对象长时间无法被回收,因为它们的 Sticky 标记无法降为 0。</li></ol><h2 id="部分标记-清除法（四色标记法）"><a href="#部分标记-清除法（四色标记法）" class="headerlink" title="部分标记- 清除法（四色标记法）"></a>部分标记- 清除法（四色标记法）</h2><p>为了解决循环引用无法回收的问题，可以考虑结合使用标记-清除法。可以只对“可能有循环引用的对象群”使用GC 标记- 清除算法，对其他对象进行内存管理时使用引用计数法。像这样只对一部分对象群使用GC 标记-清除算法的方法，叫作“部分标记- 清除算法”（Partial Mark &amp; Sweep）</p><p>部分标记- 清除法中，对象被分为四种颜色来管理</p><ol><li>黑（BLACK）：绝对不是垃圾的对象（对象产生时的初始颜色）</li><li>白（WHITE）：绝对是垃圾的对象</li><li>灰（GRAY）：搜索完毕的对象</li><li>阴影（HATCH）：可能是循环垃圾的对象</li></ol><h1 id="GC复制算法"><a href="#GC复制算法" class="headerlink" title="GC复制算法"></a>GC复制算法</h1><p>复制算法是一种常见的垃圾回收方法,它的工作原理如下:</p><ol><li><p><strong>基本思想</strong>:</p><ul><li>将堆内存划分为两个等大的区域,称为”From”空间和”To”空间。</li><li>垃圾回收器会将”From”空间中的存活对象复制到”To”空间中,同时释放”From”空间的内存。</li><li>在下一次回收时,”To”空间和”From”空间会交换角色。</li></ul></li><li><p><strong>工作过程</strong>:</p><ul><li>首先,垃圾回收器从根对象开始,递归地扫描并复制存活对象到”To”空间。</li><li>在复制过程中,如果发现某个对象的引用指向”From”空间的对象,则更新引用指向复制后的新对象。</li><li>当”From”空间中所有存活对象都被复制完成后,剩余的内存空间就可以被回收。</li></ul></li><li><p><strong>优点</strong></p><ul><li><p>不需要标记和清除的过程,简化了垃圾回收的实现。</p></li><li><p>通过复制,可以有效地解决内存碎片的问题。</p></li><li><p>复制过程中,对象的布局会被重新组织,有利于提高内存访问的局部性。</p></li></ul></li><li><p><strong>缺点</strong></p><ul><li><p>需要两倍的内存空间,因为需要同时保留”From”空间和”To”空间。</p></li><li><p>复制对象的过程会带来一定的性能开销。</p></li></ul></li></ol><h1 id="标记-压缩法"><a href="#标记-压缩法" class="headerlink" title="标记-压缩法"></a>标记-压缩法</h1><p>标记-压缩法是一种改进的垃圾回收算法,它结合了标记-清除法和复制法的优点,主要步骤如下:</p><ol><li><strong>标记阶段</strong>:<ul><li>垃圾回收器从根对象开始,递归地标记所有存活对象。</li><li>与标记-清除法类似,未被标记的对象被视为垃圾。</li></ul></li><li><strong>压缩阶段</strong>:<ul><li>在标记阶段完成后,垃圾回收器会将存活对象压缩到连续的内存区域。</li><li>具体做法是:遍历堆内存,将存活对象往一端移动,最终形成一个连续的内存块。</li><li>这样可以有效地解决内存碎片的问题。</li></ul></li><li><strong>优点</strong>:<ul><li>不需要额外的内存空间,避免了复制算法的内存开销。</li><li>通过压缩,可以有效地解决内存碎片的问题。</li><li>可以保留标记-清除法的简单性和高效性。</li></ul></li><li><strong>缺点</strong>:<ul><li>在压缩阶段,需要<strong>移动大量的存活对象</strong>,会带来一定的性能开销。</li><li>如果存活对象过多,压缩的过程可能会耗时较长。</li></ul></li></ol><h1 id="分代垃圾回收"><a href="#分代垃圾回收" class="headerlink" title="分代垃圾回收"></a>分代垃圾回收</h1><blockquote><p>大部分的对象在生成后马上就变成了垃圾，很少有对象能活得很久</p></blockquote><p>分代垃圾回收是一种基于对象生命周期的垃圾回收策略,它的核心思想是:</p><ol><li><strong>基本思想</strong>:<ul><li>将堆内存划分为几个代(Generation),通常包括年轻代(Young Generation)和老年代(Old Generation)。</li><li>新创建的对象都会被放在年轻代,经过一定的存活时间后,会被晋升到老年代。</li><li>对不同代使用不同的垃圾回收算法和频率,以优化垃圾回收的效率。</li></ul></li><li><strong>工作过程</strong>:<ul><li>年轻代中的对象比较容易成为垃圾,因此采用复制算法进行快速回收。</li><li>老年代中的对象存活时间较长,采用标记-清除或标记-压缩算法进行回收。</li><li>当对象从年轻代晋升到老年代时,称为”晋升”(Promotion)。</li></ul></li><li><strong>优点</strong>:<ul><li>利用了对象生命周期的特点,可以更有针对性地进行垃圾回收。</li><li>年轻代使用复制算法可以快速回收大量临时对象。</li><li>老年代使用标记-清除或标记-压缩算法可以高效地回收长期存活的对象。</li><li>可以降低整体的垃圾回收开销。</li></ul></li><li><strong>缺点</strong>:<ul><li>需要额外的内存空间来维护不同代之间的数据结构。</li><li>对象在不同代之间的晋升也会带来一定的开销。</li></ul></li></ol><p>以Ungar算法为例</p><h2 id="堆结构划分"><a href="#堆结构划分" class="headerlink" title="堆结构划分"></a>堆结构划分</h2><p><img src="./../../img/image-20240524102004854.png" alt="image-20240524102004854"></p><ul><li>生成空间，分配新对象的空间</li><li>2 个大小相等的幸存空间，和复制算法中的From和To类似，执行新生代GC时会使用。</li><li>老年代空间，一定次数在新生代幸存的对象会被<strong>复制</strong>到老年代空间</li><li>记录集，用来记录从老年代对象到新生代对象的引用</li></ul><h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><p>对于老年代引用新生代对象的情况，因为新生代GC只会扫描新生代空间和根持有的引用，是无法处理的，如果再把老年代的对象也全部扫描的话，就会相当于扫描了整个堆空间，丧失分代的优势。于是考虑增加了记录集，专门记录从老年代对象到新生代对象的引用。新生代GC只扫描老年代中，记录集有记录的部分。</p><p>写屏障就是将老年代对象记录到记录集的过程，这个函数会在update_ptr时执行，对满足以下三点的对象记录到记录集。</p><ul><li>发出引用的对象是老年代对象</li><li>指针更新后的引用的目标对象是新生代对象</li><li>发出引用的对象还没有被记录到记录集中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">write_barrier(obj, field, new_obj)&#123;</span><br><span class="line">    if(obj &gt;= $old_start &amp;&amp; new_obj &lt; $old_start &amp;&amp; obj.remembered == FALSE)</span><br><span class="line">        $rs[$rs_index] = obj</span><br><span class="line">        $rs_index++</span><br><span class="line">        obj.remembered = TRUE</span><br><span class="line">    *field = new_obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="新生代GC"><a href="#新生代GC" class="headerlink" title="新生代GC"></a>新生代GC</h2><ol><li>生成空间满了以后，开始执行GC</li><li>检查生成空间和From空间的活动对象，如果小于AGE_MAX，复制到To空间，否则晋升到老年代空间</li><li>交换From和To空间</li></ol><h2 id="老年代GC"><a href="#老年代GC" class="headerlink" title="老年代GC"></a>老年代GC</h2><p>使用四种基本算法之一即可，一般是标记-清除法</p><h1 id="增量式垃圾回收"><a href="#增量式垃圾回收" class="headerlink" title="增量式垃圾回收"></a>增量式垃圾回收</h1><p>停止型GC（stop-the-world-GC）缺点，GC一开始，mutator就无法执行，这在某些应用里是致命的。因此人们发明了增量式GC，让GC和mutator交替执行。</p><h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><ul><li>白色：还未搜索过的对象</li><li>灰色：正在搜索的对象</li><li>黑色：搜索完成的对象</li></ul><p>算法中三种颜色的区分</p><ul><li>白色：mark=false并且不在标记栈中</li><li>灰色：mark=true并且在标记栈中</li><li>黑色：mark=true并且不在标记栈中</li></ul><h2 id="增量式标记-清除算法"><a href="#增量式标记-清除算法" class="headerlink" title="增量式标记-清除算法"></a>增量式标记-清除算法</h2><h3 id="根查找阶段"><a href="#根查找阶段" class="headerlink" title="根查找阶段"></a>根查找阶段</h3><p>将根直接指向的对象标记为灰色，完成后将gc_phase改为GC_MARK，即标记阶段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root_scan_phase()&#123;</span><br><span class="line">    for(r : $roots)</span><br><span class="line">    mark(*r)</span><br><span class="line">    $gc_phase = GC_MARK</span><br><span class="line">&#125;</span><br><span class="line">mark(obj)&#123;</span><br><span class="line">    if(obj.mark == FALSE)</span><br><span class="line">        obj.mark = TRUE</span><br><span class="line">        push(obj, $mark_stack)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标记阶段-1"><a href="#标记阶段-1" class="headerlink" title="标记阶段"></a>标记阶段</h3><p>从标记栈取对象，将其子对象涂成灰色，这一系列操作会<strong>执行MARK_MAX次</strong>，即不是一次处理掉所有灰色对象，而是和mutator交替执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">incremental_mark_phase()&#123;</span><br><span class="line">    for(i : 1..MARK_MAX)</span><br><span class="line">        if(is_empty($mark_stack) == FALSE)</span><br><span class="line">            obj = pop($mark_stack)</span><br><span class="line">            for(child : children(obj))</span><br><span class="line">            mark(*child)</span><br><span class="line">        else</span><br><span class="line">            for(r : $roots)</span><br><span class="line">                mark(*r)</span><br><span class="line">            while(is_empty($mark_stack) == FALSE)</span><br><span class="line">                obj = pop($mark_stack)</span><br><span class="line">                for(child : children(obj))</span><br><span class="line">                    mark(*child)</span><br><span class="line">            $gc_phase = GC_SWEEP</span><br><span class="line">            $sweeping = $heap_start</span><br><span class="line">            return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个标记遗漏的问题，如下图，(a)中A已经把子对象都加入标记栈，但是当暂停GC，运行程序时，先让A引用C，再移除B的引用。出现了(c)这种情况，C即不是根指向的对象，又没有灰色对象引用，就会被遗漏，不会被搜索。</p><p><img src="./../../img/image-20240524221342877.png" alt="image-20240524221342877"></p><p>这个问题有两个办法解决：</p><ul><li>强三色不变式，强制性不允许黑色对象引用白色对象</li><li>弱三色不变式，黑色可以引用白色，但必须同时被灰色引用，或上游存在灰色对象</li></ul><p>这两种解决方法的实现也是通过写屏障，</p><p>Dijkstra的写屏障实现了强三色不变式，只要新引用的对象是白色，就将其标记（涂成灰色）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">write_barrier(obj, field, newobj)&#123;</span><br><span class="line">    if(newobj.mark == FALSE)</span><br><span class="line">        newobj.mark = TRUE</span><br><span class="line">        push(newobj, $mark_stack)</span><br><span class="line">    *field = newobj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="清除阶段-1"><a href="#清除阶段-1" class="headerlink" title="清除阶段"></a>清除阶段</h3><p>基本和普通的标记-清除法一样，将没标记的对象（不可达）加入空闲链表，将标记对象的标志位取消。同样是增量式的清除，每次只处理SWEEP_MAX数量，当把整个堆全部清除后就结束GC</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">incremental_sweep_phase()&#123;</span><br><span class="line">swept_count = 0</span><br><span class="line">    while(swept_count &lt; SWEEP_MAX)</span><br><span class="line">        if($sweeping &lt; $heap_end)</span><br><span class="line">            if($sweeping.mark == TRUE)</span><br><span class="line">            $sweeping.mark = FALSE</span><br><span class="line">            else</span><br><span class="line">                $sweeping.next = $free_list</span><br><span class="line">                $free_list = $sweeping</span><br><span class="line">                $free_size += $sweeping.size</span><br><span class="line">                $sweeping += $sweeping.size</span><br><span class="line">                swept_count++</span><br><span class="line">        else</span><br><span class="line">            $gc_phase = GC_ROOT_SCAN</span><br><span class="line">            return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点</p><ul><li>缩短最大暂停时间</li><li>降低吞吐量，因为写入屏障会增加额外负担</li></ul><h2 id="Steele-的算法"><a href="#Steele-的算法" class="headerlink" title="Steele 的算法"></a>Steele 的算法</h2><p>Steele 的算法提供了强三色不变式的实现，标记阶段若发起引用的对象是黑色的并且引用对象是白色或灰色的，就将发起对象涂成灰色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">write_barrier(obj, field, newobj)&#123;</span><br><span class="line">    if($gc_phase == GC_MARK &amp;&amp; obj.mark == TRUE &amp;&amp; newobj.mark == FALSE)</span><br><span class="line">        obj.mark = FALSE</span><br><span class="line">        push(obj, $mark_stack)</span><br><span class="line">    *field = newobj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="汤浅的算法"><a href="#汤浅的算法" class="headerlink" title="汤浅的算法"></a>汤浅的算法</h2><p>汤浅的算法也提供了强三色不变式的实现，标记阶段若发起引用的对象是白色的，就将其涂成灰色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">write_barrier(obj, field, newobj)&#123;</span><br><span class="line">    oldobj = *field</span><br><span class="line">    if(gc_phase == GC_MARK &amp;&amp; oldobj.mark == FALSE)</span><br><span class="line">    oldobj.mark = TRUE</span><br><span class="line">    push(oldobj, $mark_stack)</span><br><span class="line">    *field = newobj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><p><a href="https://github.com/ivmai/bdwgc">https://github.com/ivmai/bdwgc</a></p></li><li><p><a href="https://blog.codingnow.com/2010/02/cpp_gc.html">https://blog.codingnow.com/2010/02/cpp_gc.html</a></p></li><li><p><a href="https://segmentfault.com/a/1190000022062597">https://segmentfault.com/a/1190000022062597</a></p></li><li><p>《垃圾回收的算法与实现》</p></li><li><p>《垃圾回收算法手册》</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 垃圾回收 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GMP</title>
      <link href="/2024/05/20/go-gmp/"/>
      <url>/2024/05/20/go-gmp/</url>
      
        <content type="html"><![CDATA[<p>介绍golang的调度器</p><span id="more"></span><ul><li><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html">Scheduling In Go : Part I - OS Scheduler</a></li><li><a href="https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html">Scheduling In Go : Part II - Go Scheduler</a></li><li><a href="https://www.ardanlabs.com/blog/2018/12/scheduling-in-go-part3.html">Scheduling In Go : Part III - Concurrency</a></li><li><a href="https://go.dev/src/runtime/HACKING">https://go.dev/src/runtime/HACKING</a></li><li><a href="https://www.codingexplorations.com/blog/understanding-gos-goroutine-mutex-and-channel-gmp-model">https://www.codingexplorations.com/blog/understanding-gos-goroutine-mutex-and-channel-gmp-model</a></li><li><a href="https://www.kelche.co/blog/go/golang-scheduling/">https://www.kelche.co/blog/go/golang-scheduling/</a></li><li><a href="https://medium.com/@sanilkhurana7/understanding-the-go-scheduler-and-looking-at-how-it-works-e431a6daacf">https://medium.com/@sanilkhurana7/understanding-the-go-scheduler-and-looking-at-how-it-works-e431a6daacf</a></li></ul><h1 id="OS调度器及相关概念"><a href="#OS调度器及相关概念" class="headerlink" title="OS调度器及相关概念"></a>OS调度器及相关概念</h1><h3 id="什么是调度？"><a href="#什么是调度？" class="headerlink" title="什么是调度？"></a>什么是调度？</h3><p>调度是指操作系统或相关管理程序决定如何分配有限的计算机资源（如CPU时间、内存、磁盘等）给不同的任务或进程的过程。调度的目标是优化系统性能、提高资源利用率和满足任务的需求。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><a href="https://en.wikipedia.org/wiki/Thread_(computing)">https://en.wikipedia.org/wiki/Thread_(computing)</a></p><ul><li><p>进程，一个进程拥有一个或多个内核级线程，这些线程<strong>共享进程资源</strong>，如内存和文件句柄等。</p><p>在用户级别，一些高级语言可能具有自己的调度器，可能也会把调度单位称为进程，如erlang的轻量级进程。但如果这些调度单位是共享数据的（并通常是抢占式的），则一般称为用户级线程。协作式的则称为协程（fiber）。用户级线程可以被内核级线程以多种方式执行（1对1，1对n，多对多等）</p><p>内核调度中</p><ul><li>进程是重量级单元，创建、销毁、切换进程代价昂贵（上下文切换、缓存刷新等）。</li><li>进程拥有OS分配的资源，如内存、文件句柄、socket和PCB等。</li><li>进程之间是隔离的，除非显式指定（继承文件句柄、IPC等），否则不共享资源。</li></ul></li><li><p>内核级线程，在内核调度中</p><ul><li>用户级线程，是轻量级单元，仅拥有栈、寄存器副本、线程本地存储等少量资源，因此创建、销毁、切换成本低。</li><li>切换需要上下文切换（保护和恢复寄存器和堆栈指针），但不更改虚拟内存，因此对缓存友好</li><li>内核可以为CPU每个核心分配一个或多个内核级线程，并且可以在阻塞时交换。然而，内核级线程交换的时间远远长于用户级线程</li></ul></li><li><p>用户级线程，线程在用户库中实现时，对操作系统是透明的，称为用户级线程，有些实现采用 M:N 模型来实现。虚拟机实现的线程有时被称为绿色线程。</p><ul><li><p>由于用户线程实现通常完全在用户空间中，因此同一进程内的用户线程之间的上下文切换非常高效，因为它根本不需要与内核进行任何交互，可以通过本地保存用户线程使用的 CPU 寄存器来执行上下文切换。</p><p>并且，由于调度发生在用户空间中，因此可以更轻松地根据程序工作负载的要求定制调度策略</p></li><li><p>然而，在用户线程（而不是内核线程）中使用<strong>阻塞系统调用</strong>可能会出现问题。如果用户线程或纤程执行阻塞的系统调用，则进程中的其他用户线程和纤程将无法运行，直到系统调用返回。</p><p>此问题的常见解决方案（特别是许多绿色线程实现使用的，java.io, java.nio）是提供一个 I/O API，该 API 通过在内部使用非阻塞 I/O 来实现阻塞调用线程而不是整个进程的接口，并在 I/O 操作正在进行时调度另一个用户线程或纤程。</p></li></ul></li><li><p>纤程，纤程是一种更轻量的调度单元，它是<strong>协作调度</strong>的：正在运行的纤程必须显式“让出”（yield）以允许另一个纤程运行，这使得它们的实现比内核或用户线程容易得多。纤程可以安排在同一进程的任何线程中运行。这允许应用程序通过管理调度本身来获得性能改进，而不是依赖于内核调度程序（可能不会针对应用程序进行调整）。 OpenMP 等并行编程环境有时通过纤程实现其任务。与纤程密切相关的是协程，区别在于<strong>协程是语言级构造（Python的asyncio库和Go语言的goroutine），而纤程是系统级构造</strong>。</p></li></ul><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><ul><li>抢占式调度和协作式调度</li><li>线程模型<ul><li>1:1，内核线程</li><li>M:1，用户级线程</li><li>M:N，混合线程</li></ul></li></ul><h1 id="Go调度器"><a href="#Go调度器" class="headerlink" title="Go调度器"></a>Go调度器</h1><p><a href="https://go.dev/src/runtime/HACKING">https://go.dev/src/runtime/HACKING</a></p><h2 id="go调度器结构（GMP模型）"><a href="#go调度器结构（GMP模型）" class="headerlink" title="go调度器结构（GMP模型）"></a>go调度器结构（GMP模型）</h2><p>我们已经知道，goroutine是一种Go实现的协程。它使用的是M:N的线程模型，由于管理G、M、P三种资源，有时也被称为GMP模型。</p><p>Go调度器管理三种类型资源</p><ul><li>G 代表一个goroutine，G在M上进行上下文切换。</li><li>M 代表OS线程（machine）</li><li>P 代表go代码需要的资源，相当于OS调度器中的CPU</li></ul><p>另外，Go调度器有两种运行队列</p><ul><li>GRQ（global runnable queue），全局运行队列</li><li>LRQ（local runnable queue），本地运行队列，每个P都有一个LRQ，用于管理分配给P的goroutines，这些goroutine轮流进行上下文切换，打开和关闭分配给该P的M</li></ul><p><img src="./../../../../img/94_figure2.png" alt="img"></p><h2 id="调度机制"><a href="#调度机制" class="headerlink" title="调度机制"></a>调度机制</h2><p><strong>Go的调度器是协作式的，但看起来是抢占式的。</strong></p><p>G-P-M模型：调度器通过G-P-M模型来协调Goroutine的调度。Goroutine被关联到P上，P被关联到M上。当一个Goroutine阻塞时，所关联的P会从M上分离，以便让其他未阻塞的Goroutine继续执行。当阻塞的Goroutine解除阻塞时，调度器会将它重新关联到某个可用的P上，并将P关联到某个可用的M上。</p><p>当Go程序中发生以下四类事件会使Go调度器做出调度决策，这表示程序将获得调度的机会（但不是一定被调度）</p><ul><li>使用go关键字</li><li>垃圾回收gc</li><li>系统调用，如果 Goroutine 进行系统调用，导致 Goroutine 阻塞 M，有时调度程序能够将 Goroutine 与 M 进行上下文切换，并将新的 Goroutine 上下文切换到同一个 M 上。但是，有时会出现一个新的 M需要继续执行在 P 中排队的 Goroutines。</li><li>同步（Synchronization）和编排（Orchestration），如果原子、互斥或通道操作调用将导致 Goroutine 阻塞，调度程序可以上下文切换一个新的 Goroutine 来运行。一旦 Goroutine 可以再次运行，它就可以重新排队并最终在 M 上切换回上下文。</li></ul><h3 id="异步系统调用"><a href="#异步系统调用" class="headerlink" title="异步系统调用"></a>异步系统调用</h3><p>当操作系统具有异步处理系统调用的能力时，go会使用 <a href="https://golang.org/src/runtime/netpoll.go">network poller</a> 来更高效地处理系统调用。以Linux为例，</p><ol><li>此时，G1在线程M上工作，G2、G3、G4在等待，netpoller处于空闲。</li></ol><p><img src="./../../../../img/94_figure3.png" alt="img"></p><ol start="2"><li>当G1发起网络系统调用，G1被移动到netpoller。此时M可以执行LRQ中其他goroutine，G2在M上发生上下文切换并执行。</li></ol><p><img src="./../../../../img/94_figure4.png" alt="img"></p><ol start="3"><li>异步的网络系统调用由网络轮询器完成，G1被移回到P的LRQ中。<br>这里最大的好处是，<strong>不需要每次执行网络系统调用时，都创建额外的 M</strong>。网络轮询器有一个操作系统线程，它正在处理一个高效的事件循环。即由网络轮询器实现io复用，集中在一个操作系统线程处理。</li></ol><p><img src="./../../../../img/94_figure5.png" alt="img"></p><h3 id="同步系统调用"><a href="#同步系统调用" class="headerlink" title="同步系统调用"></a>同步系统调用</h3><p>使用文件io等系统调用无法使用netpoller处理，只能让M阻塞</p><p>1 G1执行同步系统调用，阻塞线程M1</p><p><img src="./../../../../img/94_figure6.png" alt="img"></p><p>2 M1阻塞，调度器引入一个新线程M2来服务P，执行G2。如果M2是本身存在，则转换会比创建更快。</p><p><img src="./../../../../img/94_figure7.png" alt="img"></p><p>3 G1发起的系统调用已完成，G1移回LRQ，M1放在一边， 以便后续再出现这种情况时使用。</p><p><img src="./../../../../img/94_figure8.png" alt="img"></p><h3 id="工作窃取"><a href="#工作窃取" class="headerlink" title="工作窃取"></a>工作窃取</h3><p><a href="https://rakyll.org/scheduler/">https://rakyll.org/scheduler/</a></p><p>Work Stealing：调度器使用工作窃取（Work Stealing）算法来实现负载均衡。每个P都维护了一个本地队列，用于存储待执行的Goroutine。<strong>当一个P的本地队列为空时，它会尝试从其他P的本地队列中窃取Goroutine来执行</strong>。这样可以确保Goroutine均匀地分配给所有的P。</p><p>1 这里有两个P，分别为4个goroutine工作</p><p><img src="./../../../../img/94_figure9.png" alt="img"></p><p>2 其中一个P1完成了所有的G，此时它要从P2的LRQ中窃取一个G。<br>窃取规则：<br>1）以1/61的概率会直接检查全局的GRQ。这是为了避免过度频繁地检查全局队列，以提高性能。<br>2）检查自己的LRQ<br>3）检查其他P的LRQ<br>4）检查GRQ<br>5）进行网络轮询（poll network）。这表示运行时会检查是否有网络事件需要处理，以确保网络通信的进行。</p><p><img src="./../../../../img/94_figure10.png" alt="img"></p><p>3 P1从P2的LRQ窃取了一半的工作</p><p><img src="./../../../../img/94_figure11.png" alt="img"></p><p>4 这次P2提前完成了工作，首先从P1中窃取，由于P1的LRQ为空，再次检查GRQ，窃取G9</p><p><img src="./../../../../img/94_figure12.png" alt="img"></p><p>5 P2执行G9</p><p><img src="./../../../../img/94_figure13.png" alt="img"></p><h3 id="go调度器的优势"><a href="#go调度器的优势" class="headerlink" title="go调度器的优势"></a>go调度器的优势</h3><p>以下是一个用C写的多线程程序示例</p><p>1 core1上的T1线程发送msg</p><p><img src="./../../../../img/94_figure14.png" alt="img"></p><p>2 发送完成后T1需要等待响应，进入等待态。T2收到该消息的通知进入可运行态，当调度器调度T2在core2上运行，向T1回复一个msg</p><p><img src="./../../../../img/94_figure15.png" alt="img"></p><p>3 T1收到通知并进入就绪态，切换上下文后运行，再向T2回复消息</p><p><img src="./../../../../img/94_figure16.png" alt="img"></p><p>所有这些上下文切换和状态更改都需要时间来执行，这限制了工作完成的速度。每个上下文切换可能会产生大约 1000 纳秒的延迟，并且希望硬件每纳秒执行 12 条指令，因此您会看到或多或少有 12k 条指令在这些上下文切换期间不执行。由于这些线程也在不同的核心之间跳跃，因此由于缓存行未命中而产生额外延迟的可能性也很高。</p><p>下面以go来写这个程序</p><p>1 M1上的G1向G2发送msg</p><p><img src="./../../../../img/94_figure17.png" alt="img"></p><p>2 发送后，G1进入LRQ。<strong>Go调度器可以让G2也在M1上工作，并且M1仍在C1上工作，避免了系统线程的上下文切换开销</strong>。G2向G1回复msg</p><p><img src="./../../../../img/94_figure18.png" alt="img"></p><p>3 G2进入LRQ，G1回复消息</p><p><img src="./../../../../img/94_figure19.png" alt="img"></p><p>使用goroutine的优势是，用相同的系统线程和核心来处理，在操作系统的角度，线程永远不会进入等待，因此避免了上下文切换的开销。</p><p>本质上，Go 将 IO/阻塞工作转变为操作系统级别的 CPU 密集型工作。由于所有上下文切换都发生在应用程序级别，因此每次上下文切换我们不会丢失使用线程时丢失的约 12k 指令（平均）。在 Go 中，这些相同的上下文切换会花费您约 200 纳秒或约 2.4k 条指令。该调度程序还有助于提高<strong>缓存行效率</strong>和 NUMA。这就是为什么我们不需要比虚拟核心更多的线程。在 Go 中，随着时间的推移，可以完成更多的工作，因为 Go 调度程序尝试使用<strong>更少的线程并在每个线程上执行更多操作</strong>，这有助于减少操作系统和硬件上的负载。</p><h2 id="GM"><a href="#GM" class="headerlink" title="GM"></a>GM</h2><p>GM是废弃的go调度器，看完GMP模型，很容易看出GM模型的主要缺点在于没有让不同goroutine在同一核心工作的能力，所以还是会有上下文切换的问题。</p><p><img src="./../../../../img/image-20240511232251987.png" alt="image-20240511232251987"></p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p>todo</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go并发编程</title>
      <link href="/2024/05/15/go%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"/>
      <url>/2024/05/15/go%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>介绍golang的错误处理机制</p><span id="more"></span><p><a href="https://go.dev/blog/error-handling-and-go">https://go.dev/blog/error-handling-and-go</a></p><p><a href="https://golangdocs.com/errors-exception-handling-in-golang">https://golangdocs.com/errors-exception-handling-in-golang</a></p><p><a href="https://pkg.go.dev/errors">https://pkg.go.dev/errors</a></p><h2 id="errors模块"><a href="#errors模块" class="headerlink" title="errors模块"></a>errors模块</h2><p>errors是go的标准库之一，用于处理错误</p><ul><li><a href="https://pkg.go.dev/errors#As">func As(err error, target any) bool</a> 将一个错误值转换为指定类型，并将转换结果存储在目标变量中，自定义异常可以自定义As方法</li><li><a href="https://pkg.go.dev/errors#Is">func Is(err, target error) bool</a> 检查一个错误是否是指定类型的错误</li><li><a href="https://pkg.go.dev/errors#Join">func Join(errs …error) error</a> 用换行符连接全部错误</li><li><a href="https://pkg.go.dev/errors#New">func New(text string) error</a> 返回新错误</li><li><a href="https://pkg.go.dev/errors#Unwrap">func Unwrap(err error) error</a> 获取一个错误值的底层错误，不会解开Join方法生成的组合错误</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常</span></span><br><span class="line"><span class="keyword">type</span> MyError <span class="keyword">struct</span> &#123;</span><br><span class="line">Code <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;MyError: %d&quot;</span>, e.Code)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义As方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyError)</span> <span class="title">As</span><span class="params">(target <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> t, ok := target.(*MyError); ok &#123;</span><br><span class="line">*t = *e</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常实现错误链</span></span><br><span class="line"><span class="keyword">type</span> MyWrapError <span class="keyword">struct</span> &#123;</span><br><span class="line">Code <span class="keyword">int</span></span><br><span class="line">WErr error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *MyWrapError)</span> <span class="title">Error</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;Err: %d -&gt; WrapError: %s&quot;</span>, e.Code, e.WErr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> err1, err2 *MyError</span><br><span class="line">err2 = &amp;MyError&#123;&#125;</span><br><span class="line">errors.As(&amp;MyError&#123;<span class="number">1</span>&#125;, &amp;err1)</span><br><span class="line">err2.As(&amp;MyError&#123;<span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line">errors.Is(errors.New(<span class="string">&quot;err&quot;</span>), &amp;MyError&#123;&#125;)</span><br><span class="line"></span><br><span class="line">err := errors.Join(err1, err2)</span><br><span class="line">fmt.Println(err)</span><br><span class="line"></span><br><span class="line">werr := fmt.Errorf(<span class="string">&quot;error2: [%w]&quot;</span>, errors.New(<span class="string">&quot;error1&quot;</span>))</span><br><span class="line">fmt.Println(werr)</span><br><span class="line">fmt.Println(errors.Unwrap(werr))</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">fmt.Println(MyWrapError&#123;<span class="number">1</span>, errors.New(<span class="string">&quot;norm error&quot;</span>)&#125;)</span><br><span class="line">fmt.Println(errors.Unwrap(werr))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="go错误处理"><a href="#go错误处理" class="headerlink" title="go错误处理"></a>go错误处理</h2><p>go处理error的方式是将error作为方法的最后一个返回值，非空时处理。可以使用<code>_</code>忽略错误</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;errors&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">e</span><span class="params">(v <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span>, errors.New(<span class="string">&quot;42 is unexpected!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _, err := e(<span class="number">0</span>)</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;   <span class="comment">// check error here</span></span><br><span class="line">        fmt.Println(err)      <span class="comment">// 42 is unexpected!</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ret, _ := e(<span class="number">1</span>) <span class="comment">// ignoring errors</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Panic-and-recover"><a href="#Panic-and-recover" class="headerlink" title="Panic and recover"></a>Panic and recover</h2><p><code>panic</code> 函数用于引发运行时异常（panic），它会立即停止当前函数的执行，并开始沿着调用栈向上传播，直到程序终止。当某个严重错误发生时，你可以使用 <code>panic</code> 来中断程序的正常流程，并触发异常处理流程。</p><p>为了捕获并处理 <code>panic</code>，可以使用 <code>recover</code> 函数。<code>recover</code> 用于恢复程序的控制权，并允许在 <code>defer</code> 函数中处理 <code>panic</code> 引发的异常。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(s <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(s) <span class="comment">// throws panic</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// defer makes the function run at the end</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; <span class="comment">// recovers panic</span></span><br><span class="line"><span class="keyword">if</span> e := <span class="built_in">recover</span>(); e != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Recovered from panic&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">f(<span class="string">&quot;Panic occurs!!!&quot;</span>) <span class="comment">// throws panic</span></span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>) <span class="comment">// not print</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>panic触发后程序终止，执行defer中的内容，recover恢复程序执行。</p><p>出现panic的情景</p><ul><li>数组/切片越界</li><li>空指针调用。比如访问一个 nil 结构体指针的成员</li><li>过早关闭 HTTP 响应体</li><li>除以 0</li><li>向已经关闭的 channel 发送消息</li><li>重复关闭 channel</li><li>关闭未初始化的 channel</li><li>未初始化 map。注意访问 map 不存在的 key 不会 panic，而是返回 map 类型对应的零值，但是不能直接赋值</li><li>跨协程的 panic 处理</li><li>sync 计数为负数。</li><li>类型断言不匹配。<code>var a interface&#123;&#125; = 1; fmt.Println(a.(string))</code> 会 panic，建议用 <code>s,ok := a.(string)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go并发编程</title>
      <link href="/2024/05/13/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
      <url>/2024/05/13/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>介绍golang的goroutine、channel和基本的并发编程api</p><span id="more"></span><h1 id="goroutine和channel"><a href="#goroutine和channel" class="headerlink" title="goroutine和channel"></a>goroutine和channel</h1><h2 id="协程概念"><a href="#协程概念" class="headerlink" title="协程概念"></a>协程概念</h2><ul><li>进程：是应用程序的启动实例，每个进程都有独立的内存空间，不同的进程通过进程间的通信方式来通信。</li><li>线程：从属于进程，每个进程至少包含一个线程，线程是 CPU 调度的基本单位，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信。</li><li>协程：为轻量级线程，与线程相比，协程不受操作系统的调度，协程的调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行</li></ul><h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>Goroutine 是 Go 语言中的轻量级并发执行单元。与操作系统线程相比,goroutine 的<strong>创建和切换成本</strong>非常低,可以轻松地创建成千上万个 goroutine。</p><ol><li><p><strong>创建 Goroutine</strong>:</p><ul><li>可以使用 <code>go</code> 关键字来创建一个新的 goroutine。</li><li>新创建的 goroutine 与原有的 goroutine 并发执行,相互独立。</li></ul></li><li><p><strong>Goroutine 调度</strong>:</p><ul><li>Go 运行时会自动管理 goroutine 的调度,将 goroutine 分配到可用的 CPU 核心上执行。</li><li>Go 运行时使用 M:N 调度模型,即 M 个 OS 线程映射 N 个 goroutine。</li><li>当一个 goroutine 发生阻塞时,Go 运行时会自动切换到其他可运行的 goroutine,从而实现了并发执行。</li></ul></li><li><p><strong>Goroutine 通信</strong>:</p><ul><li>Go 语言鼓励使用通道(channel)在 goroutine 之间进行通信,而不是使用共享内存和锁。</li><li>通道可以在 goroutine 之间传递数据,并提供了同步和互斥的机制。</li></ul></li><li><p><strong>Goroutine 生命周期</strong>:</p><ul><li>当一个 goroutine 执行完毕后,它会自动退出。</li><li>如果主 goroutine 退出,所有其他 goroutine 也会被强制终止。</li><li>可以使用 <code>sync.WaitGroup</code> 等机制来等待多个 goroutine 全部执行完毕。</li></ul></li><li><p><strong>Goroutine 状态</strong>:</p><ul><li>Goroutine 有以下几种状态:<ul><li><code>Running</code>: 当前正在执行</li><li><code>Runnable</code>: 已就绪,等待被调度</li><li><code>Waiting</code>: 正在等待某个条件满足</li><li><code>Stopped</code>: 已经停止或退出</li></ul></li></ul></li><li><p><strong>Goroutine 调试</strong>:</p><ul><li>Go 语言提供了一些工具和库,可以帮助开发者调试和分析 goroutine 的执行情况,如 <code>runtime/pprof</code>、<code>net/http/pprof</code> 等。</li></ul></li></ol><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><p><strong>创建 goroutine</strong>:</p><ul><li>使用 <code>go</code> 关键字启动一个新的 goroutine。</li><li>例如: <code>go myFunction()</code></li></ul></li><li><p><strong>退出goroutine</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.Goexit()</span><br></pre></td></tr></table></figure></li><li><p><strong>等待 goroutine 结束</strong>:</p><ul><li>可以使用 <code>sync.WaitGroup</code> 来等待多个 goroutine 全部执行完毕。</li><li>示例代码:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> doWork1(&amp;wg)</span><br><span class="line">    <span class="keyword">go</span> doWork2(&amp;wg)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;All goroutines completed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork1</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="comment">// do some work</span></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork2</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="comment">// do some work</span></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>通过通道(channel)进行通信</strong>:</p><ul><li>goroutine 之间常用通道进行数据交换和同步。</li><li>示例代码:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sender(ch)</span><br><span class="line">    receiver(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sender</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="number">42</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiver</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    value := &lt;-ch</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>限制 goroutine 数量</strong>:</p><ul><li>可以使用 <code>sync.WaitGroup</code> 和 <code>buffered channel</code> 来限制并发 goroutine 的数量。</li><li>示例代码:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sem := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-sem &#125;()</span><br><span class="line">            <span class="comment">// do some work</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>处理 goroutine 错误</strong>:</p><ul><li>可以使用 <code>recover()</code> 函数捕获 goroutine 中发生的 panic。</li><li>示例代码:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> safeFunction()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safeFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Recovered from:&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;Something went wrong&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>在 Go 编程语言中,通道(channel)是一种用于在 goroutine 之间进行数据通信的机制。它们提供了一种安全和高效的方式来共享数据,并帮助实现并发编程。对于有返回值的go执行函数，需要使用channel来获取返回值。类似进程间通信，管道等。</p><p><strong>通道的使用场景</strong>: 通道在实现并发编程、生产者-消费者模式、扇出/扇入模式、管道等场景中非常有用。它们提供了一种安全和高效的方式来在 goroutine 之间传递数据和同步执行。</p><h3 id="创建和使用channel"><a href="#创建和使用channel" class="headerlink" title="创建和使用channel"></a>创建和使用channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel &lt;- value <span class="comment">//发送value到channel</span></span><br><span class="line">&lt;-channel <span class="comment">//接收并丢弃</span></span><br><span class="line">x := channel <span class="comment">//接收</span></span><br><span class="line">x, ok := &lt;-channel <span class="comment">//接收并检查通道是否关闭或为空</span></span><br></pre></td></tr></table></figure><p>channel会同步两个协程，不会出现发送时，接收协程已经死亡的情况</p><ul><li>无缓冲channel</li><li>有缓存channel</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//无缓冲</span></span><br><span class="line"><span class="comment">//c := make(chan int, 3) //带缓存</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c &lt;- <span class="number">666</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">num := &lt;- c</span><br></pre></td></tr></table></figure><h3 id="缓冲区和阻塞"><a href="#缓冲区和阻塞" class="headerlink" title="缓冲区和阻塞"></a>缓冲区和阻塞</h3><p>Go 中的通道可以是有缓冲的,也可以是无缓冲的。缓冲区的大小决定了发送和接收操作是否会阻塞。理解缓冲区和阻塞是掌握 Go 并发编程的关键。</p><ol><li><p><strong>缓冲区</strong>:</p><ul><li>缓冲区是通道内部用于存储数据的一块内存空间。</li><li>当创建一个通道时,可以指定它的缓冲区大小,也就是它可以存储的最大数据量。</li><li>有缓冲通道:<ul><li>如果通道的缓冲区未满,向该通道发送数据不会阻塞。数据会先存入缓冲区。</li><li>如果通道的缓冲区为空,从该通道接收数据不会阻塞。它会等待直到有数据可以接收。</li></ul></li><li>无缓冲通道:<ul><li>缓冲区大小为 0,发送和接收操作都必须立即完成。</li><li>发送和接收操作会阻塞,直到另一端准备好进行相应的操作。</li></ul></li></ul></li><li><p><strong>阻塞</strong>:</p><ul><li>阻塞是指 goroutine 在执行某个操作时被暂时挂起,直到条件满足才能继续执行。</li><li>在通道中,发送和接收操作都可能会导致 goroutine 阻塞:<ul><li>向无缓冲通道发送数据时,如果没有 goroutine 准备接收,发送操作会阻塞。</li><li>从无缓冲通道接收数据时,如果没有 goroutine 准备发送,接收操作会阻塞。</li><li>向有缓冲通道发送数据时,如果缓冲区已满,发送操作会阻塞。</li><li>从有缓冲通道接收数据时,如果缓冲区为空,接收操作会阻塞。</li></ul></li><li>阻塞可以帮助 goroutine 进行有效的同步和协调,避免资源竞争。</li></ul></li><li><p><strong>示例</strong>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个容量为 2 的有缓冲通道</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向通道发送 3 个数据</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Sent 2 values, channel is full&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一次发送会阻塞,因为通道已满</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;This will not be printed&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从通道接收 2 个数据</span></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从空通道接收会阻塞</span></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(<span class="string">&quot;This will not be printed&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>使用场景:</strong><br>无缓存channel适用于数据要求同步的场景，而有缓存channel适用于无数据同步的场景。可以根据实现项目需求选择</p></li></ol><h3 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h3><p>可以使用 <code>close()</code> 函数关闭通道,这样可以向通道发送一个特殊的”关闭”信号。关闭后,再向该通道发送数据会导致 panic。从一个已经关闭的通道接收数据会返回通道元素类型的零值和一个 boolean 值,指示通道是否已关闭。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">c &lt;- i</span><br><span class="line"><span class="built_in">close</span>(c)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">if</span> data,ok := &lt;-c ; ok &#123;</span><br><span class="line">fmt.Println(data)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关闭后无法发送数据，向关闭channel发送已经关闭的channel报panic错误</li><li>关闭后可以继续接收数据</li><li>向nil channel发送和接收数据导致阻塞</li></ul><h3 id="channel和range"><a href="#channel和range" class="headerlink" title="channel和range"></a>channel和range</h3><p> <code>range</code> 语句从通道中<strong>接收并迭代数据</strong>。<code>range</code> 会一直阻塞,直到通道被关闭,然后它会退出循环。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> c &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="channel和select"><a href="#channel和select" class="headerlink" title="channel和select"></a>channel和select</h3><p>用于管理多个channel，<code>select</code> 语句允许 Go 程同时等待<strong>多个通道</strong>的操作。它会阻塞,直到其中一个通道ready,然后执行相应的 case 语句。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;- chan1:</span><br><span class="line"><span class="comment">//chan1读到数据执行</span></span><br><span class="line"><span class="keyword">case</span> &lt;- chan2:</span><br><span class="line"><span class="comment">//chan2读到数据执行</span></span><br><span class="line"><span class="keyword">case</span> &lt;- chan3:</span><br><span class="line"><span class="comment">//chan3读到数据执行</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//都没有读到执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacii</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span><span class="params">()</span></span>  &#123;</span><br><span class="line">x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> c &lt;- x:</span><br><span class="line">x = y</span><br><span class="line">y = x + y</span><br><span class="line"><span class="keyword">case</span> &lt;-quit:</span><br><span class="line">fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">6</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-c) </span><br><span class="line">&#125;</span><br><span class="line">quit&lt;<span class="number">-0</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    fibonacii(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h3><p>Go 中的 channel 是由以下几个部分组成的复合数据结构:</p><ol><li><p><strong>hchan 结构体</strong>:</p><ul><li>这是 channel 的核心数据结构,定义在 <code>runtime/chan.go</code> 文件中。</li><li>它包含了 channel 的基本属性,如缓冲区大小、当前缓冲区内数据量、发送/接收 goroutine 的队列等。</li></ul></li><li><p><strong>sudog 结构体</strong>:</p><ul><li>这个结构体表示一个阻塞在 channel 上的 goroutine。</li><li>它包含了 goroutine 的上下文信息,如 goroutine 指针、发送/接收的值等。</li><li>当 goroutine 阻塞在 channel 上时,它会被封装成一个 sudog 结构体,加入到 channel 的等待队列中。</li></ul></li><li><p><strong>环形缓冲区</strong>:</p><ul><li>对于有缓冲的 channel,它内部维护了一个环形缓冲区,用于存储发送到 channel 但尚未被接收的数据。</li><li>缓冲区使用 <code>buf</code> 字段表示,它是一个指向数组的指针。</li><li>缓冲区中的数据通过 <code>sendx</code> 和 <code>recvx</code> 字段来跟踪当前的发送和接收位置。</li></ul></li><li><p><strong>互斥锁和条件变量</strong>:</p><ul><li>channel 的并发访问是通过互斥锁 <code>lock</code> 来保护的。</li><li>当 goroutine 阻塞在 channel 上时,它会被放入相应的条件变量 <code>sendq</code> 或 <code>recvq</code> 中等待被唤醒。</li></ul></li></ol><h3 id="channel-是否线程安全"><a href="#channel-是否线程安全" class="headerlink" title="channel 是否线程安全"></a>channel 是否线程安全</h3><p>Go 中的 channel 是通过以下几个机制来实现并发安全的:</p><ol><li><p><strong>互斥锁</strong>:</p><ul><li>每个 channel 都有一个互斥锁 <code>lock</code>，用于保护 channel 的内部状态。</li><li>所有对 channel 的读写操作都需要先获取这个锁，确保同一时刻只有一个 goroutine 能访问 channel 的内部数据。</li></ul></li><li><p><strong>原子操作</strong>:</p><ul><li>channel 的一些关键字段,如 <code>sendx</code>、<code>recvx</code>、<code>sendq.head</code>、<code>recvq.head</code> 等，都是使用原子操作来访问的。</li><li>这确保了即使多个 goroutine 同时访问这些字段,也不会出现数据竞争的问题。</li></ul></li><li><p><strong>条件变量</strong>:</p><ul><li>当 goroutine 试图向一个已满的 channel 发送数据,或从一个空的 channel 接收数据时,它们会被挂起,并加入到相应的等待队列中。</li><li>这些等待队列使用条件变量 <code>sendq</code> 和 <code>recvq</code> 来实现。当 channel 状态发生变化时,条件变量会负责唤醒等待的 goroutine。</li></ul></li><li><p><strong>Goroutine 调度</strong>:</p><ul><li>Go 运行时会负责调度 goroutine 的执行,确保阻塞在 channel 上的 goroutine 能够在条件满足时被及时唤醒。</li></ul></li></ol><p>综上所述,Go 的 channel 实现了以下并发安全特性:</p><ol><li>使用互斥锁保护 channel 的内部状态,防止数据竞争。</li><li>利用原子操作确保关键字段的并发访问安全。</li><li>通过条件变量实现 goroutine 的阻塞和唤醒,避免忙等。</li><li>依赖 Go 运行时的 goroutine 调度机制,确保公平性和活跃性。</li></ol><h1 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h1><p><a href="https://pkg.go.dev/sync">https://pkg.go.dev/sync</a></p><h2 id="Cond条件变量"><a href="#Cond条件变量" class="headerlink" title="Cond条件变量"></a>Cond条件变量</h2><p>条件变量提供了一种方法，使得一个或多个 goroutine 可以<strong>等待某个特定条件的发生，并在条件满足时被唤醒</strong>。它允许一个或多个 goroutine 在满足特定条件之前等待，避免了忙等待（busy-waiting）的问题，从而提高了系统的效率。</p><ul><li><a href="https://pkg.go.dev/sync#Cond">type Cond</a><ul><li><a href="https://pkg.go.dev/sync#NewCond">func NewCond(l Locker) *Cond</a> 使用锁来初始化条件变量</li><li><a href="https://pkg.go.dev/sync#Cond.Broadcast">func (c *Cond) Broadcast()</a> 广播，唤醒所有在等待的goroutine</li><li><a href="https://pkg.go.dev/sync#Cond.Signal">func (c *Cond) Signal()</a> 唤醒一个在等待的goroutine（具体哪个取决于实现 先进先出）</li><li><a href="https://pkg.go.dev/sync#Cond.Wait">func (c *Cond) Wait()</a> 尝试解锁c.Unlock，等待直到被Broadcast或Signal方法唤醒</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">cond := sync.NewCond(&amp;mu)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;Producer: Item produced&quot;</span>)</span><br><span class="line"></span><br><span class="line">cond.L.Lock()</span><br><span class="line">         <span class="comment">//生产</span></span><br><span class="line">cond.L.Unlock()</span><br><span class="line">         cond.Signal() <span class="comment">// 唤醒一个等待的 goroutine</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">cond.L.Lock()</span><br><span class="line"><span class="comment">//消费</span></span><br><span class="line">         cond.L.Unlock()</span><br><span class="line">cond.Wait() <span class="comment">// 等待条件的发生</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Consumer: Item consumed&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;Main goroutine: Done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>典型场景，生产者和消费者同时持有中间结构的锁，上锁-生产者生产-解锁-唤醒消费者-上锁-消费者消费-解锁-等待</p><h2 id="Locker锁"><a href="#Locker锁" class="headerlink" title="Locker锁"></a>Locker锁</h2><p>锁接口</p><h2 id="Mutex互斥锁"><a href="#Mutex互斥锁" class="headerlink" title="Mutex互斥锁"></a>Mutex互斥锁</h2><p>实现了Locker接口</p><ul><li><a href="https://pkg.go.dev/sync#Mutex">type Mutex</a><ul><li><a href="https://pkg.go.dev/sync#Mutex.Lock">func (m *Mutex) Lock()</a></li><li><a href="https://pkg.go.dev/sync#Mutex.TryLock">func (m *Mutex) TryLock() bool</a></li><li><a href="https://pkg.go.dev/sync#Mutex.Unlock">func (m *Mutex) Unlock()</a></li></ul></li></ul><p>使用场景：单读</p><ul><li>playerIds map[int]bool  只有服务器单读</li></ul><h2 id="RWMutex读写锁"><a href="#RWMutex读写锁" class="headerlink" title="RWMutex读写锁"></a>RWMutex读写锁</h2><p>实现了Locker接口</p><ul><li><a href="https://pkg.go.dev/sync#RWMutex">type RWMutex</a><ul><li><a href="https://pkg.go.dev/sync#RWMutex.Lock">func (rw *RWMutex) Lock()</a></li><li><a href="https://pkg.go.dev/sync#RWMutex.RLock">func (rw *RWMutex) RLock()</a></li><li><a href="https://pkg.go.dev/sync#RWMutex.RLocker">func (rw *RWMutex) RLocker() Locker</a></li><li><a href="https://pkg.go.dev/sync#RWMutex.RUnlock">func (rw *RWMutex) RUnlock()</a></li><li><a href="https://pkg.go.dev/sync#RWMutex.TryLock">func (rw *RWMutex) TryLock() bool</a></li><li><a href="https://pkg.go.dev/sync#RWMutex.TryRLock">func (rw *RWMutex) TryRLock() bool</a></li><li><a href="https://pkg.go.dev/sync#RWMutex.Unlock">func (rw *RWMutex) Unlock()</a></li></ul></li></ul><p>使用场景：需要多读</p><ul><li>PropertyMap，多个goroutine需要获取属性</li></ul><h2 id="Map线程安全的map"><a href="#Map线程安全的map" class="headerlink" title="Map线程安全的map"></a>Map线程安全的map</h2><ul><li><a href="https://pkg.go.dev/sync#Map">type Map</a><ul><li><a href="https://pkg.go.dev/sync#Map.CompareAndDelete">func (m *Map) CompareAndDelete(key, old any) (deleted bool)</a></li><li><a href="https://pkg.go.dev/sync#Map.CompareAndSwap">func (m *Map) CompareAndSwap(key, old, new any) bool</a></li><li><a href="https://pkg.go.dev/sync#Map.Delete">func (m *Map) Delete(key any)</a></li><li><a href="https://pkg.go.dev/sync#Map.Load">func (m *Map) Load(key any) (value any, ok bool)</a></li><li><a href="https://pkg.go.dev/sync#Map.LoadAndDelete">func (m *Map) LoadAndDelete(key any) (value any, loaded bool)</a></li><li><a href="https://pkg.go.dev/sync#Map.LoadOrStore">func (m *Map) LoadOrStore(key, value any) (actual any, loaded bool)</a></li><li><a href="https://pkg.go.dev/sync#Map.Range">func (m *Map) Range(f func(key, value any) bool)</a></li><li><a href="https://pkg.go.dev/sync#Map.Store">func (m *Map) Store(key, value any)</a></li><li><a href="https://pkg.go.dev/sync#Map.Swap">func (m *Map) Swap(key, value any) (previous any, loaded bool)</a></li></ul></li></ul><h2 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h2><p>用于实现只执行一次的操作，确保在并发环境中某个函数只会被执行一次</p><ul><li><a href="https://pkg.go.dev/sync#Once.Do">func (o *Once) Do(f func())</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义只执行一次的函数</span></span><br><span class="line">initFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Initialization function executed.&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多个 goroutine 尝试执行函数</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">once.Do(initFunc)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞主 goroutine，等待其他 goroutine 执行完毕</span></span><br><span class="line"><span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景</p><ul><li>初始化操作：某些操作在程序运行期间只需要执行一次，例如初始化全局配置、建立数据库连接池、加载重要的资源等。使用 <code>sync.Once</code> 可以确保这些初始化操作只会执行一次，而不管有多少个 goroutine 尝试执行它们。</li><li>单例模式的创建：在某些情况下，需要确保只有一个实例被创建，如单例模式。使用 <code>sync.Once</code> 可以在多个 goroutine 中安全地创建单例实例，保证只有一个实例被创建并被共享。</li><li>缓存初始化：在使用缓存的场景中，可能需要在第一次使用缓存时进行初始化，例如加载磁盘上的数据到内存中。使用 <code>sync.Once</code> 可以确保只有第一个需要缓存的请求会触发初始化操作，而后续的请求会直接使用已经初始化好的缓存。</li><li>延迟加载：有些操作可能需要在需要时才进行，例如延迟加载配置文件、懒加载昂贵的计算结果等。使用 <code>sync.Once</code> 可以确保这些操作只会在第一次需要时执行，而后续的请求会直接使用已经加载或计算好的结果。</li></ul><h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h2><p>用于存储一组可保存和查询的临时对象，<strong>临时对象可能随时被自动删除，并且没有通知</strong>，可用于实现容量自适应的缓存（典型fmt维护）</p><ul><li><a href="https://pkg.go.dev/sync#Pool">type Pool</a><ul><li><a href="https://pkg.go.dev/sync#Pool.Get">func (p *Pool) Get() any</a></li><li><a href="https://pkg.go.dev/sync#Pool.Put">func (p *Pool) Put(x any)</a></li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bufPool = sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">any</span></span> &#123;</span><br><span class="line"><span class="comment">// The Pool&#x27;s New function should generally only return pointer</span></span><br><span class="line"><span class="comment">// types, since a pointer can be put into the return interface</span></span><br><span class="line"><span class="comment">// value without an allocation:</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// timeNow is a fake version of time.Now for tests.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeNow</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> time.Unix(<span class="number">1136214245</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Log</span><span class="params">(w io.Writer, key, val <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">b := bufPool.Get().(*bytes.Buffer)</span><br><span class="line">b.Reset()</span><br><span class="line"><span class="comment">// Replace this with time.Now() in a real logger.</span></span><br><span class="line">b.WriteString(timeNow().UTC().Format(time.RFC3339))</span><br><span class="line">b.WriteByte(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">b.WriteString(key)</span><br><span class="line">b.WriteByte(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">b.WriteString(val)</span><br><span class="line">w.Write(b.Bytes())</span><br><span class="line">bufPool.Put(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">Log(os.Stdout, <span class="string">&quot;path&quot;</span>, <span class="string">&quot;/search?q=flowers&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p><code>sync.WaitGroup</code> 类型包含一个计数器，可以通过调用 <code>Add</code> 方法增加计数器的值，调用 <code>Done</code> 方法减少计数器的值，以及调用 <code>Wait</code> 方法来阻塞当前 goroutine，直到计数器的值变为零。</p><ul><li><a href="https://pkg.go.dev/sync#WaitGroup">type WaitGroup</a><ul><li><a href="https://pkg.go.dev/sync#WaitGroup.Add">func (wg *WaitGroup) Add(delta int)</a> 添加到等待组</li><li><a href="https://pkg.go.dev/sync#WaitGroup.Done">func (wg *WaitGroup) Done()</a> </li><li><a href="https://pkg.go.dev/sync#WaitGroup.Wait">func (wg *WaitGroup) Wait()</a> </li></ul></li></ul><h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p><a href="https://pkg.go.dev/context">https://pkg.go.dev/context</a></p><p>Go语言的<code>context</code>模块提供了一种在应用程序中传递请求范围数据、控制并发和取消操作的机制。它允许你在一个请求的整个处理过程中跟踪上下文信息，并在需要时传递和使用该信息。</p><p><code>context</code>模块的主要作用如下：</p><ol><li><p>传递请求范围的数据：使用<code>context.Context</code>类型，你可以将请求范围的数据附加到上下文中，并在整个调用链中传递该上下文。这对于在请求处理过程中共享<strong>请求标识、认证信息、语言首选项</strong>等非常有用。</p></li><li><p>控制并发：<code>context</code>模块提供了管理并发操作的功能。你可以使用<code>context.Context</code>来创建带有取消和超时功能的上下文。当一个上下文被取消时，所有基于该上下文的操作都会被取消，这对于避免不必要的资源消耗和提高应用程序的可靠性非常重要。</p></li><li><p>取消操作：通过使用<code>context.Context</code>，你可以方便地取消正在进行的操作。当你需要提前中止一个请求或取消一个长时间运行的操作时，可以调用上下文的<code>cancel</code>函数来取消相关的操作。</p></li><li><p>超时控制：<code>context</code>模块还提供了超时控制的功能。你可以使用<code>context.WithTimeout</code>或<code>context.WithDeadline</code>函数创建一个带有超时限制的上下文。当超过指定的时间限制时，上下文将自动取消。</p></li></ol><p>通过使用<code>context</code>模块，你可以更好地管理并发操作、处理请求范围的数据，并在需要时方便地取消操作。这对于构建可靠的、高效的并发应用程序非常有帮助。</p><h2 id="Context-应用场景"><a href="#Context-应用场景" class="headerlink" title="Context 应用场景:"></a>Context 应用场景:</h2><ul><li>处理超时和取消操作。</li><li>在 goroutine 之间传递请求范围内的数据。</li><li>在 API 服务器中管理请求生命周期。gin包装了类似的机制，handler的参数就是context，从中用c.Param等方法获取请求、连接等信息，回复用ctx.JSON方法。</li><li>在数据库操作中处理超时。gorm框架，context.WithTimeout(context.Background(), 2*time.Second)管理超时。</li><li>在 RPC 系统中控制请求的超时和取消。</li></ul><h2 id="模块方法"><a href="#模块方法" class="headerlink" title="模块方法"></a>模块方法</h2><ul><li><a href="https://pkg.go.dev/context#AfterFunc">func AfterFunc(ctx Context, f func()) (stop func() bool)</a> 在ctx完成（取消、超时）后执行<code>f</code>函数，调用返回的 stop 函数会停止 ctx 与 f 的关联</li><li><a href="https://pkg.go.dev/context#Cause">func Cause(c Context) error</a>  返回导致上下文取消的错误</li><li><a href="https://pkg.go.dev/context#WithCancel">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</a> 创建一个带有取消机制的上下文</li><li><a href="https://pkg.go.dev/context#WithCancelCause">func WithCancelCause(parent Context) (ctx Context, cancel CancelCauseFunc)</a></li><li><a href="https://pkg.go.dev/context#WithDeadline">func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)</a> 创建一个带有截止时间的上下文</li><li><a href="https://pkg.go.dev/context#WithDeadlineCause">func WithDeadlineCause(parent Context, d time.Time, cause error) (Context, CancelFunc)</a></li><li><a href="https://pkg.go.dev/context#WithTimeout">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</a> 创建一个带有超时时间的上下文</li><li><a href="https://pkg.go.dev/context#WithTimeoutCause">func WithTimeoutCause(parent Context, timeout time.Duration, cause error) (Context, CancelFunc)</a></li></ul><h2 id="示例一：管理超时"><a href="#示例一：管理超时" class="headerlink" title="示例一：管理超时"></a>示例一：管理超时</h2><p>定义一个方法等待条件变量，在ctx取消时停止等待</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">waitOnCond := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, cond *sync.Cond, conditionMet <span class="keyword">func</span>()</span> <span class="title">bool</span>) <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// AfterFunc方法，在ctx取消唤醒所有进程，停止等待</span></span><br><span class="line">stopf := context.AfterFunc(ctx, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// We need to acquire cond.L here to be sure that the Broadcast</span></span><br><span class="line"><span class="comment">// below won&#x27;t occur before the call to Wait, which would result</span></span><br><span class="line"><span class="comment">// in a missed signal (and deadlock).</span></span><br><span class="line">cond.L.Lock()</span><br><span class="line"><span class="keyword">defer</span> cond.L.Unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">// If multiple goroutines are waiting on cond simultaneously,</span></span><br><span class="line"><span class="comment">// we need to make sure we wake up exactly this one.</span></span><br><span class="line"><span class="comment">// That means that we need to Broadcast to all of the goroutines,</span></span><br><span class="line"><span class="comment">// which will wake them all up.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// If there are N concurrent calls to waitOnCond, each of the goroutines</span></span><br><span class="line"><span class="comment">// will spuriously wake up O(N) other goroutines that aren&#x27;t ready yet,</span></span><br><span class="line"><span class="comment">// so this will cause the overall CPU cost to be O(N²).</span></span><br><span class="line">cond.Broadcast()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">defer</span> stopf()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Since the wakeups are using Broadcast instead of Signal, this call to</span></span><br><span class="line"><span class="comment">// Wait may unblock due to some other goroutine&#x27;s context becoming done,</span></span><br><span class="line"><span class="comment">// so to be sure that ctx is actually done we need to check it in a loop.</span></span><br><span class="line"><span class="keyword">for</span> !conditionMet() &#123;</span><br><span class="line">cond.Wait()</span><br><span class="line"><span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cond := sync.NewCond(<span class="built_in">new</span>(sync.Mutex))</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">1</span>*time.Millisecond)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">cond.L.Lock()</span><br><span class="line"><span class="keyword">defer</span> cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">err := waitOnCond(ctx, cond, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> i%<span class="number">2</span> == <span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// err := waitOnCond(ctx, cond, func() bool &#123; return false &#125;)</span></span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="示例二：管理连接"><a href="#示例二：管理连接" class="headerlink" title="示例二：管理连接"></a>示例二：管理连接</h2><p>此示例使用 AfterFunc 定义一个从 net.Conn 读取的函数，并在取消上下文时停止读取。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">readFromConn := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, conn net.Conn, b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">stopc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">stop := context.AfterFunc(ctx, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">conn.SetReadDeadline(time.Now())</span><br><span class="line"><span class="built_in">close</span>(stopc)</span><br><span class="line">&#125;)</span><br><span class="line">n, err = conn.Read(b)</span><br><span class="line"><span class="keyword">if</span> !stop() &#123;</span><br><span class="line"><span class="comment">// The AfterFunc was started.</span></span><br><span class="line"><span class="comment">// Wait for it to complete, and reset the Conn&#x27;s deadline.</span></span><br><span class="line">&lt;-stopc</span><br><span class="line">conn.SetReadDeadline(time.Time&#123;&#125;)</span><br><span class="line"><span class="keyword">return</span> n, ctx.Err()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:0&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> listener.Close()</span><br><span class="line"></span><br><span class="line">conn, err := net.Dial(listener.Addr().Network(), listener.Addr().String())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">1</span>*time.Millisecond)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">_, err = readFromConn(ctx, conn, b)</span><br><span class="line">fmt.Println(err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="示例三：管理错误"><a href="#示例三：管理错误" class="headerlink" title="示例三：管理错误"></a>示例三：管理错误</h2><p>此示例使用 AfterFunc 定义一个组合两个 Context 的取消信号的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;errors&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// mergeCancel returns a context that contains the values of ctx,</span></span><br><span class="line"><span class="comment">// and which is canceled when either ctx or cancelCtx is canceled.</span></span><br><span class="line">mergeCancel := <span class="function"><span class="keyword">func</span><span class="params">(ctx, cancelCtx context.Context)</span> <span class="params">(context.Context, context.CancelFunc)</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancelCause(ctx)</span><br><span class="line">stop := context.AfterFunc(cancelCtx, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">cancel(context.Cause(cancelCtx))</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> ctx, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">stop()</span><br><span class="line">cancel(context.Canceled)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ctx1, cancel1 := context.WithCancelCause(context.Background())</span><br><span class="line"><span class="keyword">defer</span> cancel1(errors.New(<span class="string">&quot;ctx1 canceled&quot;</span>))</span><br><span class="line"></span><br><span class="line">ctx2, cancel2 := context.WithCancelCause(context.Background())</span><br><span class="line"></span><br><span class="line">mergedCtx, mergedCancel := mergeCancel(ctx1, ctx2)</span><br><span class="line"><span class="keyword">defer</span> mergedCancel()</span><br><span class="line"></span><br><span class="line">cancel2(errors.New(<span class="string">&quot;ctx2 canceled&quot;</span>))</span><br><span class="line">&lt;-mergedCtx.Done()</span><br><span class="line">fmt.Println(context.Cause(mergedCtx))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="底层结构-1"><a href="#底层结构-1" class="headerlink" title="底层结构"></a>底层结构</h2><p>Go 语言中的 <code>context</code> 包的底层实现比较简单,主要由以下几个部分组成:</p><ol><li><p><strong>context 结构体</strong>:</p><ul><li><code>context</code> 结构体是 <code>context.Context</code> 接口的核心实现。</li><li>它包含了以下几个关键字段:<ul><li><code>done chan struct&#123;&#125;</code>: 一个用于通知 context 被取消的通道。</li><li><code>err error</code>: 表示 context 被取消的原因。</li><li><code>deadline time.Time</code>: context 的截止时间。</li><li><code>values map[interface&#123;&#125;]interface&#123;&#125;</code>: 存储 context 相关的键值对数据。</li></ul></li></ul></li><li><p><strong>emptyCtx 结构体</strong>:</p><ul><li><code>emptyCtx</code> 是 <code>context.Background()</code> 和 <code>context.TODO()</code> 返回的 context 实现。</li><li>它是一个单例模式的结构体,没有任何状态字段。</li></ul></li><li><p><strong>cancelCtx 结构体</strong>:</p><ul><li><code>cancelCtx</code> 是 <code>context.WithCancel()</code> 返回的 context 实现。</li><li>它在 <code>context</code> 结构体的基础上增加了以下字段:<ul><li><code>cancel func()</code>: 取消当前 context 的函数。</li><li><code>children []*cancelCtx</code>: 保存该 context 的所有子 context。</li></ul></li></ul></li><li><p><strong>timerCtx 结构体</strong>:</p><ul><li><code>timerCtx</code> 是 <code>context.WithDeadline()</code> 和 <code>context.WithTimeout()</code> 返回的 context 实现。</li><li>它在 <code>cancelCtx</code> 结构体的基础上增加了以下字段:<ul><li><code>deadline time.Time</code>: context 的截止时间。</li><li><code>timer *time.Timer</code>: 用于在截止时间到达时取消 context 的定时器。</li></ul></li></ul></li><li><p><strong>valueCtx 结构体</strong>:</p><ul><li><code>valueCtx</code> 是 <code>context.WithValue()</code> 返回的 context 实现。</li><li>它在 <code>context</code> 结构体的基础上增加了以下字段:<ul><li><code>key, val interface&#123;&#125;</code>: 存储 context 的键值对。</li></ul></li></ul></li></ol><p>这些结构体共同构成了 <code>context</code> 包的底层实现。当使用不同的 context 创建函数时,会返回对应的结构体实例。</p><h1 id="atom"><a href="#atom" class="headerlink" title="atom"></a>atom</h1><p><a href="https://pkg.go.dev/sync/atomic">https://pkg.go.dev/sync/atomic</a></p><p>todo</p><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a>控制并发数</h2><h3 id="有缓冲通道"><a href="#有缓冲通道" class="headerlink" title="有缓冲通道"></a>有缓冲通道</h3><p>根据通道中没有数据时读取操作陷入阻塞和通道已满时继续写入操作陷入阻塞的特性，正好实现控制并发数量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    count := <span class="number">10</span>                     <span class="comment">// 最大支持并发</span></span><br><span class="line">    sum := <span class="number">100</span>                      <span class="comment">// 任务总数</span></span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;          <span class="comment">//控制主协程等待所有子协程执行完之后再退出。</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, count) <span class="comment">// 控制任务并发的chan</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; sum; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        c &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 作用类似于waitgroup.Add(1)</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Println(j)</span><br><span class="line">            &lt;-c <span class="comment">// 执行完毕，释放资源</span></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三方库实现的协程池"><a href="#第三方库实现的协程池" class="headerlink" title="第三方库实现的协程池"></a>第三方库实现的协程池</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/Jeffail/tunny&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool := tunny.NewFunc(<span class="number">10</span>, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        log.Println(i)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">defer</span> pool.Close()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">500</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> pool.Process(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手动实现协程池"><a href="#手动实现协程池" class="headerlink" title="手动实现协程池"></a>手动实现协程池</h3><p>todo</p><h2 id="Mutex-有几种模式？"><a href="#Mutex-有几种模式？" class="headerlink" title="Mutex 有几种模式？"></a>Mutex 有几种模式？</h2><p><strong>1）正常模式</strong></p><ol><li>当前的mutex只有一个goruntine来获取，那么没有竞争，直接返回。</li><li>新的goruntine进来，如果当前mutex已经被获取了，则该goruntine进入一个先入先出的waiter队列，在mutex被释放后，waiter按照先进先出的方式获取锁。该goruntine会处于自旋状态(不挂起，继续占有cpu)。</li><li>新的goruntine进来，mutex处于空闲状态，将参与竞争。新来的 goroutine 有先天的优势，它们正在 CPU 中运行，可能它们的数量还不少，所以，在高并发情况下，被唤醒的 waiter 可能比较悲剧地获取不到锁，这时，它会被插入到队列的前面。如果 waiter 获取不到锁的时间超过阈值 1 毫秒，那么，这个 Mutex 就进入到了饥饿模式。</li></ol><p><strong>2）饥饿模式</strong></p><p>在饥饿模式下，Mutex 的拥有者将直接把锁交给队列最前面的 waiter。新来的 goroutine 不会尝试获取锁，即使看起来锁没有被持有，它也不会去抢，也不会 spin（自旋），它会乖乖地加入到等待队列的尾部。 如果拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式:</p><ol><li>此 waiter 已经是队列中的最后一个 waiter 了，没有其它的等待锁的 goroutine 了；</li><li>此 waiter 的等待时间小于 1 毫秒。</li></ol><h2 id="goroutine-的自旋占用资源如何解决"><a href="#goroutine-的自旋占用资源如何解决" class="headerlink" title="goroutine 的自旋占用资源如何解决"></a>goroutine 的自旋占用资源如何解决</h2><p>自旋锁是指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断地判断是否能够被成功获取，直到获取到锁才会退出循环。</p><p><strong>自旋的条件如下：</strong></p><p>1）还没自旋超过 4 次,</p><p>2）多核处理器，</p><p>3）GOMAXPROCS &gt; 1，</p><p>4）p 上本地 goroutine 队列为空。</p><p>mutex 会让当前的 goroutine 去空转 CPU，在空转完后再次调用 CAS 方法去尝试性的占有锁资源，直到不满足自旋条件，则最终会加入到等待队列里。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go数据结构</title>
      <link href="/2024/05/11/go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/05/11/go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>介绍golang的slice、map相关内容</p><span id="more"></span><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p>数组(Array)是一种固定长度的数据结构,用于存储一组相同类型的元素</p><ol><li><strong>长度固定</strong>:<ul><li>数组的长度在创建时就确定,不能动态改变。</li><li>数组的长度是类型的一部分,如 <code>[5]int</code> 和 <code>[10]int</code> 是不同的类型。</li></ul></li><li><strong>元素类型相同</strong>:<ul><li>数组中的所有元素必须是相同类型的值。</li><li>数组支持基本数据类型和复合数据类型(如结构体)。</li></ul></li><li><strong>零值</strong>:<ul><li>未初始化的数组,其元素的值为该元素类型的零值。</li></ul></li><li><strong>创建数组</strong>:<ul><li>直接声明: <code>var arr [5]int</code></li><li>使用字面量: <code>arr := [5]int&#123;1, 2, 3, 4, 5&#125;</code></li><li>使用省略号: <code>arr := [...]int&#123;1, 2, 3, 4, 5&#125;</code></li></ul></li><li><strong>访问元素</strong>:<ul><li>通过下标访问: <code>arr[index]</code></li><li>下标从 0 开始</li></ul></li><li><strong>数组作为函数参数</strong>:<ul><li>数组作为函数参数时,实际上是值传递,函数内部操作的是数组的副本。</li><li>如果需要修改原数组,可以传递数组的指针。</li></ul></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> myArray [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">    myArray2 := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;<span class="built_in">len</span>(myArray1); i++&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> idx, val =: <span class="keyword">range</span> myArray2 &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//打印类型</span></span><br><span class="line">    fmt.Printf(<span class="string">&quot;%T&quot;</span>, myArray=<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//值拷贝 长度必须确定 比较麻烦 实际使用动态数组居多</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArray</span><span class="params">(arr [4]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态数组（切片）"><a href="#动态数组（切片）" class="headerlink" title="动态数组（切片）"></a>动态数组（切片）</h1><p>在 Go 语言中,切片(Slice)是一种<strong>引用类型</strong>,它代表了数组的一部分。切片拥有以下特点:</p><ol><li><p><strong>长度和容量</strong>:</p><ul><li>切片的长度(length)表示切片中元素的数量。</li><li>切片的容量(capacity)表示从切片的第一个元素到底层数组末尾的元素数量。</li></ul></li><li><p><strong>零值</strong>:</p><ul><li>未初始化的切片的零值是 <code>nil</code>。</li><li>一个零值切片的长度和容量都为 0。</li></ul></li><li><p><strong>创建切片</strong>:</p><ul><li>直接声明: <code>var s []int</code></li><li>使用字面量: <code>s := []int&#123;1, 2, 3&#125;</code></li><li>从数组或切片获取: <code>s := arr[start:end]</code> 或 <code>s := arr[start:end:capacity]</code></li></ul></li><li><p><strong>切片操作</strong>:</p><ul><li>获取元素: <code>s[index]</code></li><li>设置元素: <code>s[index] = value</code></li><li>追加元素: <code>s = append(s, 1, 2, 3)</code></li><li>截取子切片: <code>s2 := s[start:end]</code> 或 <code>s2 := s[start:end:capacity]</code></li></ul></li><li><p><strong>切片底层数组</strong>:</p><ul><li>切片和它的底层数组共享内存,对切片的修改会影响到底层数组。</li><li>当切片的容量不足时,会自动分配一个新的底层数组。</li></ul></li><li><p><strong>slice作为函数参数</strong>:</p><ul><li>是引用传递</li></ul></li></ol><p>示例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建切片</span></span><br><span class="line"><span class="keyword">var</span> numbers = <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">5</span>) <span class="comment">//len为3 capacity为5 </span></span><br><span class="line"></span><br><span class="line">nums := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">fmt.Println(nums)     <span class="comment">// 输出: [1 2 3 4 5]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(nums)) <span class="comment">// 输出: 5</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(nums)) <span class="comment">// 输出: 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片操作</span></span><br><span class="line">subNums := nums[<span class="number">2</span>:<span class="number">4</span>] <span class="comment">//通过截取创建的切片，是引用原数组，改变了切片原数组也改变，同理，改变了原数组，切片也发送改变</span></span><br><span class="line">fmt.Println(subNums)   <span class="comment">// 输出: [3 4]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(subNums)) <span class="comment">// 输出: 2</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(subNums)) <span class="comment">// 输出: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加元素</span></span><br><span class="line">nums = <span class="built_in">append</span>(nums, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">fmt.Println(nums)     <span class="comment">// 输出: [1 2 3 4 5 6 7]</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(nums)) <span class="comment">// 输出: 7</span></span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(nums)) <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//深拷贝</span></span><br><span class="line">s2 :=<span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>)  <span class="comment">//创建一个完全独立于原数组的切片副本，改变这个切片不会影响原数组</span></span><br><span class="line"><span class="built_in">copy</span>(s2, s)  <span class="comment">//s拷贝到s2 </span></span><br></pre></td></tr></table></figure><h2 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h2><p>在 Go 语言中,slice 的底层实现是基于数组的。每个 slice 都包含了三个重要的字段:</p><ol><li><strong>pointer</strong>: 指向底层数组的指针。</li><li><strong>len</strong>: slice 的长度。</li><li><strong>cap</strong>: slice 的容量。</li></ol><p>具体来说,slice 的底层结构可以表示为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    pointer <span class="keyword">uintptr</span></span><br><span class="line">    <span class="built_in">len</span>     <span class="keyword">int</span></span><br><span class="line">    <span class="built_in">cap</span>     <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们来详细了解一下 slice 的底层结构:</p><ol><li><p><strong>pointer</strong>: 这个指针指向了底层数组的第一个元素。通过这个指针,slice 可以访问和修改底层数组的元素。</p></li><li><p><strong>len</strong>: 表示 slice 当前包含的元素个数。len 不能超过 cap。</p></li><li><p><strong>cap</strong>: 表示 slice 底层数组的容量。当 slice 需要存储更多元素时,可以通过扩展容量来实现。</p></li></ol><p>当你创建一个 slice 时,比如 <code>s := []int&#123;1, 2, 3&#125;</code>, Go 会在内存中分配一个底层数组,然后创建一个 slice 结构,其 pointer 指向这个数组,len 和 cap 都为 3。</p><p>当你对 slice 进行操作时,比如 <code>s = s[1:2]</code>, Go 会创建一个新的 slice 结构,但 pointer 仍然指向原来的底层数组。这样做可以避免内存拷贝,提高性能。</p><p>需要注意的是,当 slice 的容量不足时,Go 会自动扩容。扩容时,Go 会分配一个新的较大的底层数组,并将原有的元素拷贝到新数组中,然后更新 slice 结构的 pointer、len 和 cap 字段。</p><h2 id="从数组中取一个相同大小的slice有成本吗？"><a href="#从数组中取一个相同大小的slice有成本吗？" class="headerlink" title="从数组中取一个相同大小的slice有成本吗？"></a>从数组中取一个相同大小的slice有成本吗？</h2><p>是相对轻量的操作</p><h2 id="slice和数组区别"><a href="#slice和数组区别" class="headerlink" title="slice和数组区别"></a>slice和数组区别</h2><p>作为参数的区别</p><ol><li>当使用数组作为参数和返回值的时候，传进去的是值，在函数内部对数组进行修改并不会影响原数据</li><li>当切片作为参数的时候穿进去的是值，也就是值传递，但是当我在函数里面修改切片的时候，我们发现源数据也会被修改，这是因为我们在切片的底层维护这一个匿名的数组，当我们把切片当成参数的时候，会重现创建一个切片，但是创建的这个切片和我们原来的数据是共享数据源的，所以在函数内被修改，源数据也会被修改</li><li>数组还是切片，在函数中传递的时候如果没有指定为指针传递的话，都是值传递，但是切片在传递的过程中，有着共享底层数组的风险，所以如果在函数内部进行了更改的时候，会修改到源数据，所以我们需要根据不同的需求来处理，如果我们不希望源数据被修改话的我们可以使用copy函数复制切片后再传入，如果希望源数据被修改的话我们应该使用指针传递的方式</li></ol><h2 id="底层结构和特性"><a href="#底层结构和特性" class="headerlink" title="底层结构和特性"></a>底层结构和特性</h2><p>答：Go 的 slice 底层数据结构是由一个 <strong>array 指针</strong>指向底层数组，len 表示切片长度，cap 表示切片容量。slice 的主要实现是扩容。对于 append 向 slice 添加元素时，假如 slice 容量够用，则追加新元素进去，slice.len++，返回原来的 slice。当原容量不够，则 slice 先扩容，扩容之后 slice 得到新的 slice，将元素追加进新的 slice，slice.len++，返回新的 slice。对于切片的扩容规则：当切片比较小时（容量小于 1024），则采用较大的扩容倍速进行扩容（新的扩容会是原来的 2 倍），避免频繁扩容，从而减少内存分配的次数和数据拷贝的代价。当切片较大的时（原来的 slice 的容量大于或者等于 1024），采用较小的扩容倍速（新的扩容将扩大大于或者等于原来 1.25 倍），主要避免空间浪费，网上其实很多总结的是 1.25 倍，那是在不考虑内存对齐的情况下，实际上还要考虑内存对齐，扩容是大于或者等于 1.25 倍。</p><p>（关于刚才问的 slice 为什么传到函数内可能被修改，如果 slice 在函数内没有出现扩容，函数外和函数内 slice 变量指向是同一个数组，则函数内复制的 slice 变量值出现更改，函数外这个 slice 变量值也会被修改。如果 slice 在函数内出现扩容，则函数内变量的值会新生成一个数组（也就是新的 slice，而函数外的 slice 指向的还是原来的 slice，则函数内的修改不会影响函数外的 slice。）</p><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p><code>map</code> 是一种非常常用的数据结构,用于存储键值对。它提供了快速高效的数据访问和查找功能。以下是关于 Go 语言中 <code>map</code> 的一些重要特点和用法:</p><ol><li><p><strong>声明和初始化</strong>:</p><ul><li>使用 <code>make()</code> 函数创建一个 <code>map</code>:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></li><li>使用字面量语法初始化 <code>map</code>:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m := <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>&#123;<span class="string">&quot;apple&quot;</span>: <span class="number">5</span>, <span class="string">&quot;banana&quot;</span>: <span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>访问和修改</strong>:</p><ul><li>通过键访问值:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value := m[<span class="string">&quot;apple&quot;</span>]</span><br></pre></td></tr></table></figure></li><li>添加或修改键值对:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m[<span class="string">&quot;orange&quot;</span>] = <span class="number">7</span></span><br><span class="line">m[<span class="string">&quot;apple&quot;</span>] = <span class="number">6</span></span><br></pre></td></tr></table></figure></li><li>删除键值对:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">delete</span>(m, <span class="string">&quot;banana&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>检查键是否存在</strong>:</p><ul><li>使用”两值返回”的方式检查键是否存在:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value, ok := m[<span class="string">&quot;pear&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="comment">// 键不存在</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>遍历 <code>map</code></strong>:</p><ul><li>使用 <code>for range</code> 循环遍历 <code>map</code>:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> m &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Key: %s, Value: %d\n&quot;</span>, key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>注意遍历顺序是随机的。</li></ul></li><li><p><strong>并发安全性</strong>:</p><ul><li><code>map</code> 本身不是并发安全的。如果需要在并发环境下使用 <code>map</code>,需要使用 <code>sync.Map</code> 或者自行加锁。</li></ul></li><li><p><strong>其他特性</strong>:</p><ul><li><code>map</code> 的键必须是<strong>可比较</strong>的类型,如字符串、整数、布尔值等。</li><li><code>map</code> 的值可以是任意类型,包括自定义类型。</li><li><code>map</code> 的长度可以动态增长,无需事先指定大小。</li></ul></li></ol><h2 id="底层结构-1"><a href="#底层结构-1" class="headerlink" title="底层结构"></a>底层结构</h2><p><a href="https://github.com/golang/go/blob/master/src/runtime/map.go">https://github.com/golang/go/blob/master/src/runtime/map.go</a></p><p>Go 语言中 <code>map</code> 的底层实现是基于哈希表(hash table)的数据结构。具体来说,Go 的 <code>map</code> 是使用拉链法(chaining)来解决哈希冲突的。下面我们来详细了解一下 <code>map</code> 的底层实现:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.</span></span><br><span class="line"><span class="comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span></span><br><span class="line">count     <span class="keyword">int</span> <span class="comment">// # live cells == size of map.  Must be first (used by len() builtin)</span></span><br><span class="line">flags     <span class="keyword">uint8</span></span><br><span class="line">B         <span class="keyword">uint8</span>  <span class="comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span></span><br><span class="line">noverflow <span class="keyword">uint16</span> <span class="comment">// approximate number of overflow buckets; see incrnoverflow for details</span></span><br><span class="line">hash0     <span class="keyword">uint32</span> <span class="comment">// hash seed</span></span><br><span class="line"></span><br><span class="line">buckets    unsafe.Pointer <span class="comment">// array of 2^B Buckets. may be nil if count==0.</span></span><br><span class="line">oldbuckets unsafe.Pointer <span class="comment">// previous bucket array of half the size, non-nil only when growing</span></span><br><span class="line">nevacuate  <span class="keyword">uintptr</span>        <span class="comment">// progress counter for evacuation (buckets less than this have been evacuated)</span></span><br><span class="line"></span><br><span class="line">extra *mapextra <span class="comment">// optional fields</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><strong>bucket 结构</strong>:<ul><li>Go 中的 <code>map</code> 由多个 <code>bucket</code> 组成,每个 <code>bucket</code> 存储 8 个键值对。</li><li>每个 <code>bucket</code> 结构包含以下字段:<ul><li><code>tophash</code>: 8 个键的哈希值的高 8 位。用于快速比较是否命中。</li><li><code>keys</code>: 8 个键。</li><li><code>values</code>: 8 个值。</li></ul></li><li>当某个 <code>bucket</code> 存不下新的键值对时,会创建一个新的 <code>bucket</code> 并链接到原有的 <code>bucket</code> 上,形成链表结构。</li></ul></li><li><strong>哈希函数</strong>:<ul><li>Go 使用 <code>runtime.alg1</code> 作为默认的哈希函数。这是一种快速高效的哈希算法。</li><li>对于字符串类型的键,Go 使用特殊的字符串哈希算法,进一步提高性能。</li></ul></li><li><strong>扩容机制</strong>:<ul><li><strong>初始容量</strong>:<ul><li>当创建一个新的 map 时,如果没有指定初始容量,Go 会默认分配一个小的初始容量,通常是 8。</li><li>如果在创建 map 时指定了初始容量,Go 会根据这个容量分配相应大小的底层数组。</li></ul></li><li><strong>扩容时机</strong>:<ul><li>当 map 中元素的数量超过当前容量的 2/3 时,就会触发扩容操作。</li><li>扩容的目的是为了降低 map 的平均查找时间复杂度,保持 map 的性能。</li></ul></li><li><strong>扩容策略</strong>:<ul><li>map 的扩容操作会创建一个新的底层数组,新数组的容量通常是旧数组容量的 2 倍。</li><li>将旧数组中的元素逐个复制到新数组中。</li><li>更新 map 结构体中的相关字段,使其指向新的底层数组。</li></ul></li><li><strong>装载因子</strong>:<ul><li>装载因子是 map 中元素个数与底层数组容量的比值。</li><li>Go 语言中 map 的默认装载因子是 2/3,即当 map 中元素个数超过底层数组容量的 2/3 时,就会触发扩容。</li><li>较高的装载因子可以减少内存占用,但可能会增加 map 的查找时间。较低的装载因子可以提高查找性能,但会增加内存占用。</li></ul></li><li><strong>key 的重新哈希</strong>:<ul><li>在扩容时,map 会重新计算每个 key 的哈希值,并根据新的容量将元素放到新的位置上。</li><li>这样可以保证 map 中元素的分布更加均匀,降低冲突概率,提高查找性能。</li><li>会尽量减少rehash以提高性能</li></ul></li></ul></li><li><strong>查找操作</strong>:<ul><li>当使用 <code>m[key]</code> 访问 map 中的元素时,会发生以下步骤:</li><li>首先计算 key 的哈希值。</li><li>根据哈希值和当前 map 的容量,确定 key 在底层数组中的位置。</li><li>遍历该位置的冲突链(也称为桶),逐个比较 key 是否相等。</li><li>如果找到匹配的 key,则返回对应的值。如果没找到,则返回 map 值类型的零值。</li></ul></li><li><strong>插入操作</strong>:<ul><li>当使用 <code>m[key] = value</code> 向 map 中插入元素时,会发生以下步骤:</li><li>首先计算 key 的哈希值。</li><li>根据哈希值和当前 map 的容量,确定 key 在底层数组中的位置。</li><li>遍历该位置的冲突链,查找是否已经存在相同的 key。</li><li>如果找到相同的 key,则更新对应的值。</li><li>如果没找到相同的 key,则创建一个新的键值对,添加到冲突链的尾部。</li><li>如果添加后导致装载因子超过 2/3,则触发 map 的扩容操作。</li></ul></li><li><strong>删除操作</strong>:<ul><li>当使用 <code>delete(m, key)</code> 从 map 中删除元素时,会发生以下步骤:</li><li>首先计算 key 的哈希值。</li><li>根据哈希值和当前 map 的容量,确定 key 在底层数组中的位置。</li><li>遍历该位置的冲突链,查找是否存在相同的 key。</li><li>如果找到相同的 key,则将其从冲突链中删除。</li><li>如果冲突链为空,则将该位置的桶标记为空。</li></ul></li></ol><h2 id="map循环是否有序"><a href="#map循环是否有序" class="headerlink" title="map循环是否有序"></a>map循环是否有序</h2><p>map 的底层实现是基于哈希表的,哈希表本身是一种无序的数据结构。当我们使用 <code>for key, value := range myMap</code> 的方式遍历 map 时,Go 会在每次遍历时以随机的顺序返回 map 中的键值对。这种无序性是 map 设计的一个特点,它可以提高 map 的查找性能。</p><ol><li><strong>使用有序数据结构</strong>:<ul><li>如果你需要保持键值对的顺序,可以使用 Go 标准库提供的 <code>slice</code> 或 <code>list</code> 来模拟有序的 map。在这种情况下,你需要自行维护键值对的顺序信息。</li></ul></li><li><strong>手动对 map 的 key 进行排序</strong>:<ul><li>你可以先获取 map 的所有键,然后对它们进行排序(比如使用 <code>sort</code> 包)。接着按照排序后的键的顺序来遍历 map。</li></ul></li><li><strong>第三方的ordered_map</strong></li></ol><h2 id="删除key的内存情况"><a href="#删除key的内存情况" class="headerlink" title="删除key的内存情况"></a>删除key的内存情况</h2><ul><li>如果删除的元素是值类型，如int，float，bool，string以及数组和struct，map的内存不会自动释放</li><li>如果删除的元素是引用类型，如指针，slice，map，chan等，map的内存会自动释放，但释放的内存是子元素应用类型的内存占用</li><li>将map设置为nil后，内存被回收。</li></ul><h2 id="nil-map-和空-map-区别"><a href="#nil-map-和空-map-区别" class="headerlink" title="nil map 和空 map 区别"></a>nil map 和空 map 区别</h2><p><strong>nil map 是未初始化，空map是长度为空</strong></p><p>1）可以对未初始化的map进行取值，但取出来的东西是空：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">fmt.Println(m1[<span class="string">&quot;1&quot;</span>])</span><br></pre></td></tr></table></figure><p>2）不能对未初始化的map进行赋值，这样将会抛出一个异常：</p><p>未初始化的map是nil，它与一个空map基本等价，只是nil的map不允许往里面添加值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">m1[<span class="string">&quot;1&quot;</span>] = <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="built_in">panic</span>: assignment to entry in <span class="literal">nil</span> <span class="keyword">map</span></span><br><span class="line"></span><br><span class="line">因此，<span class="keyword">map</span>是<span class="literal">nil</span>时，取值是不会报错的（取不到而已），但增加值会报错。</span><br><span class="line"></span><br><span class="line">其实，还有一个区别，<span class="built_in">delete</span>一个<span class="literal">nil</span> <span class="keyword">map</span>会<span class="built_in">panic</span>，</span><br><span class="line">但是<span class="built_in">delete</span> 空<span class="keyword">map</span>是一个空操作（并不会<span class="built_in">panic</span>）</span><br><span class="line">（这个区别在最新的Go tips中已经没有了，即：<span class="built_in">delete</span>一个<span class="literal">nil</span> <span class="keyword">map</span>也不会<span class="built_in">panic</span>）</span><br></pre></td></tr></table></figure><p>3）通过fmt打印map时，空map和nil map结果是一样的，都为map[]。所以，这个时候别断定map是空还是nil，而应该通过map == nil来判断。</p><h2 id="哪些类型可以作为map类型的key"><a href="#哪些类型可以作为map类型的key" class="headerlink" title="哪些类型可以作为map类型的key"></a>哪些类型可以作为map类型的key</h2><p>在 Go 语言中,map 的键必须是可比较类型。可比较类型是指支持使用 <code>==</code> 和 <code>!=</code> 运算符进行相等性比较的类型。</p><p>具体来说,Go 标准库中以下类型是可比较类型:</p><ol><li><p><strong>基本类型</strong>:</p><ul><li>布尔型 (<code>bool</code>)</li><li>整型 (<code>int</code>, <code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code>, <code>uintptr</code>)</li><li>浮点型 (<code>float32</code>, <code>float64</code>)</li><li>复数型 (<code>complex64</code>, <code>complex128</code>)</li><li>字符型 (<code>byte</code>, <code>rune</code>)</li><li>字符串型 (<code>string</code>)</li></ul></li><li><p><strong>指针类型</strong>:</p><ul><li>所有指针类型,如 <code>*int</code>、<code>*struct</code>等</li></ul></li><li><p><strong>结构体类型</strong>:</p><ul><li>当结构体的所有字段都是可比较类型时,该结构体类型也是可比较类型。</li></ul></li><li><p><strong>数组类型</strong>:</p><ul><li>当数组的元素类型是可比较类型时,该数组类型也是可比较类型。</li></ul></li><li><p><strong>接口类型</strong>:</p><ul><li>当接口值的动态类型和动态值都是可比较类型时,该接口类型也是可比较类型。</li></ul></li></ol><p>需要注意的是:</p><ul><li>切片(<code>slice</code>)、映射(<code>map</code>)和函数类型都不是可比较类型,因此不能作为 map 的键。</li><li>如果你需要使用这些类型作为 map 的键,可以考虑使用自定义的结构体类型来模拟。比如使用包含切片的结构体作为 map 的键。</li></ul><h2 id="并发访问map"><a href="#并发访问map" class="headerlink" title="并发访问map"></a>并发访问map</h2><ol><li>锁</li><li>sync.Map</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go语法基础</title>
      <link href="/2024/05/10/go%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2024/05/10/go%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>介绍golang的基本语法</p><span id="more"></span><h1 id="变量和类型相关"><a href="#变量和类型相关" class="headerlink" title="变量和类型相关"></a>变量和类型相关</h1><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>声明单个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//全局变量可以使用以下三种</span></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span> <span class="comment">//默认值0</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">100</span> <span class="comment">//自动推导类型 不建议</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//以下方法只能声明函数体内局部变量</span></span><br><span class="line">b := <span class="number">100</span></span><br></pre></td></tr></table></figure><p>声明多个变量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xx, yy <span class="keyword">int</span> = <span class="number">100</span>, <span class="number">200</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">vv <span class="keyword">int</span> = <span class="number">100</span></span><br><span class="line">    jj <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>iota是一个语法特性，每行累计1，并且可以使用公式，从而指定每个常量的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> length <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">BEIJING = <span class="number">0</span></span><br><span class="line">    SHEN = <span class="number">1</span></span><br><span class="line">    GUANGZHOU = <span class="number">2</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//iota按行累加1 第一行默认0</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">BEIJING = <span class="literal">iota</span></span><br><span class="line">    SHEN</span><br><span class="line">    GUANGZHOU</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用公式</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">BEIJING = <span class="number">10</span>*<span class="literal">iota</span></span><br><span class="line">    SHEN  <span class="comment">//10</span></span><br><span class="line">    GUANGZHOU <span class="comment">//20</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用公式</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">a, b = <span class="literal">iota</span>+<span class="number">1</span>, <span class="literal">iota</span>+<span class="number">2</span> <span class="comment">// iota=0 a=1 b=2</span></span><br><span class="line">    c, d  <span class="comment">// iota=1 c=2 d=3</span></span><br><span class="line">    e, f <span class="comment">// iota=2 e=3 f=4</span></span><br><span class="line">    </span><br><span class="line">    g, h = <span class="literal">iota</span>*<span class="number">2</span>, <span class="literal">iota</span>*<span class="number">3</span>  <span class="comment">// iota=3 g=6 h=9</span></span><br><span class="line">    i, k  <span class="comment">// iota = 4 i=8 k=12</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="单引号，双引号，反引号声明类型"><a href="#单引号，双引号，反引号声明类型" class="headerlink" title="单引号，双引号，反引号声明类型"></a>单引号，双引号，反引号声明类型</h2><ul><li>单引号，表示byte类型或rune类型，对应 uint8和int32类型，默认是 rune 类型。byte用来强调数据是raw data，而不是数字；而rune用来表示Unicode的code point。</li><li>双引号，字符串，实际上是字符数组。可以用索引号访问某字节，也可以用len()函数来获取字符串所占的字节长度。</li><li>反引号，表示字符串字面量，但不支持任何转义序列。字面量 raw literal string 的意思是，你定义时写的啥样，它就啥样，你有换行，它就换行。你写转义字符，它也就展示转义字符。相当于python的 <code>r&quot;string&quot;</code></li></ul><h2 id="不同的类型比较"><a href="#不同的类型比较" class="headerlink" title="不同的类型比较"></a>不同的类型比较</h2><p>string，int，float interface 等可以通过 reflect.DeepEqual 和等于号进行比较，像 slice，struct，map 则一般使用 reflect.DeepEqual 来检测是否相等。</p><h2 id="rune-类型"><a href="#rune-类型" class="headerlink" title="rune 类型"></a>rune 类型</h2><p>用来表示 Unicode 码点的别名，它实际上是 <code>int32</code> 类型的别名</p><ul><li><strong>Unicode 支持</strong>: <code>rune</code> 类型可以表示 Unicode 字符集中的所有字符,包括中文、日文、韩文等。</li><li><strong>变长编码</strong>: Go 语言使用 UTF-8 编码,一个 <code>rune</code> 类型的值可以占用 1 到 4 个字节。</li><li><strong>别名类型</strong>: <code>rune</code> 是 <code>int32</code> 类型的别名,但它更能反映其用途,即代表 Unicode 码点。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 rune 类型变量</span></span><br><span class="line"><span class="keyword">var</span> r <span class="keyword">rune</span> = <span class="string">&#x27;你&#x27;</span></span><br><span class="line">fmt.Println(r) <span class="comment">// 输出: 20320</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从字符串中获取 rune 类型的值</span></span><br><span class="line">s := <span class="string">&quot;Hello, 世界&quot;</span></span><br><span class="line"><span class="keyword">for</span> i, c := <span class="keyword">range</span> s &#123;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;index:%d, rune:%c\n&quot;</span>, i, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>复合数据类型,用于将多个不同类型的数据组合在一起</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Address <span class="keyword">struct</span> &#123;</span><br><span class="line">    City  <span class="keyword">string</span></span><br><span class="line">    State <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name    <span class="keyword">string</span></span><br><span class="line">    Age     <span class="keyword">int</span></span><br><span class="line">    Address Address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p := Person&#123;</span><br><span class="line">    Name: <span class="string">&quot;Alice&quot;</span>,</span><br><span class="line">    Age:  <span class="number">30</span>,</span><br><span class="line">    Address: Address&#123;</span><br><span class="line">        City:  <span class="string">&quot;New York&quot;</span>,</span><br><span class="line">        State: <span class="string">&quot;NY&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(p.Address.City, p.Address.State) <span class="comment">// 输出: New York NY</span></span><br></pre></td></tr></table></figure><h3 id="结构体标签"><a href="#结构体标签" class="headerlink" title="结构体标签"></a>结构体标签</h3><p>结构体标签(struct tag)是附加在结构体字段上的元数据信息，通过反射来获取。它们用于在运行时提供关于该字段的额外信息,通常用于实现序列化/反序列化、表单验证等功能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span> &#123;</span><br><span class="line">    Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">    Age  <span class="keyword">int</span>    <span class="string">`json:&quot;age&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><ul><li>分号可加可不加</li><li>分号必须和函数名同一行</li><li>支持多返回值</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a <span class="keyword">string</span>, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    c:=<span class="number">100</span></span><br><span class="line">    <span class="keyword">return</span> c, c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以给返回值定义名称</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a <span class="keyword">string</span>, b <span class="keyword">int</span>)</span> <span class="params">(r1 <span class="keyword">int</span>, r2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    r1 = <span class="number">1000</span></span><br><span class="line">    r2 = <span class="number">2000</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">foo</span><span class="params">(a <span class="keyword">string</span>, b <span class="keyword">int</span>)</span> <span class="params">(r1, r2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    r1 = <span class="number">1000</span></span><br><span class="line">    r2 = <span class="number">2000</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="值传递和指针传递"><a href="#值传递和指针传递" class="headerlink" title="值传递和指针传递"></a>值传递和指针传递</h2><p>Go 的函数参数传递都是值传递。所谓值传递：指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。参数传递还有引用传递，所谓引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数</p><p>因为 Go 里面的 map，slice，chan 是引用类型。变量区分值类型和引用类型。所谓值类型：变量和变量的值存在同一个位置。所谓引用类型：变量和变量的值是不同的位置，变量的值存储的是对值的引用。但并不是 map，slice，chan 的所有的变量在函数内都能被修改，不同数据类型的底层存储结构和实现可能不太一样，情况也就不一样。</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>和普通函数写法差不多</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h2><p><a href="https://go.dev/doc/effective_go#init">https://go.dev/doc/effective_go#init</a></p><p>init函数在变量声明后执行</p><p>执行顺序</p><p>先执行所有package的init，在执行所有package的main</p><ol><li>import</li><li>声明变量</li><li>init函数</li><li>main函数</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>defer语句在其他语句执行后，生命周期结束前执行，类似c++析构函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> fmt.Pringln(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Pringln(<span class="string">&quot;def&quot;</span>)</span><br></pre></td></tr></table></figure><p>底层结构和特性</p><ul><li>每个 defer 语句都对应一个defer 实例，多个实例使用指针连接起来形成一个<strong>单链表</strong>，保存在 gotoutine 数据结构中，每次插入defer 实例，均插入到链表的头部，函数结束再一次从头部取出，从而形成<strong>后进先出</strong>的效果。</li><li>延迟函数的参数是 defer 语句出现的时候就已经确定了的。</li><li>延迟函数执行按照后进先出的顺序执行，即先出现的 defer 最后执行。</li><li>return语句先执行，defer语句后执行</li><li>延迟函数可能操作主函数的返回值。</li><li>申请资源后立即使用 defer 关闭资源是个好习惯。</li></ul><h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 经典 for 循环</span></span><br><span class="line"><span class="keyword">for</span> init; condition; post &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while 循环</span></span><br><span class="line"><span class="keyword">for</span> condition &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无限循环</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="range循环"><a href="#range循环" class="headerlink" title="range循环"></a>range循环</h2><p>用于遍历各种数据结构，需要注意的是在 for a,b := range c 遍历中， a 和 b 在内存中只会存在一份，即之后每次循环时遍历到的数据都是以值覆盖的方式赋给 a 和 b，a，b 的内存地址始终不变。由于有这个特性，for 循环里面如果开协程，不能直接把 a 或者 b 的地址传给协程。解决办法：在每次循环时，创建一个临时变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历数组/切片</span></span><br><span class="line"><span class="keyword">for</span> index, value := <span class="keyword">range</span> array &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历映射</span></span><br><span class="line"><span class="keyword">for</span> key, value := <span class="keyword">range</span> <span class="keyword">map</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历字符串</span></span><br><span class="line"><span class="keyword">for</span> index, runeValue := <span class="keyword">range</span> <span class="string">&quot;字符串&quot;</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带标签的 for 循环</span></span><br><span class="line">OuterLoop:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">2</span>; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> OuterLoop</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带标签的 continue</span></span><br><span class="line">OuterLoop:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">2</span>; j++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">1</span> &amp;&amp; j == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span> OuterLoop</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 循环体</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="if语句和switch语句"><a href="#if语句和switch语句" class="headerlink" title="if语句和switch语句"></a>if语句和switch语句</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition1 &#123;</span><br><span class="line">    <span class="comment">// 满足 condition1 时执行的代码块</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> condition2 &#123;</span><br><span class="line">    <span class="comment">// 不满足 condition1 但满足 condition2 时执行的代码块</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 以上条件都不满足时执行的代码块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> initStatement; condition &#123;</span><br><span class="line">    <span class="comment">// 满足条件时执行的代码块</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不需要手动加break语句</span></span><br><span class="line"><span class="keyword">switch</span> value := x.(<span class="keyword">type</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">int</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is int,&quot;</span>, value)</span><br><span class="line"><span class="keyword">case</span> <span class="keyword">string</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;x is string,&quot;</span>, value)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">    fmt.Println(<span class="string">&quot;type is unknown&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h1><h2 id="导入方式"><a href="#导入方式" class="headerlink" title="导入方式"></a>导入方式</h2><p>如果import了某个包，但是没有使用包里的函数，就会报错。在包名前加<code>_</code>即可。结合前面的init函数，可以在系统启动时初始化数据库等资源。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>匿名和别名导入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> _<span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> fmt <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="keyword">import</span> . <span class="string">&quot;fmt&quot;</span> <span class="comment">//导入全部方法 不再需要模块名调</span></span><br></pre></td></tr></table></figure><h2 id="GOPATH工作模式"><a href="#GOPATH工作模式" class="headerlink" title="GOPATH工作模式"></a>GOPATH工作模式</h2><p>在早期的Go版本中，<code>GOPATH</code>是一个环境变量，用于指定Go语言工作区的根目录。所有的Go代码、依赖库和可执行文件都需要存放在<code>GOPATH</code>下的特定目录结构中。</p><ol><li><p><code>bin</code>目录：该目录用于存放编译后生成的可执行文件。当你使用<code>go install</code>命令编译并安装一个可执行文件时，该文件将被放置在<code>bin</code>目录下。在运行Go程序时，可以直接从<code>bin</code>目录中执行相应的可执行文件。</p></li><li><p><code>pkg</code>目录：该目录用于存放编译后生成的包对象文件（<code>.a</code>文件）。当你使用<code>go install</code>命令编译并安装一个Go包时，该包的对象文件将被放置在<code>pkg</code>目录下。这些对象文件可以被其他程序引用和链接，提供了代码重用和模块化的能力。</p></li><li><p><code>src</code>目录：该目录是存放Go源代码文件的根目录。你的项目的源代码文件应该位于<code>src</code>目录下的适当子目录中。每个子目录通常对应一个包（package），并以包的导入路径命名。例如，如果你的项目的导入路径是<code>github.com/username/project</code>，那么你的源代码文件应该位于<code>src/github.com/username/project</code>目录下。</p></li></ol><p>这种目录结构的设计是为了支持Go语言的包管理和代码组织。通过将源代码、编译后的可执行文件和包对象文件分开存放，可以提高代码的可维护性和重用性。同时，使用这种标准的目录结构，还可以方便地与其他Go项目进行集成和共享代码。</p><p>虽然<code>GOPATH</code>在过去被广泛使用，但它存在一些弊端，导致在Go 1.11 版本之后被弃用。下面是一些<code>GOPATH</code>的弊端：</p><ol><li><p>单一全局工作区：<code>GOPATH</code>将所有的Go项目和依赖库都放在一个全局的工作区中。这导致了项目之间的依赖管理困难，且无法隔离项目之间的环境。</p></li><li><p>依赖冲突：当多个项目依赖同一个库的不同版本时，<code>GOPATH</code>无法提供有效的解决方案。这可能导致版本冲突和构建问题。</p></li><li><p>缺乏版本管理：<code>GOPATH</code>中的依赖库没有明确的版本管理机制。无法方便地切换和管理不同的库版本。</p></li><li><p>缺乏可移植性：使用<code>GOPATH</code>时，Go项目在不同的环境中可能会面临配置和路径问题，导致代码在不同环境中的可移植性较差。</p></li></ol><p>为了解决这些问题，Go 1.11 版本引入了Go Modules，它是一种更现代、灵活的依赖管理系统。Go Modules 可以在任意目录中使用，不再需要依赖全局的<code>GOPATH</code>。它允许每个项目拥有独立的依赖管理，并提供版本控制和语义化版本支持。</p><p>通过使用Go Modules，可以避免<code>GOPATH</code>的弊端，更好地管理和构建Go项目，同时提高可移植性和依赖管理的灵活性。</p><h2 id="Go-Modules工作模式"><a href="#Go-Modules工作模式" class="headerlink" title="Go Modules工作模式"></a>Go Modules工作模式</h2><p><a href="https://go.dev/blog/using-go-modules">https://go.dev/blog/using-go-modules</a></p><p>淘汰了GOPATH</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">go mod help</span><br><span class="line"></span><br><span class="line">go mod init 生成go.mod文件</span><br><span class="line">go mod download 下载go.mod列出的所有依赖</span><br><span class="line">go mod tidy 整理先有依赖</span><br><span class="line">go mod graph 查看现有依赖</span><br><span class="line">go mod edit 编辑go.mod文件</span><br><span class="line">go mod vendor 导出所有依赖到vendor目录</span><br><span class="line">go mod verify 校验依赖是否被篡改</span><br><span class="line">go mod why 查看为什么需要依赖某模块</span><br></pre></td></tr></table></figure><p>需要设置的环境变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GOPRIVATE=&#x27;&#x27;</span><br><span class="line">GONOPROXY=&#x27;&#x27;</span><br><span class="line">GONOSUMDB=&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">go env -w GO111MODULE=on</span><br><span class="line">go env -w GOPROXY=https://mirrors.aliyun.com/goproxy/</span><br></pre></td></tr></table></figure><p>go modules初始化项目</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go init github.com/acld/module_test</span><br><span class="line">go get github.com/aceld/zinx</span><br></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p>在 Go 语言中,指针是一个非常重要的概念。指针可以让我们更好地控制和管理内存,从而编写出更高效和灵活的代码。</p><h2 id="指针的声明和使用"><a href="#指针的声明和使用" class="headerlink" title="指针的声明和使用"></a>指针的声明和使用</h2><p>在 Go 中,我们使用 <code>*</code> 操作符来声明一个指针变量:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p *<span class="keyword">int</span> <span class="comment">// 声明一个指向 int 类型的指针变量</span></span><br></pre></td></tr></table></figure><p>要获取一个变量的地址,可以使用 <code>&amp;</code> 操作符:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x := <span class="number">42</span></span><br><span class="line">p = &amp;x <span class="comment">// p 现在指向 x 变量的地址</span></span><br></pre></td></tr></table></figure><p>通过指针我们可以间接访问和修改变量的值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(*p) <span class="comment">// 输出 42</span></span><br><span class="line">*p = <span class="number">100</span> <span class="comment">// 修改 x 的值为 100</span></span><br></pre></td></tr></table></figure><h2 id="指针的应用场景"><a href="#指针的应用场景" class="headerlink" title="指针的应用场景"></a>指针的应用场景</h2><ol><li><strong>函数参数传递</strong>: 使用指针可以避免复制大量数据,提高性能。</li><li><strong>动态内存分配</strong>: 使用 <code>new()</code> 函数可以动态分配内存,返回一个指向新分配内存的指针。</li><li><strong>数据结构</strong>: 许多复杂的数据结构,如链表、树等都需要使用指针进行实现。</li><li><strong>unsafe 包</strong>: Go 的 <code>unsafe</code> 包提供了一些不安全的操作,可以用于更底层的内存访问和控制。</li></ol><p><strong>指针使用注意事项</strong></p><ol><li>不要保存一个指向局部变量的指针,因为局部变量在函数返回后会被回收。</li><li>不要尝试访问一个空指针,否则会导致程序崩溃。</li><li>合理使用指针可以提高程序的性能,但滥用指针会导致代码难以维护和调试。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeValue</span><span class="params">(p *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *p=<span class="number">10</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span> = <span class="number">1</span></span><br><span class="line">    changeValue(&amp;a) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unsafe包使用"><a href="#unsafe包使用" class="headerlink" title="unsafe包使用"></a>unsafe包使用</h2><p><a href="https://pkg.go.dev/unsafe">https://pkg.go.dev/unsafe</a></p><p>todo</p><h2 id="uintptr和-unsafe-Pointer-的区别"><a href="#uintptr和-unsafe-Pointer-的区别" class="headerlink" title="uintptr和 unsafe.Pointer 的区别"></a>uintptr和 unsafe.Pointer 的区别</h2><p>答：unsafe.Pointer 是通用指针类型，它不能参与计算，任何类型的指针都可以转化成 unsafe.Pointer，unsafe.Pointer 可以转化成任何类型的指针，uintptr 可以转换为 unsafe.Pointer，unsafe.Pointer 可以转换为 uintptr。uintptr 是指针运算的工具，但是它不能持有指针对象（意思就是它跟指针对象不能互相转换），unsafe.Pointer 是指针对象进行运算（也就是 uintptr）的桥梁。</p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="类（封装）"><a href="#类（封装）" class="headerlink" title="类（封装）"></a>类（封装）</h2><p>类 = struct + 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Hero <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Ad <span class="keyword">int</span></span><br><span class="line">    Level</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Hero)</span> <span class="title">GetName</span><span class="params">()</span></span> &#123;</span><br><span class="line">this.Name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Hero, newName <span class="keyword">string</span>)</span> <span class="title">SetName</span><span class="params">()</span></span> &#123;</span><br><span class="line">this.Name = newName</span><br><span class="line">    <span class="keyword">return</span> this</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>权限控制</p><ul><li>首字母大写代表是公共的，可被外界访问</li><li>首字母小写代表是私有的，不能被外界访问</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>golang的继承是用组合实现的伪继承，即子类会拥有一个父类的示例，但不拥有父类里的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    sex <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Human)</span> <span class="title">Eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Human)</span> <span class="title">Walk</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">type</span> SuperMan <span class="keyword">struct</span> &#123;</span><br><span class="line">    Human</span><br><span class="line">    </span><br><span class="line">    level <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SuperMan)</span> <span class="title">Eat</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *SuperMan)</span> <span class="title">Fly</span><span class="params">()</span></span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向下转型</span></span><br><span class="line">s := SuperMan&#123;Human&#123;<span class="string">&quot;li4&quot;</span>,<span class="string">&quot;female&quot;</span>&#125;, <span class="number">88</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><ol><li>实现一个接口，就是实现其所有的方法 。</li><li>golang不允许重载，不同的方法必须用不同的方法名。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">    Area() <span class="keyword">float64</span></span><br><span class="line">    Perimeter() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">    Width, Height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> r.Width * r.Height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r Rectangle)</span> <span class="title">Perimeter</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * (r.Width + r.Height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><p>类型断言是一个将接口值转换为其底层具体类型的操作。它用于从 <code>interface&#123;&#125;</code> 类型中提取出具体的类型信息。</p><p>空接口，就是 interface{}， int、string等都实现的这个类型。<strong>需要传任意类型数据的时候使用</strong></p><p>类型断言的基本语法如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value, ok := x.(T)</span><br></pre></td></tr></table></figure><p>其中:</p><ul><li><code>x</code> 是要进行类型断言的表达式,它的类型必须是 <code>interface&#123;&#125;</code>。</li><li><code>T</code> 是希望获得的具体类型。</li><li><code>value</code> 是类型断言成功后得到的具体值。</li><li><code>ok</code> 是一个布尔值,表示类型断言是否成功。如果成功,<code>ok</code> 为 <code>true</code>；否则为 <code>false</code>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myFunc</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    <span class="comment">//空接口类型断言</span></span><br><span class="line">    value, ok := arg.(<span class="keyword">string</span>)  <span class="comment">//获取value并断言</span></span><br><span class="line">    <span class="comment">//value := arg.(string)  //单独获取value</span></span><br><span class="line">    <span class="keyword">if</span> !ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Type assertion on errors fails on wrapped errors </span></span><br><span class="line"><span class="comment">// 对包装类型建议使用As</span></span><br><span class="line"><span class="keyword">var</span> errs validator.ValidationErrors</span><br><span class="line"><span class="keyword">if</span> !errors.As(err, &amp;errs) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span>&#123;</span><br><span class="line">ReadBook()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Writer <span class="keyword">interface</span>&#123;</span><br><span class="line">WriteBook()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Book <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Book)</span> <span class="title">ReadBook</span><span class="params">()</span></span>  &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *Book)</span> <span class="title">WriteBook</span><span class="params">()</span></span>   &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">  b := &amp;Book&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> r Reader</span><br><span class="line"><span class="keyword">var</span> w Writer</span><br><span class="line">r = b</span><br><span class="line">w = b</span><br><span class="line">val1,boo1 := r.(Reader)</span><br><span class="line">val2,boo2 := r.(Writer)</span><br><span class="line">val3,boo3 := w.(Reader)</span><br><span class="line">val4,boo4 := w.(Writer)</span><br><span class="line">fmt.Println(val1)</span><br><span class="line">fmt.Println(boo1)</span><br><span class="line">fmt.Println(val2)</span><br><span class="line">fmt.Println(boo2)</span><br><span class="line">fmt.Println(val3)</span><br><span class="line">fmt.Println(boo3)</span><br><span class="line">fmt.Println(val4)</span><br><span class="line">fmt.Println(boo4)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//book类同时实现了Reader和Writer接口，断言为两种类型都会成功</span></span><br><span class="line">&amp;&#123;&#125;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&amp;&#123;&#125;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&amp;&#123;&#125;</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&amp;&#123;&#125;</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="反射原理和用法"><a href="#反射原理和用法" class="headerlink" title="反射原理和用法"></a>反射原理和用法</h3><p>允许程序在运行时动态地检查和操作变量、类型和值。</p><ol><li><strong>interface{}类型</strong>: Go 中所有的值都有一个动态类型和一个静态类型。当一个值被赋给一个 <code>interface&#123;&#125;</code> 类型的变量时,这个值的动态类型和静态类型都被保存了下来。</li><li><strong>reflect.Type和reflect.Value</strong>: Go 的反射包 <code>reflect</code> 提供了两个主要的类型: <code>reflect.Type</code> 和 <code>reflect.Value</code>。<code>reflect.Type</code> 表示一个 Go 类型,<code>reflect.Value</code> 表示一个具体的值。</li><li><strong>在interface{}和reflect之间转换</strong>: 我们可以使用 <code>reflect.TypeOf()</code> 和 <code>reflect.ValueOf()</code> 函数在 <code>interface&#123;&#125;</code> 和 <code>reflect.Type</code>/<code>reflect.Value</code> 之间进行转换。这是反射的基础。</li><li><strong>通过反射修改变量</strong>: 有了 <code>reflect.Value</code>，我们可以对变量的值进行读取和修改。但是需要注意,只有可寻址的 <code>reflect.Value</code> 才能被修改。</li><li><strong>反射的局限性</strong>: 虽然反射是一个强大的工具,但它也有一些局限性。比如不支持未导出的字段或方法的访问,以及需要小心处理 <code>interface&#123;&#125;</code> 转换可能引发的 panic。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id <span class="keyword">int</span></span><br><span class="line">Name <span class="keyword">string</span></span><br><span class="line">Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFieldAndFunc</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取type和value</span></span><br><span class="line">typ := reflect.TypeOf(arg)</span><br><span class="line">val := reflect.ValueOf(arg)</span><br><span class="line">fmt.Println(typ)</span><br><span class="line">fmt.Println(val)</span><br><span class="line"><span class="comment">// 根据type获取field</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; typ.NumField(); i++ &#123;</span><br><span class="line">field := typ.Field(i)</span><br><span class="line">value := val.Field(i).Interface()</span><br><span class="line">fmt.Println(field.Name)</span><br><span class="line">fmt.Println(field.Type)</span><br><span class="line">fmt.Println(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据type获取func</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; typ.NumMethod(); i++ &#123;</span><br><span class="line">m := typ.Method(i)</span><br><span class="line">fmt.Println(m.Name)</span><br><span class="line">fmt.Println(m.Type)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123; </span><br><span class="line">GetFieldAndFunc(User&#123;<span class="number">10</span>,<span class="string">&quot;小猪&quot;</span>, <span class="number">18</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="反射解析结构体标签"><a href="#反射解析结构体标签" class="headerlink" title="反射解析结构体标签"></a>反射解析结构体标签</h3><p>结构体标签是field的<strong>键值对</strong>说明，是一种程序元说明，类似java中的注解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Resume <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="keyword">string</span> <span class="string">`info:&quot;name&quot; doc:&quot;我的名字`</span></span><br><span class="line">Sex <span class="keyword">string</span> <span class="string">`info:&quot;sex&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FindTag</span><span class="params">(str <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">t := reflect.TypeOf(str).Elem()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField() ; i++ &#123;</span><br><span class="line">tagInfo := t.Field(i).Tag.Get(<span class="string">&quot;info&quot;</span>)</span><br><span class="line">tagDoc := t.Field(i).Tag.Get(<span class="string">&quot;doc&quot;</span>)</span><br><span class="line">fmt.Println(tagInfo)</span><br><span class="line">fmt.Println(tagDoc)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123; </span><br><span class="line"><span class="comment">// GetFieldAndFunc(User&#123;10,&quot;小猪&quot;, 18&#125;)</span></span><br><span class="line">FindTag(&amp;Resume&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="json中应用"><a href="#json中应用" class="headerlink" title="json中应用"></a>json中应用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Movie <span class="keyword">struct</span> &#123;</span><br><span class="line">Title <span class="keyword">string</span> <span class="string">`json:&quot;title&quot;`</span></span><br><span class="line">Year <span class="keyword">int</span> <span class="string">`json:&quot;year&quot;`</span></span><br><span class="line">Price <span class="keyword">int</span><span class="string">`json:&quot;rmb&quot;`</span></span><br><span class="line">Actors []<span class="keyword">string</span> <span class="string">`json:&quot;actors&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123; </span><br><span class="line"><span class="comment">// GetFieldAndFunc(User&#123;10,&quot;小猪&quot;, 18&#125;)</span></span><br><span class="line"><span class="comment">// FindTag(&amp;Resume&#123;&#125;)</span></span><br><span class="line"></span><br><span class="line">movie := Movie&#123;<span class="string">&quot;喜剧之王&quot;</span>, <span class="number">2000</span>, <span class="number">10</span> , []<span class="keyword">string</span>&#123;<span class="string">&quot;xinye&quot;</span>, <span class="string">&quot;zhangbozhi&quot;</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">jsonStr,err := json.Marshal(movie)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;err: &quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fmt.Printf(&quot;json string: %s&quot;, jsonStr)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// jsonStr = &quot;&#123;&quot;title&quot;:&quot;喜剧之王&quot;,&quot;year&quot;:2000,&quot;rmb&quot;:10,&quot;actors&quot;:[&quot;xinye&quot;,&quot;zhangbozhi&quot;]&#125;&quot;</span></span><br><span class="line">myMovie := Movie&#123;&#125;</span><br><span class="line">err = json.Unmarshal(jsonStr, &amp;myMovie)</span><br><span class="line"><span class="keyword">if</span> err!=<span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;err: &quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(myMovie)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>性能分析</title>
      <link href="/2023/07/12/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/"/>
      <url>/2023/07/12/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>etop和fprof的使用</p><span id="more"></span><h1 id="etop"><a href="#etop" class="headerlink" title="etop"></a>etop</h1><p>交互式的性能分析工具，它可以实时监控Erlang节点的各种系统资源和进程状态，包括CPU、内存、消息队列等方面，同时还可以对进程进行排序和筛选，以快速定位性能瓶颈。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ul><li><p>可执行程序 etop</p></li><li><p>批处理文件 etop.bat<br>内容如下，实际启动一个hidden终端，支持使用参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@ECHO OFF</span><br><span class="line">CALL werl -sname etop -hidden -s etop -s erlang halt -output text %*</span><br></pre></td></tr></table></figure></li></ul><p>属于observer应用程序，文件位置在observer下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\erl-24.3.4.2\lib\observer-2.11.1\priv\bin&gt;etop</span><br><span class="line"></span><br><span class="line">etop -node tiger@durin.</span><br></pre></td></tr></table></figure><p>接口</p><ul><li>start() -&gt; ok</li><li>start(Options) -&gt; ok</li><li>stop() -&gt; stop</li></ul><h2 id="输出信息"><a href="#输出信息" class="headerlink" title="输出信息"></a>输出信息</h2><ul><li>cpu 节点处于活动状态的时间百分比。</li><li>procs 节点上的进程数</li><li>runq 准备运行的进程数</li><li>Memory 单位是KB</li><li>Time 进程被调度的时间</li><li>Reds 进程上执行的reductions 数量。<br>这里没懂Reductions 是什么<br>Reductions = integer() &gt;= 1</li><li>Memory 进程大小，用process_info(Pid,memory)获取</li><li>MsgQ 消息队列长度</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">==========================================================================================</span><br><span class="line"> &#x27;etop@DESKTOP-7LTU1TQ&#x27;                                                    17:22:39</span><br><span class="line"> Load:  cpu         0               Memory:  total       16335    binary         86</span><br><span class="line">        procs      47                        processes    5043    code         5181</span><br><span class="line">        runq        0                        atom          272    ets           381</span><br><span class="line"></span><br><span class="line">Pid            Name or Initial Func    Time    Reds   Memory     MsgQ Current Function</span><br><span class="line">------------------------------------------------------------------------------------------</span><br><span class="line">&lt;0.50.0&gt;       code_server              &#x27;-&#x27;  101901   263936        0 erl_prim_loader:requ</span><br><span class="line">&lt;0.10.0&gt;       erl_prim_loader          &#x27;-&#x27;   58863   196888        0 prim_file:read_file_</span><br><span class="line">&lt;0.44.0&gt;       application_controll     &#x27;-&#x27;    8149   601888        0 gen_server:loop/7   </span><br><span class="line">&lt;0.60.0&gt;       net_kernel               &#x27;-&#x27;    5423    10832        0 gen_server:loop/7   </span><br><span class="line">&lt;0.9.0&gt;        etop_server              &#x27;-&#x27;    2978    13680        0 etop:data_handler/2 </span><br><span class="line">&lt;0.49.0&gt;       kernel_sup               &#x27;-&#x27;    2595    14208        0 gen_server:loop/7   </span><br><span class="line">&lt;0.0.0&gt;        init                     &#x27;-&#x27;    2359    21584        0 init:boot_loop/2    </span><br><span class="line">&lt;0.84.0&gt;       erlang:apply/2           &#x27;-&#x27;     879   230536        0 code_server:call/1  </span><br><span class="line">&lt;0.69.0&gt;       user_drv                 &#x27;-&#x27;     669     8840        0 user_drv:server_loop</span><br><span class="line">&lt;0.42.0&gt;       logger                   &#x27;-&#x27;     641     8840        0 gen_server:loop/7   </span><br><span class="line">==========================================================================================</span><br></pre></td></tr></table></figure><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul><li><p>config(Key,Value) -&gt; Result</p><ul><li><p>lines 显示行数</p></li><li><p>interval 更新间隔（秒）</p></li><li><p>accumulate 显示的是否 累计的execution time</p></li><li><p>sort  根据 runtime | reductions | memory | msg_q 排序</p></li></ul></li></ul><p>打印时可能无法接收键盘输入，使用Ctrl+G挂起再输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">etop -node tiger@durin -setcookie mycookie -lines 15</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1&gt; etop:config(lines,5).</span><br><span class="line">ok</span><br><span class="line">2&gt; Pid            Name or Initial Func    Time    Reds   Memory     MsgQ Current Function</span><br><span class="line">2&gt; ------------------------------------------------------------------------------------------</span><br><span class="line">2&gt; &lt;0.64.0&gt;       user                     &#x27;-&#x27;   39547    42392        0 user:get_chars/8</span><br><span class="line">2&gt; &lt;0.84.0&gt;       etop_txt:init/1          &#x27;-&#x27;    6782   109240        0 etop:update/1</span><br><span class="line">2&gt; &lt;0.101.0&gt;      erlang:apply/2           &#x27;-&#x27;    1278     8672        0 shell:eval_loop/3</span><br><span class="line">2&gt; &lt;0.100.0&gt;      erlang:apply/2           &#x27;-&#x27;     389   231016        0 shell:get_command1/5</span><br><span class="line">2&gt; &lt;0.82.0&gt;       etop_server              &#x27;-&#x27;      17     8784        0 etop:data_handler/2</span><br><span class="line">2&gt; ==========================================================================================</span><br></pre></td></tr></table></figure><h2 id="记录"><a href="#记录" class="headerlink" title="记录"></a>记录</h2><ul><li>dump(File) -&gt; Result<br>将监控信息转储到文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etop:dump(&quot;MyFile&quot;).</span><br></pre></td></tr></table></figure><h1 id="fprof"><a href="#fprof" class="headerlink" title="fprof"></a>fprof</h1><p>fprof 是一个分析工具，可用于了解不同函数消耗的处理时间以及在哪些进程中消耗的处理时间。</p><p>fprof 的处理分为三步：</p><ol><li><p>Tracing</p></li><li><p>Profiling</p><ul><li>profile() -&gt; ok | {error, Reason} | {‘EXIT’, ServerPid, Reason}</li><li>profile(OptionName, OptionValue) -&gt;<pre><code>       ok |       &#123;ok, Tracer&#125; |       &#123;error, Reason&#125; |       &#123;&#39;EXIT&#39;, ServerPid, Reason&#125;</code></pre></li><li>profile(OptionName) -&gt;<pre><code>       ok |       &#123;ok, Tracer&#125; |       &#123;error, Reason&#125; |       &#123;&#39;EXIT&#39;, ServerPid, Reason&#125;</code></pre></li></ul></li><li><p>Analysing</p><ul><li>analyse() -&gt; ok | {error, Reason} | {‘EXIT’, ServerPid, Reason}</li><li>analyse(OptionName, OptionValue) -&gt;<pre><code>       ok | &#123;error, Reason&#125; | &#123;&#39;EXIT&#39;, ServerPid, Reason&#125;</code></pre></li><li>analyse(OptionName) -&gt;<pre><code>       ok | &#123;error, Reason&#125; | &#123;&#39;EXIT&#39;, ServerPid, Reason&#125;</code></pre></li></ul></li></ol><h2 id="分析源代码"><a href="#分析源代码" class="headerlink" title="分析源代码"></a>分析源代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-module(my_module).</span><br><span class="line"></span><br><span class="line">%% API</span><br><span class="line">-export([start/0]).</span><br><span class="line"></span><br><span class="line">start() -&gt;</span><br><span class="line">  fprof:trace(start),</span><br><span class="line">  io:format(&quot;ok&quot;),</span><br><span class="line">  fprof:trace(stop).</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">8&gt; c(my_module).</span><br><span class="line">&#123;ok,my_module&#125;</span><br><span class="line">9&gt; my_module:start().</span><br><span class="line">okok</span><br><span class="line">10&gt; fprof:profile().</span><br><span class="line">Reading trace data...</span><br><span class="line"></span><br><span class="line">End of trace!</span><br><span class="line">ok</span><br><span class="line">11&gt; fprof:analyse().   </span><br><span class="line">Processing data...</span><br><span class="line">Creating output...</span><br><span class="line">%% Analysis results:</span><br><span class="line">&#123;  analysis_options,</span><br><span class="line"> [&#123;callers, true&#125;,</span><br><span class="line">  &#123;sort, acc&#125;,</span><br><span class="line">  &#123;totals, false&#125;,</span><br><span class="line">  &#123;details, true&#125;]&#125;.</span><br><span class="line"></span><br><span class="line">%                                               CNT       ACC       OWN</span><br><span class="line">[&#123; totals,                                       19,    0.132,    0.131&#125;].  %%%</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%                                               CNT       ACC       OWN</span><br><span class="line">[&#123; &quot;&lt;0.78.0&gt;&quot;,                                   19,undefined,    0.131&#125;].   %%</span><br><span class="line"></span><br><span class="line">&#123;[&#123;undefined,                                     0,    0.102,    0.001&#125;,</span><br><span class="line">  &#123;&#123;my_module,start,0&#125;,                           0,    0.022,    0.001&#125;,</span><br><span class="line">  &#123;&#123;fprof,call,1&#125;,                                1,    0.003,    0.002&#125;],</span><br><span class="line"> &#123; &#123;fprof,just_call,2&#125;,                           1,    0.127,    0.004&#125;,     %</span><br><span class="line"> [&#123;&#123;erlang,demonitor,1&#125;,                          1,    0.101,    0.101&#125;,</span><br><span class="line">  &#123;&#123;io,format,1&#125;,                                 1,    0.021,    0.004&#125;,</span><br><span class="line">  &#123;&#123;erlang,monitor,2&#125;,                            1,    0.001,    0.001&#125;,</span><br><span class="line">  &#123;suspend,                                       1,    0.000,    0.000&#125;]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;&#123;fprof,just_call,2&#125;,                           1,    0.101,    0.101&#125;],</span><br><span class="line"> &#123; &#123;erlang,demonitor,1&#125;,                          1,    0.101,    0.101&#125;,     %</span><br><span class="line"> [ ]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;undefined,                                     0,    0.022,    0.000&#125;,</span><br><span class="line">  &#123;&#123;erl_eval,do_apply,6&#125;,                         0,    0.008,    0.001&#125;],</span><br><span class="line"> &#123; &#123;my_module,start,0&#125;,                           0,    0.030,    0.001&#125;,     %</span><br><span class="line"> [&#123;&#123;fprof,just_call,2&#125;,                           0,    0.022,    0.001&#125;,</span><br><span class="line">  &#123;&#123;fprof,trace,1&#125;,                               1,    0.007,    0.001&#125;]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;&#123;fprof,just_call,2&#125;,                           1,    0.021,    0.004&#125;],</span><br><span class="line"> &#123; &#123;io,format,1&#125;,                                 1,    0.021,    0.004&#125;,     %</span><br><span class="line"> [&#123;&#123;io,request,3&#125;,                                1,    0.013,    0.002&#125;,</span><br><span class="line">  &#123;&#123;io,default_output,0&#125;,                         1,    0.003,    0.002&#125;,</span><br><span class="line">  &#123;&#123;erlang,make_ref,0&#125;,                           1,    0.001,    0.001&#125;]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;&#123;io,format,1&#125;,                                 1,    0.013,    0.002&#125;],</span><br><span class="line"> &#123; &#123;io,request,3&#125;,                                1,    0.013,    0.002&#125;,     %</span><br><span class="line"> [&#123;&#123;io,execute_request,3&#125;,                        1,    0.007,    0.004&#125;,</span><br><span class="line">  &#123;&#123;io,io_request,2&#125;,                             1,    0.004,    0.001&#125;]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;undefined,                                     0,    0.008,    0.000&#125;],</span><br><span class="line"> &#123; &#123;erl_eval,do_apply,6&#125;,                         0,    0.008,    0.000&#125;,     %</span><br><span class="line"> [&#123;&#123;my_module,start,0&#125;,                           0,    0.008,    0.001&#125;]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;&#123;io,request,3&#125;,                                1,    0.007,    0.004&#125;],</span><br><span class="line"> &#123; &#123;io,execute_request,3&#125;,                        1,    0.007,    0.004&#125;,     %</span><br><span class="line"> [&#123;&#123;erlang,monitor,2&#125;,                            1,    0.001,    0.001&#125;,</span><br><span class="line">  &#123;&#123;erlang,demonitor,2&#125;,                          1,    0.001,    0.001&#125;,</span><br><span class="line">  &#123;suspend,                                       1,    0.001,    0.000&#125;]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;&#123;my_module,start,0&#125;,                           1,    0.007,    0.001&#125;],</span><br><span class="line"> &#123; &#123;fprof,trace,1&#125;,                               1,    0.007,    0.001&#125;,     %</span><br><span class="line"> [&#123;&#123;fprof,call,1&#125;,                                1,    0.006,    0.002&#125;]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;&#123;fprof,trace,1&#125;,                               1,    0.006,    0.002&#125;],</span><br><span class="line"> &#123; &#123;fprof,call,1&#125;,                                1,    0.006,    0.002&#125;,     %</span><br><span class="line"> [&#123;&#123;fprof,just_call,2&#125;,                           1,    0.003,    0.002&#125;,</span><br><span class="line">  &#123;&#123;erlang,whereis,1&#125;,                            1,    0.001,    0.001&#125;]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;&#123;io,request,3&#125;,                                1,    0.004,    0.001&#125;],</span><br><span class="line"> &#123; &#123;io,io_request,2&#125;,                             1,    0.004,    0.001&#125;,     %</span><br><span class="line"> [&#123;&#123;io,bc_req,3&#125;,                                 1,    0.003,    0.002&#125;]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;&#123;io,format,1&#125;,                                 1,    0.003,    0.002&#125;],</span><br><span class="line"> &#123; &#123;io,default_output,0&#125;,                         1,    0.003,    0.002&#125;,     %</span><br><span class="line"> [&#123;&#123;erlang,group_leader,0&#125;,                       1,    0.001,    0.001&#125;]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;&#123;io,io_request,2&#125;,                             1,    0.003,    0.002&#125;],</span><br><span class="line"> &#123; &#123;io,bc_req,3&#125;,                                 1,    0.003,    0.002&#125;,     %</span><br><span class="line"> [&#123;&#123;net_kernel,dflag_unicode_io,1&#125;,               1,    0.001,    0.001&#125;]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;&#123;io,execute_request,3&#125;,                        1,    0.001,    0.001&#125;,</span><br><span class="line">  &#123;&#123;fprof,just_call,2&#125;,                           1,    0.001,    0.001&#125;],</span><br><span class="line"> &#123; &#123;erlang,monitor,2&#125;,                            2,    0.002,    0.002&#125;,     %</span><br><span class="line"> [ ]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;&#123;io,bc_req,3&#125;,                                 1,    0.001,    0.001&#125;],</span><br><span class="line"> &#123; &#123;net_kernel,dflag_unicode_io,1&#125;,               1,    0.001,    0.001&#125;,     %</span><br><span class="line"> [ ]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;&#123;fprof,call,1&#125;,                                1,    0.001,    0.001&#125;],</span><br><span class="line"> &#123; &#123;erlang,whereis,1&#125;,                            1,    0.001,    0.001&#125;,     %</span><br><span class="line"> [ ]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;&#123;io,format,1&#125;,                                 1,    0.001,    0.001&#125;],</span><br><span class="line"> &#123; &#123;erlang,make_ref,0&#125;,                           1,    0.001,    0.001&#125;,     %</span><br><span class="line"> [ ]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;&#123;io,default_output,0&#125;,                         1,    0.001,    0.001&#125;],</span><br><span class="line"> &#123; &#123;erlang,group_leader,0&#125;,                       1,    0.001,    0.001&#125;,     %</span><br><span class="line"> [ ]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;&#123;io,execute_request,3&#125;,                        1,    0.001,    0.001&#125;],</span><br><span class="line"> &#123; &#123;erlang,demonitor,2&#125;,                          1,    0.001,    0.001&#125;,     %</span><br><span class="line"> [ ]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;&#123;io,execute_request,3&#125;,                        1,    0.001,    0.000&#125;,</span><br><span class="line">  &#123;&#123;fprof,just_call,2&#125;,                           1,    0.000,    0.000&#125;],</span><br><span class="line"> &#123; suspend,                                       2,    0.001,    0.000&#125;,     %</span><br><span class="line"> [ ]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[ ],</span><br><span class="line"> &#123; undefined,                                     0,    0.000,    0.000&#125;,     %</span><br><span class="line"> [&#123;&#123;fprof,just_call,2&#125;,                           0,    0.102,    0.001&#125;,</span><br><span class="line">  &#123;&#123;my_module,start,0&#125;,                           0,    0.022,    0.000&#125;,</span><br><span class="line">  &#123;&#123;erl_eval,do_apply,6&#125;,                         0,    0.008,    0.000&#125;]&#125;.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Done!</span><br><span class="line">ok</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="分析函数"><a href="#分析函数" class="headerlink" title="分析函数"></a>分析函数</h2><ul><li>apply函数 封装了trace(start)和trace(stop)</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">4&gt; c(foo).</span><br><span class="line">foo.erl:25:18: Warning: variable &#x27;FD&#x27; is unused</span><br><span class="line">%   25| create_file_slow(FD, M, M) -&gt;</span><br><span class="line">%     |                  ^</span><br><span class="line"></span><br><span class="line">&#123;ok,foo&#125;</span><br><span class="line">5&gt; fprof:apply(foo, create_file_slow, [junk, 1024]).</span><br><span class="line">ok</span><br><span class="line">6&gt; fprof:profile().</span><br><span class="line">Reading trace data...</span><br><span class="line">..................</span><br><span class="line">End of trace!</span><br><span class="line">ok</span><br><span class="line">7&gt; fprof:analyse().</span><br><span class="line">Processing data...</span><br><span class="line">Creating output...</span><br><span class="line">%% Analysis results:</span><br><span class="line">&#123;  analysis_options,</span><br><span class="line"> [&#123;callers, true&#125;,</span><br><span class="line">  &#123;sort, acc&#125;,</span><br><span class="line">  &#123;totals, false&#125;,</span><br><span class="line">  &#123;details, true&#125;]&#125;.</span><br><span class="line"></span><br><span class="line">%                                               CNT       ACC       OWN</span><br><span class="line">[&#123; totals,                                     11782,   38.914,   22.223&#125;].  %%%</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">%                                               CNT       ACC       OWN</span><br><span class="line">[&#123; &quot;&lt;0.78.0&gt;&quot;,                                 11573,undefined,   21.329&#125;].   %%</span><br><span class="line"></span><br><span class="line">&#123;[&#123;undefined,                                     0,   38.914,    0.002&#125;],</span><br><span class="line"> &#123; &#123;fprof,apply_start_stop,4&#125;,                    0,   38.914,    0.002&#125;,     %</span><br><span class="line"> [&#123;&#123;foo,create_file_slow,2&#125;,                      1,   38.912,    0.007&#125;,</span><br><span class="line">  &#123;suspend,                                       1,    0.000,    0.000&#125;]&#125;.</span><br><span class="line"></span><br><span class="line">&#123;[&#123;&#123;fprof,apply_start_stop,4&#125;,                    1,   38.912,    0.007&#125;],</span><br><span class="line"> &#123; &#123;foo,create_file_slow,2&#125;,                      1,   38.912,    0.007&#125;,     %</span><br><span class="line"> [&#123;&#123;foo,create_file_slow,3&#125;,                      1,   19.592,    0.002&#125;,</span><br><span class="line">  &#123;&#123;file,open,2&#125;,                                 1,   17.512,    0.004&#125;,</span><br><span class="line">  &#123;&#123;lists,map,2&#125;,                                 1,    1.166,    0.445&#125;,</span><br><span class="line">  &#123;&#123;file,close,1&#125;,                                1,    0.544,    0.001&#125;,</span><br><span class="line">  &#123;&#123;lists,seq,2&#125;,                                 1,    0.066,    0.001&#125;,</span><br><span class="line">  &#123;&#123;file,write,2&#125;,                                1,    0.025,    0.001&#125;]&#125;.</span><br><span class="line">  </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">Done!</span><br><span class="line">ok</span><br></pre></td></tr></table></figure><h2 id="运行时分析"><a href="#运行时分析" class="headerlink" title="运行时分析"></a>运行时分析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;ok, Tracer&#125; = fprof:profile(start),</span><br><span class="line">fprof:trace([start, &#123;tracer, Tracer&#125;]),</span><br><span class="line">%% Code to profile</span><br><span class="line">fprof:trace(stop);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ETS</title>
      <link href="/2023/07/11/ETS/"/>
      <url>/2023/07/11/ETS/</url>
      
        <content type="html"><![CDATA[<p>介绍erlang中的ETS。</p><span id="more"></span><h2 id="ETS和DETS"><a href="#ETS和DETS" class="headerlink" title="ETS和DETS"></a>ETS和DETS</h2><p>都提供键值对的存储，ETS存在内存，DETS存在磁盘</p><ul><li><p>创建表 </p><ul><li>ets:new(Name, Options) -&gt; table()</li><li>dets:open_file(Name, Args) -&gt; {ok, Name} | {error, Reason}</li><li>Options参数<ul><li>set | ordered_set | bag | duplicate_bag<ul><li>set 异键无序</li><li>ordered_set 异键有序</li><li>bag 同键，不止一个元组拥有相同的键，但是不能有两个完全相同的元组</li><li>duplicate_bag 副本同键，不止一个元组拥有相同的键，并且可以存在多个相同的元组</li></ul></li><li>private<br>创建一个私有表，只有主管进程才能读取和写入它。</li><li>public<br>创建一个公共表，任何知道此表标识符的进程都能读取和写入它。</li><li>protected<br>创建一个受保护表，任何知道此表标识符的进程都能读取它，但只有主管进程才能写入它。</li><li>named_table<br>如果设置了此选项，Name就可以被用于后续的表操作。</li><li>{keypos, K}<br>用K作为键的位置。通常键的位置是1。基本上唯一需要使用这个选项的场合是保存Erlang记录（它其实是元组的另一种形式），并且记录的第一个元素包含记录名的时候。<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 异键表（set），要求表里所有的键都是唯一的</span></span><br><span class="line">TableId = ets:new(mytable, [set, named_table]).</span><br><span class="line"><span class="comment">% 同键表（bag），允许多个元素拥有相同的键</span></span><br><span class="line">TableId = ets:new(mytable, [bag]).</span><br><span class="line"></span><br><span class="line">dets:open_file(abc, [&#123;type, bag&#125;]).</span><br><span class="line">dets:open_file(mytable, [&#123;file, table_file&#125;]).</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>插入元组 </p><ul><li>insert(Name, Objects) -&gt; ok | {error, Reason}<br>插入或更新</li><li>insert_new(Name, Objects) -&gt; boolean() | {error, Reason}<br>插入，只要Objects有已存在的元素，不更新表，返回false<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ets:insert(TableId, &#123;a,<span class="number">1</span>&#125;).</span><br><span class="line">ets:insert_new(TableId, [&#123;a,<span class="number">1</span>&#125;,&#123;b,<span class="number">2</span>&#125;]).</span><br><span class="line">dets:insert(<span class="string">&quot;MyTable&quot;</span>, &#123;a,<span class="number">1</span>&#125;).</span><br><span class="line">dets:insert_new(<span class="string">&quot;MyTable&quot;</span>, [&#123;a,<span class="number">1</span>&#125;,&#123;b,<span class="number">2</span>&#125;]).</span><br></pre></td></tr></table></figure></li></ul></li><li><p>查找元组 返回列表</p><ul><li>ets:lookup(Table, Key) -&gt; [Object]<br>对于同键表，只会返回只有一个元素的列表</li><li>ets:lookup_element(Table, Key, Pos) -&gt; Elem<br>相当于对lookup出来的元组再使用element函数，返回元组的Pos位置元素</li><li>dets:lookup(Name, Key)<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ets:lookup(TableId, a).</span><br><span class="line">ets:lookup_element(TableId, a, <span class="number">1</span>).</span><br><span class="line"></span><br><span class="line">dets:lookup(<span class="string">&quot;MyTable&quot;</span>, a).</span><br></pre></td></tr></table></figure></li></ul></li><li><p>丢弃表、元组</p><ul><li>ets:delete(Table) -&gt; true</li><li>ets:delete(Table, Key) -&gt; true</li><li>dets:close(Name)</li><li>dets:delete(Name, Key) -&gt; true<br>删除后查找返回空列表<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ets:delete(TableId, a).</span><br><span class="line">ets:delete(TableId).</span><br><span class="line"></span><br><span class="line">dets:close(abc). </span><br><span class="line">dets:delete(abc, b). </span><br></pre></td></tr></table></figure></li></ul></li></ul><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><p>Mod:module_info(exports)会返回Mod模块里所有导出函数的列表。用这个函数找出Erlang系统库里导出的所有函数。制作一个键-值查询表，其中键是一个{Function,Arity}对（Arity表示参数数量），值是一个模块名。把这些数据储存在ETS和DETS表里。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TableId = ets:new(mytable, [bag]).</span><br><span class="line">Objects = erlang:module_info(exports).</span><br><span class="line">ets:insert(TableId, Objects).</span><br><span class="line">ets:lookup(TableId, port_info).</span><br><span class="line"><span class="comment">%</span></span><br><span class="line">TableName = dets:open_file(abc, [&#123;type, bag&#125;]).</span><br><span class="line">dets:insert(TableId, Objects).</span><br><span class="line">dets:lookup(TableId, port_info).</span><br></pre></td></tr></table></figure></li><li><p>制作一个共享的ETS计数表。实现一个名为count:me(Mod,Line)的函数，通过在你的代码里添加count:me(?MODULE, ?LINE)来调用它。每当这个函数被调用时，就给记录自身执行次数的计数器加1。编写一些函数来初始化和读取计数器。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(count)</span>.</span><br><span class="line"><span class="keyword">-author</span><span class="params">(<span class="string">&quot;hz&quot;</span>)</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% API</span></span><br><span class="line"><span class="comment">%%-export([me/2]).</span></span><br><span class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">0</span>, init/<span class="number">1</span>, me/<span class="number">2</span>, get_count/<span class="number">1</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 初始化计数器</span></span><br><span class="line"><span class="function"><span class="title">init</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  ets:new(count, [set, named_table]).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">init</span><span class="params">(MODULE)</span> -&gt;</span></span><br><span class="line">  ets:insert(count, &#123;?MODULE, <span class="number">0</span>&#125;).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">me</span><span class="params">(MODULE, LINE)</span> -&gt;</span></span><br><span class="line">  OldNum = ets:lookup(count, MODULE),</span><br><span class="line">  ets:update_element(count, MODULE, <span class="number">1</span>).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_count</span><span class="params">(MODULE)</span> -&gt;</span></span><br><span class="line">  ets:lookup_element(count, ?MODULE, <span class="number">2</span>).</span><br></pre></td></tr></table></figure></li><li><p>编写一个检测文本抄袭的程序。用一个双遍历（two-pass）算法来实现它。第一次遍历时，把文本打散成40个字符的小块并计算各个块的校验和，然后把校验和与文件名保存在一个ETS表里。第二次遍历时，计算数据里各个40字符块的校验和，并把它们与ETS表里的校验和进行比较。</p></li></ol><h1 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h1><p>所有对 对象 的操作都是原子的和隔离的。</p><h1 id="遍历表"><a href="#遍历表" class="headerlink" title="遍历表"></a>遍历表</h1><ul><li><p><strong>Single-step</strong> traversal one key at at time, using </p><ul><li><a href="https://www.erlang.org/doc/man/ets.html#first-1">first/1</a> 返回第一个键</li><li><a href="https://www.erlang.org/doc/man/ets.html#next-2">next/2</a> 返回紧跟Key1的下一个键</li><li><a href="https://www.erlang.org/doc/man/ets.html#last-1">last/1</a> 返回最后一个键</li><li><a href="https://www.erlang.org/doc/man/ets.html#prev-2">prev/2</a> 对于<code>ordered_set</code>类型，返回前一个键，对于其他表类型和next/2同义<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ets:new(abc, [set, named_table]).</span><br><span class="line"><span class="number">5</span>&gt; ets:first(abc).</span><br><span class="line">a</span><br><span class="line"><span class="number">11</span>&gt; ets:next(abc,a).                  </span><br><span class="line">b</span><br><span class="line"><span class="number">15</span>&gt; ets:prev(abc,b). </span><br><span class="line">c</span><br><span class="line"></span><br><span class="line">ets:new(abc, [ordered_set, named_table]).</span><br><span class="line"><span class="number">16</span>&gt; ets:next(abc,b). </span><br><span class="line">c</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Search with simple <strong>match patterns</strong>, using </p><ul><li><a href="https://www.erlang.org/doc/man/ets.html#match-1">match/1/2/3</a>, <ul><li>match(Continuation) -&gt; {[Match], Continuation} | ‘$end_of_table’</li><li>match(Table, Pattern) -&gt; [Match]</li><li>match(Table, Pattern, Limit) -&gt; {[Match], Continuation} | ‘$end_of_table’</li></ul></li><li><a href="https://www.erlang.org/doc/man/ets.html#match_delete-2">match_delete/2</a> </li><li><a href="https://www.erlang.org/doc/man/ets.html#match_object-1">match_object/1/2/3</a>.</li><li>匹配规则<ul><li>Erlang terms表示匹配<strong>固定值</strong></li><li>‘_’ 匹配任意值</li><li>模式遍历 ‘$N’, where N=0,1,…  在匹配的位置占位<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ets:new(abc, [named_table]). </span><br><span class="line">ets:insert(abc, [&#123;rufsen,dog,<span class="number">7</span>&#125;,&#123;brunte,horse,<span class="number">5</span>&#125;,&#123;ludde,dog,<span class="number">5</span>&#125;]).</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>&gt; ets:match(abc, &#x27;$<span class="number">1</span>&#x27;). <span class="comment">% Matches every object in table</span></span><br><span class="line"><span class="comment">%[[&#123;rufsen,dog,7&#125;],[&#123;ludde,dog,5&#125;],[&#123;brunte,horse,5&#125;]]</span></span><br><span class="line"><span class="number">6</span>&gt; ets:match(abc, &#123;&#x27;_&#x27;,dog,&#x27;$<span class="number">1</span>&#x27;&#125;). </span><br><span class="line">[[<span class="number">7</span>],[<span class="number">5</span>]]</span><br><span class="line"><span class="number">8</span>&gt; ets:match(abc, &#123;&#x27;_&#x27;,cow,&#x27;$<span class="number">1</span>&#x27;&#125;). </span><br><span class="line">[]</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>Search with more powerful <strong>match specifications</strong>, using </p><ul><li><a href="https://www.erlang.org/doc/man/ets.html#select-1">select/1/2/3</a><ul><li>select(Continuation) -&gt; {[Match], Continuation} | ‘$end_of_table’</li><li>select(Table, MatchSpec) -&gt; [Match]</li><li>select(Table, MatchSpec, Limit) -&gt; {[Match], Continuation} | ‘$end_of_table’</li></ul></li><li><a href="https://www.erlang.org/doc/man/ets.html#select_count-2">select_count/2</a> </li><li><a href="https://www.erlang.org/doc/man/ets.html#select_delete-2">select_delete/2</a></li><li><a href="https://www.erlang.org/doc/man/ets.html#select_replace-2">select_replace/2</a>  </li><li><a href="https://www.erlang.org/doc/man/ets.html#select_reverse-1">select_reverse/1/2/3</a>.</li><li>详细匹配规则：<a href="https://www.erlang.org/doc/apps/erts/match_spec.html">https://www.erlang.org/doc/apps/erts/match_spec.html</a><br>匹配规则是包含一个或多个<strong>三元组</strong>的列表，第一个元素是模式，第二个元素是关卡列表，可以为空，第三个元素接收匹配结果，<code>$_</code> 指定结果为整个元组对象，<code>&#39;$$&#39;</code>将所有匹配结果放在一个列表中。<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MatchSpec = [MatchFunction]</span><br><span class="line">MatchFunction = &#123;MatchHead, [Guard], [Result]&#125;</span><br><span class="line">MatchHead = <span class="string">&quot;Pattern as in ets:match&quot;</span></span><br><span class="line">Guard = &#123;<span class="string">&quot;Guardtest name&quot;</span>, ...&#125;</span><br><span class="line">Result = <span class="string">&quot;Term construct&quot;</span></span><br></pre></td></tr></table></figure>案例<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ets:new(abc, [named_table]). </span><br><span class="line">ets:insert(abc, [&#123;rufsen,dog,<span class="number">7</span>&#125;,&#123;brunte,horse,<span class="number">5</span>&#125;,&#123;ludde,dog,<span class="number">5</span>&#125;]).</span><br><span class="line"></span><br><span class="line"><span class="number">10</span>&gt; ets:match(abc,&#123;&#x27;$<span class="number">1</span>&#x27;,&#x27;$<span class="number">2</span>&#x27;,&#x27;$<span class="number">3</span>&#x27;&#125;).</span><br><span class="line">[[rufsen,dog,<span class="number">7</span>],[ludde,dog,<span class="number">5</span>],[brunte,horse,<span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="number">11</span>&gt; ets:select(abc,[&#123;&#123;&#x27;$<span class="number">1</span>&#x27;,&#x27;$<span class="number">2</span>&#x27;,&#x27;$<span class="number">3</span>&#x27;&#125;,[],[&#x27;$$&#x27;]&#125;]).  </span><br><span class="line">[[rufsen,dog,<span class="number">7</span>],[ludde,dog,<span class="number">5</span>],[brunte,horse,<span class="number">5</span>]]</span><br><span class="line"></span><br><span class="line"><span class="number">12</span>&gt; ets:select(abc,[&#123;&#123;&#x27;$<span class="number">1</span>&#x27;,&#x27;$<span class="number">2</span>&#x27;,&#x27;$<span class="number">3</span>&#x27;&#125;,[],[&#x27;$_&#x27;]&#125;]). </span><br><span class="line">[&#123;rufsen,dog,<span class="number">7</span>&#125;,&#123;ludde,dog,<span class="number">5</span>&#125;,&#123;brunte,horse,<span class="number">5</span>&#125;]</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>转换为其他格式</strong> <a href="https://www.erlang.org/doc/man/ets.html#tab2file-2">tab2file/2/3</a> and <a href="https://www.erlang.org/doc/man/ets.html#tab2list-1">tab2list/1</a>.</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ets:tab2file(table, <span class="string">&quot;MyFile&quot;</span>).</span><br><span class="line"></span><br><span class="line"><span class="number">27</span>&gt; ets:tab2list(tt).</span><br><span class="line">[&#123;a,<span class="number">1</span>&#125;,&#123;b,<span class="number">1</span>&#125;,&#123;c,<span class="number">1</span>&#125;]</span><br></pre></td></tr></table></figure></li></ul><h1 id="细节问题"><a href="#细节问题" class="headerlink" title="细节问题"></a>细节问题</h1><p>1.官方文档中提到： In the current implementation, every object insert and look-up operation results in a copy of the object，这是什么意思呢？<br>意思是，在当前erlang的实现版本中，插入一个tuple：会从当前process中的stack和heap拷贝tuple的一副副本到ets table中去，同样查询操作也会导致从表中拷贝一份tuple（或多个tuples）到执行查询的process的stack和heap中去，这种行为适用于erlang所有的数据类型，除了binaries； </p><p>2.ets table是不会被垃圾回收的，只有当下面两种情况它会被销毁：<br>a.调用delete方法；<br>b.创建ets table的process结束； </p><p>3.关于ordered_set类型table，它的内部元素根据Key值按照Erlang Term Order排序，那么Erlang Term Order是什么呢？<br>a.如果比较的两个值不是同一种数据类型，则按照这种规则比较：<strong>number &lt; atom &lt; reference &lt; fun &lt; port &lt; pid &lt; tuple &lt; list &lt; bit string</strong>；<br>b.如果比较的两个值都是List，那么它会逐个比较其中元素；<br>3.如果比较的两个值都是Tuple，那么它首先会比较Tuple Size是否相同（即元素个数），若Size相同则逐个比较其中的元素； </p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mnesia</title>
      <link href="/2023/07/10/mnesia/"/>
      <url>/2023/07/10/mnesia/</url>
      
        <content type="html"><![CDATA[<p>介绍mnesia数据库</p><span id="more"></span><p><a href="https://www.erlang.org/doc/apps/mnesia/users_guide.html">https://www.erlang.org/doc/apps/mnesia/users_guide.html</a></p><p><a href="https://www.erlang.org/doc/man/qlc.html">Erlang – qlc</a></p><p>Mnesia是一种分布式、多模型数据库管理系统，用于Erlang编程语言。它专门为电信和其他高可用性和高可靠性应用程序开发。</p><p>Mnesia是一种混合数据库系统，结合了传统关系型数据库和键值存储的特性。它支持事务、复制、分布和容错，使其非常适合在分布式系统中使用。</p><p>Mnesia的一个关键特性是其自动分布和复制数据到集群中的多个节点，提供高可用性和容错性。它还支持各种数据模型，包括关系型、键值和面向对象。</p><p>Mnesia内置于Erlang编程语言中，在电信、金融和其他需要高可靠性和容错性的行业得到广泛应用。它也被用于一些Web应用程序和其他分布式系统中。</p><h1 id="定义数据库架构（Schema）"><a href="#定义数据库架构（Schema）" class="headerlink" title="定义数据库架构（Schema）"></a>定义数据库架构（Schema）</h1><ul><li>create_schema(Ns :: [node()]) -&gt; result()</li><li>transform_table(Tab :: table(), Fun, NewA :: [Attr], RecName) -&gt;<pre><code>               t_result(ok)</code></pre></li></ul><p>定义数据库<strong>表格</strong>和<strong>索引</strong>等结构。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>&gt; test_mnesia:do_this_once().</span><br><span class="line">=INFO REPORT==== <span class="number">11</span>-Jul-<span class="number">2023</span>::<span class="number">01</span>:<span class="number">49</span>:<span class="number">15.163000</span> ===</span><br><span class="line">    application: mnesia</span><br><span class="line">    exited: stopped</span><br><span class="line">    type: temporary</span><br><span class="line"></span><br><span class="line">stopped</span><br></pre></td></tr></table></figure><h1 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h1><p>每个<strong>表由记录组成</strong>，其中第一个元素是记录名称，表的第二个元素是一个键，用于标识该表中的特定记录。表名和键的组合是一个二元组{Tab，Key}，称为OID，用于唯一标识该记录在数据库中的位置。</p><p>例如，如果一个员工记录被表示为元组{employee,104732,klacke,7,male,98108,{221,015}}，那么这个记录的OID是元组{employee,104732}。</p><h1 id="启动Mnesia"><a href="#启动Mnesia" class="headerlink" title="启动Mnesia"></a>启动Mnesia</h1><p>启动前：</p><ul><li>在所有参与的节点上必须初始化一个空的模式。</li><li>Erlang系统必须启动。</li><li>必须使用函数mnesia:create_schema(NodeList)定义和实现具有磁盘数据库模式的节点。</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">start</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    mnesia:start(),</span><br><span class="line">    mnesia:wait_for_tables([shop,cost,design], <span class="number">20000</span>).</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3&gt; test_mnesia:start().       </span><br><span class="line">ok</span><br></pre></td></tr></table></figure><h1 id="创建和管理表格"><a href="#创建和管理表格" class="headerlink" title="创建和管理表格"></a>创建和管理表格</h1><p>使用Erlang的mnesia:create_table()和mnesia:delete_table()函数来创建和删除表格。可以使用mnesia:transaction()函数来执行事务。</p><h1 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h1><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  SELECT * FROM shop;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">demo</span><span class="params">(select_shop)</span> -&gt;</span></span><br><span class="line">    do(qlc:q([X || X &lt;- mnesia:table(shop)]));</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5&gt; test_mnesia:demo(select_shop)</span><br><span class="line">.</span><br><span class="line">[&#123;shop,potato,2456,1.2&#125;,</span><br><span class="line"> &#123;shop,apple,20,2.3&#125;,</span><br><span class="line"> &#123;shop,orange,100,3.8&#125;,</span><br><span class="line"> &#123;shop,pear,200,3.6&#125;,</span><br><span class="line"> &#123;shop,banana,420,4.5&#125;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% SQL equivalent</span></span><br><span class="line"><span class="comment">%%  SELECT item, quantity FROM shop;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">demo</span><span class="params">(select_some)</span> -&gt;</span></span><br><span class="line">    do(qlc:q([&#123;X#shop.item, X#shop.quantity&#125; || X &lt;- mnesia:table(shop)]));</span><br><span class="line"> </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">6&gt; test_mnesia:demo(select_some).</span><br><span class="line">[&#123;potato,2456&#125;,</span><br><span class="line"> &#123;apple,20&#125;,</span><br><span class="line"> &#123;orange,100&#125;,</span><br><span class="line"> &#123;pear,200&#125;,</span><br><span class="line"> &#123;banana,420&#125;]</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% SQL equivalent</span></span><br><span class="line"><span class="comment">%%   SELECT shop.item FROM shop</span></span><br><span class="line"><span class="comment">%%   WHERE  shop.quantity &lt; 250;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">demo</span><span class="params">(reorder)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7&gt; test_mnesia:demo(reorder)     .</span><br><span class="line">[apple,orange,pear]</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% SQL equivalent</span></span><br><span class="line"><span class="comment">%%   SELECT shop.item</span></span><br><span class="line"><span class="comment">%%   FROM shop, cost </span></span><br><span class="line"><span class="comment">%%   WHERE shop.item = cost.name </span></span><br><span class="line"><span class="comment">%%     AND cost.price &lt; 2</span></span><br><span class="line"><span class="comment">%%     AND shop.quantity &lt; 250</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">demo</span><span class="params">(join)</span> -&gt;</span></span><br><span class="line">    do(qlc:q([X#shop.item || X &lt;- mnesia:table(shop),</span><br><span class="line">     X#shop.quantity &lt; <span class="number">250</span>,</span><br><span class="line">     Y &lt;- mnesia:table(cost),</span><br><span class="line">     X#shop.item =:= Y#cost.name,</span><br><span class="line">     Y#cost.price &lt; <span class="number">2</span></span><br><span class="line">])).</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8&gt; test_mnesia:demo(join).  </span><br><span class="line">[apple]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>套接字编程</title>
      <link href="/2023/07/09/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/07/09/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>介绍erlang中使用套接字的方法</p><span id="more"></span><h1 id="IOList"><a href="#IOList" class="headerlink" title="IOList"></a>IOList</h1><p>在Erlang中，iolist（即输入/输出列表）是一种特殊的数据类型，用于表示一组二进制数据和/或其他iolists，这些数据可以一起被处理或者输出。</p><p>Iolist由0个或多个二进制数据、其他iolist和字符列表组成。Iolist通常用于高效地处理和传输二进制数据，因为它们可以被递归地处理和拼接而无需复制数据。这使得iolist在处理大量数据时可以更加高效地使用内存。</p><p>Iolist可以使用中括号表示法进行构造，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&lt;&lt;&quot;hello&quot;&gt;&gt;, &quot; world&quot;, [&lt;&lt;&quot;!&quot;&gt;&gt;]]</span><br></pre></td></tr></table></figure><p>这个iolist包含三个元素，分别是一个二进制数据<code>&lt;&lt;&quot;hello&quot;&gt;&gt;</code>，一个字符列表<code>&quot; world&quot;</code>，和一个包含一个单独二进制数据<code>&lt;&lt;&quot;!&quot;&gt;&gt;</code>的iolist。注意，iolist可以包含其他iolist，从而允许对数据进行嵌套构造。</p><p>在Erlang中，许多函数都可以接受iolist作为参数。对于需要处理大量二进制数据的函数来说，使用iolist可以带来显著的性能提升。</p><h1 id="gen-tcp"><a href="#gen-tcp" class="headerlink" title="gen_tcp"></a>gen_tcp</h1><p><a href="https://www.erlang.org/doc/man/gen_tcp.html">https://www.erlang.org/doc/man/gen_tcp.html</a></p><p>在Erlang中，TCP编程通常涉及以下步骤：</p><ol><li>创建和绑定TCP套接字</li><li>接受客户端连接</li><li>发送和接收TCP数据</li></ol><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><p>监听套接字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&gt; &#123;ok, ListenSocket&#125; = gen_tcp:listen(8088, [binary,&#123;active,true&#125;,&#123;packet,0&#125;]).</span><br><span class="line">&#123;ok,#Port&lt;0.508&gt;&#125;</span><br><span class="line">2&gt; &#123;ok,Sokcet&#125; = gen_tcp:accept(ListenSocket).</span><br></pre></td></tr></table></figure><ul><li>8088是监听端口</li><li>binary接收的是二进制串，</li><li>{active,true}是主动模式,socket收到消息以{tcp, Socket, Data} | {tcp_closed, Socket} 主动投递给进程。</li><li>{packet,N}，N是包头的长度，以字节为单位，包头会被自动添加和解析，这个参数关系到是否会粘包（事实上socket是没有粘包这种概念的，很多新手因为这个词都会被搞得云里雾里的，TCP本来就是基于字节流而不是消息包的协议，正确的解读应该是应用层协议的解析，这个后面我再讲），N为0时包头长度为0</li><li>返回监听套接字后我们需要调用gen_tcp:accept(ListenSocket)等待接收连接，在没有客户端连接之前，是堵塞的，Socket是不会返回的，shell会卡住。用accept/2的话有一个timeout参数 ，超时没有连接会关闭  </li></ul><h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1&gt; &#123;ok,Socket&#125; = gen_tcp:connect(&#123;127,0,0,1&#125;,8088,[binary,&#123;active,true&#125;,&#123;packet,0&#125;]).</span><br><span class="line">&#123;ok,#Port&lt;0.508&gt;&#125;  </span><br><span class="line">2&gt; gen_tcp:send(Socket, &quot;hello world!&quot;).</span><br><span class="line">ok  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">我们打开服务端的shell，查看下是否收到消息</span><br><span class="line"></span><br><span class="line">3&gt; flush().</span><br><span class="line">Shell got &#123;tcp,#Port&lt;0.519&gt;,&lt;&lt;&quot;hello world!&quot;&gt;&gt;&#125;</span><br><span class="line">ok  </span><br></pre></td></tr></table></figure><p>可以看到服务端已经收到消息(主动模式下socket会将消息投递到进程邮箱)<br>同样的我们服务端也可以用gen_tcp:send与客户端通信 </p><h2 id="改造处理多个请求"><a href="#改造处理多个请求" class="headerlink" title="改造处理多个请求"></a>改造处理多个请求</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">-module(echo2).</span><br><span class="line"></span><br><span class="line">%% API</span><br><span class="line">-export([</span><br><span class="line">    start_server/0</span><br><span class="line">    , start_client/0</span><br><span class="line">]).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-define(TCP_OPTIONS, [binary, &#123;packet, 0&#125;, &#123;active, true&#125;]).</span><br><span class="line">-define(PORT, 8087).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start_server()-&gt;</span><br><span class="line">    &#123;ok, LSocket&#125; = gen_tcp:listen(?PORT, ?TCP_OPTIONS),</span><br><span class="line">    %%创建一个接收器进程 去监听套接字</span><br><span class="line">    spawn(fun() -&gt; acceptor(LSocket) end).</span><br><span class="line"></span><br><span class="line">acceptor(LSocket) -&gt;</span><br><span class="line">    &#123;ok, Socket&#125; = gen_tcp:accept(LSocket),</span><br><span class="line">    %% 当监听到连接请求时，创建一个新的进程去监听新的请求，本进程处理这个socket通信</span><br><span class="line">    spawn(fun() -&gt; accept(LSocket) end),</span><br><span class="line">    handle_socket(Socket).</span><br><span class="line"></span><br><span class="line">%% 进入循环，读取socket信息 处理</span><br><span class="line">%% 在客户端断开连接时退出。</span><br><span class="line">handle_socket(Socket) -&gt;</span><br><span class="line">    receive</span><br><span class="line">        &#123;tcp,Socket,Bin&#125;-&gt;</span><br><span class="line">            io:format(&quot; received binary  = ~p~n&quot;,[Bin]),</span><br><span class="line">            %% do some thing</span><br><span class="line">            handle_socket(Socket);</span><br><span class="line">        &#123;tcp_closed, Socket&#125; -&gt;</span><br><span class="line">            io:format(&quot;close ~n&quot;);</span><br><span class="line">        Msg -&gt;</span><br><span class="line">            io:format(&quot;receive ~p ~n&quot;,[Msg]),</span><br><span class="line">            handle_socket(Socket)</span><br><span class="line">    end.</span><br><span class="line"></span><br><span class="line">start_client()-&gt;</span><br><span class="line">    &#123;ok,Socket&#125; = gen_tcp:connect(&#123;127,0,0,1&#125;,?PORT,?TCP_OPTIONS),</span><br><span class="line">    gen_tcp:send(Socket, &quot;Hello&quot;),</span><br><span class="line">    gen_tcp:send(Socket, &quot;223333&quot;),</span><br><span class="line">    gen_tcp:close(Socket).</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">1&gt; c(echo2).</span><br><span class="line">&#123;ok,echo2&#125;</span><br><span class="line">2&gt; echo2:start_server().</span><br><span class="line">&lt;0.39.0&gt;</span><br><span class="line">3&gt; echo2:start_client().</span><br><span class="line">ok</span><br><span class="line"> received binary  = &lt;&lt;&quot;Hello&quot;&gt;&gt;</span><br><span class="line">4&gt;  received binary  = &lt;&lt;&quot;223333&quot;&gt;&gt;</span><br><span class="line">4&gt; close</span><br><span class="line">4&gt; echo2:start_client().</span><br><span class="line">ok</span><br><span class="line"> received binary  = &lt;&lt;&quot;Hello&quot;&gt;&gt;</span><br><span class="line">5&gt;  received binary  = &lt;&lt;&quot;223333&quot;&gt;&gt;</span><br><span class="line">5&gt; close</span><br></pre></td></tr></table></figure><p>调用start_server()时会堵塞在gen_tcp:accept(LSocket),直到有客户端连接时，服务费返回socket,然后启动一个新进程，该进程职责也是一样的，spawn返回后，接收来自客户端的消息，然后输出，循环这个过程一直到客户端关闭Socket  。</p><p>接收过程是串行的，每次接收到一个请求时才创建一个空闲actor（进程）去监听监听套接字，并发环境时效率低。可以用类似线程池的思想，一开始就创建多个接收器进程，并把它们交给一个监督者进程去管理，或者是采用异步的方式。</p><h2 id="消息模式"><a href="#消息模式" class="headerlink" title="消息模式"></a>消息模式</h2><p>Erlang的socket有3种消息接收模式：active、passive和active once </p><ol><li><p>active（主动消息接收）：<br>非阻塞。当数据到达时系统会socket会向控制进程发送{tcp, Socket, Data}消息。但控制进程无法控制消息流，想象一下如果盲目相信外部所有发送来的数据转化为消息，那么进程的消息队列堆满了一堆数据，严重影响receive的处理；</p></li><li><p>passive（被动消息接收）：<br>阻塞。控制进程必须主动调用recv()来接收消息。<br>可以看到进程邮箱没有收到消息，需要调用gen_tcp:recv获取数据， gen_tcp:recv（Socket,Length）是堵塞的，如果没有收到数据之前是不会返回的，Length代表要获取Socket接收缓冲区数据的大小，基本单位为字节，0代表获取所有 </p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1&gt; &#123;ok, LSocket&#125; = gen_tcp:listen(8086, [&#123;active,false&#125;]).</span><br><span class="line">&#123;ok,#Port&lt;0.508&gt;&#125;</span><br><span class="line">2&gt; &#123;ok, Socket&#125; = gen_tcp:accept(LSocket).</span><br><span class="line">再开一个  </span><br><span class="line">1&gt; &#123;ok,Socket&#125; = gen_tcp:connect(&#123;127,0,0,1&#125;,8086,[&#123;active,false&#125;]).</span><br><span class="line">&#123;ok,#Port&lt;0.508&gt;&#125;</span><br><span class="line">2&gt; gen_tcp:send(Socket,&quot;23333&quot;).  </span><br><span class="line">再看下服务端  </span><br><span class="line">&#123;ok,#Port&lt;0.519&gt;&#125;</span><br><span class="line">3&gt; flush().</span><br><span class="line">ok</span><br><span class="line">4&gt; &#123;ok, Data&#125; = gen_tcp:recv(Socket, 0).</span><br><span class="line">&#123;ok,&quot;23333&quot;&#125;  </span><br></pre></td></tr></table></figure><ol start="3"><li><p>active once（单次主动）<br>在这个模式中，socket是主动的，但是只能接收一条消息。在控制进程发出一条消息之后，他必须明确的调用 inet:setopts（Socket,[{active,once}]） 以便让socket恢复并接收下一条消息。系统在这发生之前会一直阻塞。 使用 {active,once} 选项，用户可以实现高层次的数据流控制(有时叫交通管制)，同时又防止了服务器被过多的消息所淹没。 虽然active once是官方推荐的方式，但是我发现游戏服务器这块大部分都是采用被动模式  </p><p> {ok,Listen} = gen_tcp:listen(Port,[…,{active,once}…]),<br> {ok,Socket} = gen_tcp:accept(Listen), loop(Socket). </p><p>  loop(Socket) -&gt;</p><p>   receive<br> {tcp,Socket,Data} -&gt; … </p><pre><code>     数据处理 ... %%准备好启用下一条消息时     inet:setopts(Socket,[&#123;active,once&#125;]),     loop(Socket);</code></pre><p> {tcp_closed,Socket} -&gt; …<br>  end.</p></li></ol><h1 id="gen-udp"><a href="#gen-udp" class="headerlink" title="gen_udp"></a>gen_udp</h1><p><a href="https://www.erlang.org/doc/man/gen_udp.html">https://www.erlang.org/doc/man/gen_udp.html</a></p><p>在Erlang中，UDP编程通常涉及到两个方面：</p><ol><li>创建和绑定UDP套接字</li><li>发送和接收UDP数据包</li></ol><p>下面是一个简单的例子，演示了如何在Erlang中使用UDP编程：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(udp_server)</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([start/<span class="number">1</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">start</span><span class="params">(Port)</span> -&gt;</span></span><br><span class="line">    &#123;ok, Socket&#125; = gen_udp:open(Port, [&#123;active, true&#125;]),</span><br><span class="line">    io:format(<span class="string">&quot;UDP server started on port ~w~n&quot;</span>, [Port]),</span><br><span class="line">    loop(Socket).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">loop</span><span class="params">(Socket)</span> -&gt;</span></span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">        &#123;udp, Socket, Host, Port, Data&#125; -&gt;</span><br><span class="line">            io:format(<span class="string">&quot;Received ~w bytes of data from ~w:~w~n~w~n&quot;</span>, [size(Data), Host, Port, Data]),</span><br><span class="line">            gen_udp:send(Socket, Host, Port, Data),</span><br><span class="line">            loop(Socket);</span><br><span class="line">        &#123;udp, Socket, _, _, &#123;error, Reason&#125;&#125; -&gt;</span><br><span class="line">            io:format(<span class="string">&quot;Error receiving UDP packet: ~w~n&quot;</span>, [Reason]),</span><br><span class="line">            loop(Socket)</span><br><span class="line">    <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>gen_udp:open/2</code>函数用于创建并绑定UDP套接字，<code>&#123;active, true&#125;</code>选项表示我们希望在收到数据包时立即将其投递到进程邮箱中。然后，我们使用一个无限循环来接收并处理UDP数据包。当收到数据包时，我们使用<code>gen_udp:send/4</code>函数将数据包回送给发送方。如果收到错误的数据包，则打印错误消息并继续循环。</p><p>下面是一个简单的UDP客户端示例，它可以向UDP服务器发送数据包：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(udp_client)</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([send/<span class="number">3</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">send</span><span class="params">(Host, Port, Data)</span> -&gt;</span></span><br><span class="line">    &#123;ok, Socket&#125; = gen_udp:open(<span class="number">0</span>, []),</span><br><span class="line">    gen_udp:send(Socket, Host, Port, Data),</span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">        &#123;udp, Socket, _, _, Response&#125; -&gt;</span><br><span class="line">            io:format(<span class="string">&quot;Received ~w bytes of response: ~w~n&quot;</span>, [size(Response), Response])</span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    gen_udp:close(Socket).</span><br></pre></td></tr></table></figure><p>在这个例子中，我们使用<code>gen_udp:open/2</code>函数创建一个UDP套接字，并使用<code>gen_udp:send/4</code>函数将数据包发送到指定的主机和端口。我们使用<code>receive</code>语句来等待服务器的响应。当收到响应数据包时，我们打印出响应数据的大小和内容。最后，我们使用<code>gen_udp:close/1</code>函数关闭UDP套接字。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提高程序运行效率</title>
      <link href="/2023/07/03/Efficiency/"/>
      <url>/2023/07/03/Efficiency/</url>
      
        <content type="html"><![CDATA[<p>提高效率的技巧</p><span id="more"></span><p><a href="https://www.erlang.org/doc/efficiency_guide/users_guide.html">Erlang – Efficiency Guide</a></p><h1 id="Erlang性能传说"><a href="#Erlang性能传说" class="headerlink" title="Erlang性能传说"></a>Erlang性能传说</h1><ol><li>尾递归比递归快得多</li><li><code>++</code>总是很差</li><li>String很慢</li><li>修复<strong>Dets</strong> 文件很慢</li><li>BEAM是基于堆栈的字节码虚拟机，因此很慢</li><li>不用的变量用<code>_</code>标记</li><li><strong>NIF</strong> 总是比自己写快</li></ol><p>过时的传说</p><ol><li>Funs很慢</li><li>列表推导很慢</li><li><code>--</code>很慢</li></ol><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>与普通递归相比，由于尾递归的调用处于方法的最后，因此方法之前所积累下的各种状态对于递归调用结果已经没有任何意义，因此完全可以把本次方法中留在堆栈中的数据完全清除，把空间让给最后的递归调用。这样的优化便使得递归不会在调用堆栈上产生堆积，意味着即时是“无限”递归也不会让堆栈溢出。这便是尾递归的优势。</p><p>尾递归的本质，其实是将递归方法中的需要的“所有状态”通过方法的参数传入下一次调用中，通过参数传递结果，达到不压栈的目的。</p><h3 id="递归改写为尾递归的方法"><a href="#递归改写为尾递归的方法" class="headerlink" title="递归改写为尾递归的方法"></a>递归改写为尾递归的方法</h3><p>将普通递归函数改写为尾递归函数，需要引入一个额外的累积参数（accumulator），用于保存中间结果并在递归调用中传递。这样，在每次递归调用时，不再产生新的堆栈帧，而是更新累积参数的值，直到达到终止条件。以下是将普通递归函数改写为尾递归函数的一般步骤：</p><ol><li>引入一个额外的累积参数，用于保存中间结果。</li><li>将递归函数的终止条件作为尾递归函数的终止条件，并将累积参数作为返回值返回。</li><li>在递归调用中，更新累积参数的值，并继续递归调用。</li></ol><p>以下是一个示例，将普通递归的阶乘函数改写为尾递归函数：</p><p>普通递归示例（阶乘函数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fact(0) -&gt; 1;</span><br><span class="line">fact(N) -&gt; N * fact(N - 1).</span><br></pre></td></tr></table></figure><p>尾递归示例（阶乘函数）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fact(N) -&gt; fact(N, 1).</span><br><span class="line"></span><br><span class="line">fact(0, Acc) -&gt; Acc;</span><br><span class="line">fact(N, Acc) -&gt; fact(N - 1, N * Acc).</span><br></pre></td></tr></table></figure><p>在尾递归的示例中，<code>fact/2</code> 函数接受两个参数：<code>N</code> 表示要计算阶乘的数，<code>Acc</code> 表示累积的结果。递归调用发生在每次迭代时，通过更新参数 <code>N</code> 和 <code>Acc</code> 来进行下一次迭代，直到达到终止条件 <code>N = 0</code>。最终结果直接返回给调用者，没有进行任何后续计算。</p><p>通过将普通递归改写为尾递归，可以避免堆栈溢出的风险，并允许尾递归函数以迭代的方式执行，从而提高性能和资源利用率。</p><h2 id="字符串处理"><a href="#字符串处理" class="headerlink" title="字符串处理"></a>字符串处理</h2><p>TODO</p><h1 id="常见注意事项"><a href="#常见注意事项" class="headerlink" title="常见注意事项"></a>常见注意事项</h1><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>指定时间后向指定进程发送Msg</p><ul><li>erlang:send_after(Time, Dest, Msg) -&gt; TimerRef</li><li>erlang:start_timer(Time, Dest, Msg) -&gt; TimerRef</li></ul><p>用**<a href="https://www.erlang.org/doc/man/erlang.html#send_after-3">erlang:send_after/3</a>** and **<a href="https://www.erlang.org/doc/man/erlang.html#start_timer-3">erlang:start_timer/3</a>**比timer模块更高效</p><h2 id="意外复制"><a href="#意外复制" class="headerlink" title="意外复制"></a>意外复制</h2><p>分裂新进程时，尽量只传入要使用的数据，传入记录会导致复制整改记录</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">accidental1</span><span class="params">(State)</span> -&gt;</span></span><br><span class="line">    spawn(<span class="keyword">fun</span>() -&gt;</span><br><span class="line">                  io:format(<span class="string">&quot;~p\n&quot;</span>, [State#state.info])</span><br><span class="line">          <span class="keyword">end</span>).</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fixed_accidental1</span><span class="params">(State)</span> -&gt;</span></span><br><span class="line">    Info = State#state.info,</span><br><span class="line">    spawn(<span class="keyword">fun</span>() -&gt;</span><br><span class="line">                  io:format(<span class="string">&quot;~p\n&quot;</span>, [Info])</span><br><span class="line">          <span class="keyword">end</span>).</span><br></pre></td></tr></table></figure><h2 id="list-to-atom-1"><a href="#list-to-atom-1" class="headerlink" title="list_to_atom/1"></a>list_to_atom/1</h2><p>原子不会被垃圾回收器回收，当到达一定数量，erlang系统会被终止，所有不能随意创建原子。</p><p>如果只使用预先定义的原子，就用<code>list_to_existing_atom(String) -&gt; atom()</code>防止ddos攻击。</p><h3 id="length-1"><a href="#length-1" class="headerlink" title="length/1"></a>length/1</h3><p>length要遍历，对大列表尽量少用。</p><p>可以用模式识别避免。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(L) when length(L) &gt;= 3 -&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>can be rewritten to:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo([_,_,_|_]=L) -&gt;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><h3 id="setelement-3"><a href="#setelement-3" class="headerlink" title="setelement/3"></a>setelement/3</h3><p>会复制操作的元组，但编译器会对连续的调用进行优化。</p><ul><li>索引是整数字面量</li><li>索引降序调用</li><li>连续调用</li><li>上一个调用的结果是下一个的参数</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">multiple_setelement</span><span class="params">(T0)</span> -&gt;</span></span><br><span class="line">    T1 = setelement(<span class="number">9</span>, T0, bar),</span><br><span class="line">    T2 = setelement(<span class="number">7</span>, T1, foobar),</span><br><span class="line">    setelement(<span class="number">5</span>, T2, new_value).</span><br></pre></td></tr></table></figure><h2 id="size-1"><a href="#size-1" class="headerlink" title="size/1"></a>size/1</h2><p>用tuple_size/1 and byte_size/1 ，而不是通用的size/1</p><h3 id="split-binary-2"><a href="#split-binary-2" class="headerlink" title="split_binary/2"></a>split_binary/2</h3><p>模式匹配往往比split_binary/2更高效</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;Bin1:Num/binary,Bin2/binary&gt;&gt; = Bin,</span><br><span class="line"></span><br><span class="line">&#123;Bin1,Bin2&#125; = split_binary(Bin, Num)</span><br></pre></td></tr></table></figure><h1 id="Binaries的构造和匹配"><a href="#Binaries的构造和匹配" class="headerlink" title="Binaries的构造和匹配"></a>Binaries的构造和匹配</h1><p>TODO</p><h1 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h1><h2 id="共享键"><a href="#共享键" class="headerlink" title="共享键"></a>共享键</h2><p>两个maps具有<strong>相同</strong>（键的数量和具体值都相同）的键，则它们将共享该键。类似于原子，就和避免创建过多原子一样，避免创建过多的key</p><p>包装一个构造函数可以最大程度共享键并减少内存使用</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">new</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    #&#123;a =&gt; default, b =&gt; default, c =&gt; default&#125;.</span><br></pre></td></tr></table></figure><h2 id="垃圾回收：TODO"><a href="#垃圾回收：TODO" class="headerlink" title="垃圾回收：TODO"></a>垃圾回收：TODO</h2><p>以下是AI的回答</p><p>在Erlang中，为了提高内存利用率和垃圾回收的效率，采用了一种称为“小内存对象”的策略。小内存对象是指大小小于等于64字节的数据结构，例如元组、二进制、列表等等。</p><p>这些小内存对象被存储在连续的内存块中，使得它们可以被高效地分配和回收。此外，Erlang还使用了一种称为“分代垃圾回收”的技术，将内存划分为不同的代，以便更有效地回收内存。</p><p>对于小内存对象，Erlang使用了一种称为“复制式垃圾回收”的算法。这种算法将内存划分为两个部分，分别称为“from”和“to”空间。当内存中的小内存对象被回收时，它们被复制到“to”空间中，而“from”空间则被清空。这种算法的优点是简单高效，但它不能处理大内存对象（即大小大于64字节的对象）。</p><p>因此，对于大内存对象，Erlang使用了一种称为“标记-清除”算法的垃圾回收技术。这种算法的缺点是它可能会导致内存碎片，从而降低内存使用效率。</p><p>需要注意的是，尽管Erlang的小内存对象策略可以提高内存利用率和垃圾回收效率，但它也有一些限制。例如，元组和记录的大小不能超过32个元素，否则它们将不再被视为小内存对象，而是被存储在堆中，这将导致额外的内存开销和性能损失。</p><h2 id="一般原则"><a href="#一般原则" class="headerlink" title="一般原则"></a>一般原则</h2><ul><li>映射组语法往往比maps模块的方法更高效</li><li>避免使用超过32个元素的大映射组</li><li>利用共享键</li><li>一次匹配多个元素</li><li>一次更新多个元素</li><li>避免使用默认值和maps:get(Key, Map, Default)函数</li><li>使用maps:merge/2 合并，避免缺失key</li></ul><h2 id="用于实现字典"><a href="#用于实现字典" class="headerlink" title="用于实现字典"></a>用于实现字典</h2><p>字典的特点</p><ul><li>key在编译器是未知的</li><li>映射组中可能有任意数量元素</li><li>一次查找或更新的元素不超过一个</li></ul><p>通常map是字典最好的底层结构，以下场景是例外</p><ul><li>需要频繁的排序或者从排序列表构造，使用gb_trees</li><li>key都是非零整数，用array实现</li></ul><h2 id="用于实现集合"><a href="#用于实现集合" class="headerlink" title="用于实现集合"></a>用于实现集合</h2><p>sets模块以映射组作为底层结构实现集合</p><p>通常map是集合最好的底层结构，以下场景是例外</p><ul><li>频繁使用交集运算，但不需要单元素操作，使用ordsets模块，底层是红黑树</li><li>频繁使用交集运算，并且需要高效的单元素操作，使用gb_sets模块，底层是AVL树</li><li>表示为整数</li></ul><h1 id="List-Handling"><a href="#List-Handling" class="headerlink" title="List Handling"></a>List Handling</h1><h2 id="创建列表"><a href="#创建列表" class="headerlink" title="创建列表"></a>创建列表</h2><p>列表的创建方式只有 列表头+列表尾 的方式，++和append都会把前面的列表的元素作为列表头，第二个列表作为列表尾来构建，所以尽量<strong>把短列表放前面</strong>。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">append</span><span class="params">([H|T], Tail)</span> -&gt;</span></span><br><span class="line">    [H|append(T, Tail)];</span><br><span class="line"><span class="function"><span class="title">append</span><span class="params">([], Tail)</span> -&gt;</span></span><br><span class="line">    Tail.</span><br></pre></td></tr></table></figure><h2 id="列表推导"><a href="#列表推导" class="headerlink" title="列表推导"></a>列表推导</h2><p>若列表推导的结果不被使用，就不会构建列表，可以理解为遍历了传进去的列表。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[io:put_chars(E) || E &lt;- List],</span><br></pre></td></tr></table></figure><p>=</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x27;lc^<span class="number">0</span>&#x27;([E|Tail], Expr) -&gt;</span><br><span class="line">    Expr(E),</span><br><span class="line">    &#x27;lc^<span class="number">0</span>&#x27;(Tail, Expr);</span><br><span class="line">&#x27;lc^<span class="number">0</span>&#x27;([], _Expr) -&gt; [].</span><br></pre></td></tr></table></figure><h2 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h2><p><a href="https://www.erlang.org/doc/man/lists.html#flatten-1">lists:flatten/1</a>会复制所有嵌套的列表，可以避免的情况：</p><ul><li>发送数据到port</li><li>可以接收嵌套列表作为参数的BIF，例如iolist可以是嵌套列表<br>list_to_binary/1 or iolist_to_binary/1等</li><li>只有一层用 <strong><a href="https://www.erlang.org/doc/man/lists.html#append-1">lists:append/1</a></strong>.</li></ul><h2 id="尾递归-1"><a href="#尾递归-1" class="headerlink" title="尾递归"></a>尾递归</h2><p>要用尾递归</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>supervisor</title>
      <link href="/2023/07/02/supervisor/"/>
      <url>/2023/07/02/supervisor/</url>
      
        <content type="html"><![CDATA[<p>介绍四大行为模式之一的supervisor</p><span id="more"></span><p>supervisor负责启动、停止、监控子进程。</p><h2 id="启动和监控子进程"><a href="#启动和监控子进程" class="headerlink" title="启动和监控子进程"></a>启动和监控子进程</h2><p>主要通过各种<strong>配置</strong>来指定监控的策略。</p><ul><li>start_child(SupRef, ChildSpec) -&gt; startchild_ret()<ul><li>SupRef 监控者的引用，可以是Pid、注册名等</li><li>ChildSpec</li></ul></li><li>start_link(Module, Args) -&gt; startlink_ret()</li><li>start_link(SupName, Module, Args) -&gt; startlink_ret()<ul><li>Pid、注册名等</li><li>Module 通过回调函数的init来查找启动策略</li><li>startlink_ret<ul><li>{ok, pid()} </li><li>ignore </li><li>{error, startlink_err()}</li></ul></li><li>Args 对应Module:init的Args </li></ul></li><li>Module:init(Args) -&gt; Result<ul><li>Result<ul><li>{ok,{SupFlags,[ChildSpec]}}</li><li>ignore</li><li>SupFlags表示监督者配置<br>ChildSpecs是子进程标识列表，子进程标识ChildSpec是特殊的Map，后面有具体的例子</li></ul></li></ul></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(ch_sup)</span>.</span><br><span class="line"><span class="keyword">-behaviour</span><span class="params">(supervisor)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>])</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    supervisor:start_link(ch_sup, []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">init</span><span class="params">(_Args)</span> -&gt;</span></span><br><span class="line">    SupFlags = #&#123;strategy =&gt; one_for_one, intensity =&gt; <span class="number">1</span>, period =&gt; <span class="number">5</span>&#125;,</span><br><span class="line">    ChildSpecs = [#&#123;id =&gt; ch3,</span><br><span class="line">                    start =&gt; &#123;ch3, start_link, []&#125;,</span><br><span class="line">                    restart =&gt; permanent,</span><br><span class="line">                    shutdown =&gt; brutal_kill,</span><br><span class="line">                    type =&gt; worker,</span><br><span class="line">                    modules =&gt; [ch3]&#125;],</span><br><span class="line">    &#123;ok, &#123;SupFlags, ChildSpecs&#125;&#125;.</span><br></pre></td></tr></table></figure><h3 id="SupFlags"><a href="#SupFlags" class="headerlink" title="SupFlags"></a>SupFlags</h3><ul><li>strategy 重启策略 <ul><li>one_for_all 若一个子进程终止，终止所有子进程并重启所有子进程</li><li>one_for_one <strong>默认</strong>策略，若一个子进程终止，只有该进程会重启</li><li>rest_for_one 若一个子进程终止，终止该进程以后启动的所有子进程（ChildSpecs中指定的顺序）并重启所有终止的子进程</li><li>simple_one_for_one 简化的one_for_one 策略，监督者不启动子进程，而是在运行中使用<code>supervisor:start_child(Sup, List)</code>函数添加</li></ul></li><li>intensity（默认1）和period（默认5） 重启强度<br>监督者在period内重启了intensity次子进程，监督者和子进程都会被终止</li><li>auto_shutdown 当重要的子进程（significant children）关闭时关闭自身 <ul><li>never 默认配置</li><li>any_significant</li><li>all_significant</li></ul></li></ul><h3 id="ChildSpecs"><a href="#ChildSpecs" class="headerlink" title="ChildSpecs"></a>ChildSpecs</h3><ul><li>id 必须配置，用于监督者<strong>内部</strong>标识子进程，常用模块名</li><li>start 必须配置，子进程的启动方法，例：<code>start =&gt; &#123;&#39;AModule&#39;, start_link, []&#125;</code></li><li>restart 何时重启 <ul><li>permanent 总是重启（包括正常关闭）</li><li>transient 非正常终止时重启</li><li>temporary 永不重启</li></ul></li><li>significant 布尔类型，标识重要进程</li><li>shutdown 如何终结这个进程<ul><li>brutal_kill 无条件使用<code>exit(Child, kill)</code>终止</li><li>timeout 通知子进程让其自己关闭，等待接收退出信号，超时没收到信号无条件使用<code>exit(Child, kill)</code>终止</li><li>若子进程是另一个监督者，必须设置为<strong>infinity</strong>来提供足够的关闭时间</li></ul></li><li>type <ul><li>worker</li><li>supervisor</li></ul></li><li>modules</li></ul><p>多个子进程的配置</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></span><br><span class="line">  gen_event:swap_handler(alarm_handler, &#123;alarm_handler, swap&#125;, &#123;my_alarm_handler, xyz&#125;),</span><br><span class="line">  &#123;ok, &#123;&#123;one_for_one, <span class="number">3</span>, <span class="number">10</span>&#125;, <span class="comment">% RestartStrategy MaxRestarts Time</span></span><br><span class="line">    [</span><br><span class="line">      &#123;tag1, <span class="comment">%% worker1</span></span><br><span class="line">        &#123;area_server, start_link, []&#125;,</span><br><span class="line">        permanent,</span><br><span class="line">        <span class="number">10000</span>,</span><br><span class="line">        worker,</span><br><span class="line">        [area_server]&#125;,</span><br><span class="line">      &#123;tag2, <span class="comment">%% worker2</span></span><br><span class="line">        &#123;prime_server, start_link, []&#125;,</span><br><span class="line">        permanent,</span><br><span class="line">        <span class="number">10000</span>,</span><br><span class="line">        worker,</span><br><span class="line">        [prime_server]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;&#125;.</span><br></pre></td></tr></table></figure><p>worker启动格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;Tag, &#123;Mod, Func, ArgList&#125;,</span><br><span class="line">  Restart,</span><br><span class="line">  Shutdown,</span><br><span class="line">  Type,</span><br><span class="line">  [Mod1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="停止子进程"><a href="#停止子进程" class="headerlink" title="停止子进程"></a>停止子进程</h2><ul><li>terminate_child(SupRef, Id) -&gt; Result<br>id是关联子进程的值，通常是子进程的模块名</li><li>delete_child(SupRef, Id) -&gt; Result</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gen_event</title>
      <link href="/2023/07/01/gen_event/"/>
      <url>/2023/07/01/gen_event/</url>
      
        <content type="html"><![CDATA[<p>介绍四大行为模式之一的gen_event</p><span id="more"></span><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="事件概念"><a href="#事件概念" class="headerlink" title="事件概念"></a>事件概念</h2><p>“事件”指的是程序执行过程中发生的某些特定情况或操作，例如用户点击了某个按钮、程序执行了某个操作、系统状态发生了变化等等。</p><p>在服务器端中，事件指的是服务器程序运行过程中发生的特定情况或操作，例如客户端连接到服务器、收到客户端请求、完成数据库操作、定时任务执行等等。</p><p>服务器端的事件通常是预定义的，通过注册事件监听器或回调函数来响应这些事件。当事件被触发时，服务器程序会自动调用相应的监听器或回调函数进行处理。</p><p>服务器端的事件通常用于实现异步处理、任务调度、定时任务等功能。例如，在Web服务器中，当客户端发起请求时，服务器会触发”收到请求”事件，程序员可以通过注册”请求处理器”监听器来处理这个事件，将请求转发给后端处理或返回相应的结果。</p><h2 id="erlang实现事件处理"><a href="#erlang实现事件处理" class="headerlink" title="erlang实现事件处理"></a>erlang实现事件处理</h2><p>实际上是一个特殊的进程，当接收到特定的事件消息时进行相应的处理。</p><p>事件处理器</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(event_handler)</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% API</span></span><br><span class="line"><span class="keyword">-export</span><span class="params">([make/<span class="number">1</span>, add_handler/<span class="number">2</span>, event/<span class="number">2</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 创建事件处理器Name 初始时不执行任何操作（返回void）</span></span><br><span class="line"><span class="function"><span class="title">make</span><span class="params">(Name)</span> -&gt;</span></span><br><span class="line">  register(Name, spawn(<span class="keyword">fun</span>() -&gt; my_handler(fun no_op/1) <span class="keyword">end</span>)).</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 为事件处理器添加一个处理函数Fun。这样当事件X发生时，事件处理器就会执行Fun(X)。</span></span><br><span class="line"><span class="function"><span class="title">add_handler</span><span class="params">(Name, Fun)</span> -&gt;</span></span><br><span class="line">  Name ! &#123;add, Fun&#125;.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 发送事件X到 名为Name的事件处理器</span></span><br><span class="line"><span class="function"><span class="title">event</span><span class="params">(Name, X)</span> -&gt;</span></span><br><span class="line">  Name ! &#123;event, X&#125;.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 服务逻辑</span></span><br><span class="line"><span class="function"><span class="title">my_handler</span><span class="params">(Fun)</span> -&gt;</span></span><br><span class="line">  <span class="keyword">receive</span></span><br><span class="line">    &#123;add, Fun1&#125; -&gt;</span><br><span class="line">      my_handler(Fun1);</span><br><span class="line">    &#123;event, Any&#125; -&gt;</span><br><span class="line">      (<span class="keyword">catch</span> Fun(Any)),</span><br><span class="line">      my_handler(Fun)</span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">no_op</span><span class="params">(_)</span> -&gt;</span> void.</span><br></pre></td></tr></table></figure><p>惯例，把处理函数Fun写在一个回调模块里，可以隐藏处理函数</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(motor_controller)</span>.</span><br><span class="line"><span class="comment">%% 回调模块</span></span><br><span class="line"><span class="comment">%% API</span></span><br><span class="line"><span class="keyword">-export</span><span class="params">([add_event_handler/<span class="number">0</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">add_event_handler</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  event_handler:add_handler(errors, fun controller/1).</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="function"><span class="title">controller</span><span class="params">(too_hot)</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;Turn off the motor~n&quot;</span>);</span><br><span class="line"><span class="function"><span class="title">controller</span><span class="params">(X)</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;~w ignored event: ~p~n&quot;</span>, [?MODULE, X]).</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">% 添加fun</span><br><span class="line">2&gt; event_handler:make(errors).</span><br><span class="line">true</span><br><span class="line">3&gt; event_handler:add_handler(errors, fun(Arg)-&gt;io:format(&quot;Arg is ~w~n&quot;,[Arg]) end).  </span><br><span class="line">add_handler&#123;add,#Fun&lt;erl_eval.44.65746770&gt;&#125;</span><br><span class="line">4&gt; event_handler:event(errors, 1).</span><br><span class="line">Arg is 1</span><br><span class="line">&#123;event,1&#125;</span><br><span class="line"></span><br><span class="line">% 添加回调模块</span><br><span class="line">6&gt; motor_controller:add_event_handler().</span><br><span class="line">add_handler&#123;add,#Fun&lt;motor_controller.0.12439643&gt;&#125;</span><br><span class="line">7&gt; event_handler:event(errors, cold).    </span><br><span class="line">motor_controller ignored event: cold</span><br><span class="line">&#123;event,cold&#125;</span><br><span class="line">8&gt; event_handler:event(errors, too_hot). </span><br><span class="line">Turn off the motor</span><br><span class="line">&#123;event,too_hot&#125;</span><br></pre></td></tr></table></figure><h1 id="gen-event-behaviour"><a href="#gen-event-behaviour" class="headerlink" title="gen_event behaviour"></a>gen_event behaviour</h1><h2 id="和gen-statem里的事件区别"><a href="#和gen-statem里的事件区别" class="headerlink" title="和gen_statem里的事件区别"></a>和gen_statem里的事件区别</h2><p>在Erlang中，事件（Event）是一个通用的概念，它可以用来描述发生在系统中的任何类型的动作或状态变化。在Erlang中，gen_event和gen_fsm都是基于事件驱动的框架，但它们处理事件的方式有所不同。</p><ol><li>gen_event：gen_event是Erlang中的一个事件处理器，用于处理异步事件。gen_event会在一组已注册的回调函数中寻找匹配的函数来处理事件。gen_event可以处理多个事件流，每个事件流都由一个或多个事件源产生。当事件源产生事件时，gen_event会将事件分派给已注册的回调函数进行处理。</li><li>gen_fsm：gen_fsm是Erlang中的一个有限状态机框架，它基于状态转换来处理事件。gen_fsm定义了一组状态和状态转换函数，每个状态都有一组可接受的事件。当事件发生时，gen_fsm会根据当前状态和事件类型来确定下一个状态，并执行相应的状态转换函数。</li></ol><p>总的来说，gen_event和gen_fsm都是基于事件的框架，但它们处理事件的方式有所不同。gen_event是一个通用的事件处理器，用于处理异步事件，而gen_fsm是一个有限状态机框架，用于处理基于状态转换的事件。</p><h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><ul><li>start() -&gt; Result</li><li>start(EventMgrName | Options) -&gt; Result</li><li>start(EventMgrName, Options) -&gt; Result</li><li>start_link() -&gt; Result</li><li>start_link(EventMgrName | Options) -&gt; Result</li><li>start_link(EventMgrName, Options) -&gt; Result</li><li>start_monitor() -&gt; Result</li><li>start_monitor(EventMgrName | Options) -&gt; Result</li><li>start_monitor(EventMgrName, Options) -&gt; Result</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-spec</span><span class="params">(start_link() -&gt; &#123;ok, pid()&#125; | &#123;error, &#123;already_started, pid()&#125;&#125;)</span>.</span><br><span class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  gen_event:start_link(&#123;local, error_man&#125;).</span><br></pre></td></tr></table></figure><h2 id="添加、删除和替换事件管理器"><a href="#添加、删除和替换事件管理器" class="headerlink" title="添加、删除和替换事件管理器"></a>添加、删除和替换事件管理器</h2><ul><li><p>添加</p><ul><li><p>add_handler(EventMgrRef, Handler, Args) -&gt; Result</p></li><li><p>add_sup_handler(EventMgrRef, Handler, Args) -&gt; Result</p></li><li><p>delete_handler(EventMgrRef, Handler, Args) -&gt; Result</p></li></ul></li><li><p>删除</p><ul><li>delete_handler(EventMgrRef, Handler, Args) -&gt; Result</li></ul></li><li><p>替换</p><ul><li>swap_handler(EventMgrRef, {Handler1,Args1}, {Handler2,Args2}) -&gt; Result<br>* </li></ul></li></ul><h2 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h2><ul><li>call(EventMgrRef, Handler, Request) -&gt; Result</li><li>call(EventMgrRef, Handler, Request, Timeout) -&gt; Result</li><li>Module:handle_call(Request, State) -&gt; Result</li></ul><ul><li>sync_notify(EventMgrRef, Event) -&gt; ok</li><li>Module:handle_event(Event, State) -&gt; Result</li></ul><p>自定义alarm handler</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(my_alarm_handler)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-behaviour</span><span class="params">(gen_event)</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% API</span></span><br><span class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>, add_handler/<span class="number">0</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% gen_event callbacks</span></span><br><span class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>, handle_event/<span class="number">2</span>, handle_call/<span class="number">2</span>, handle_info/<span class="number">2</span>, terminate/<span class="number">2</span>,</span></span><br><span class="line"><span class="params">  code_change/<span class="number">3</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-define</span><span class="params">(SERVER, ?MODULE)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-record</span><span class="params">(my_alarm_handler_state, &#123;&#125;)</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% @doc Creates an event manager</span></span><br><span class="line"><span class="keyword">-spec</span><span class="params">(start_link() -&gt; &#123;ok, pid()&#125; | &#123;error, &#123;already_started, pid()&#125;&#125;)</span>.</span><br><span class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  gen_event:start_link(&#123;local, ?SERVER&#125;).</span><br><span class="line"></span><br><span class="line"><span class="comment">%% @doc Adds an event handler</span></span><br><span class="line"><span class="keyword">-spec</span><span class="params">(add_handler() -&gt; ok | &#123;&#x27;EXIT&#x27;, Reason :: term()&#125; | term())</span>.</span><br><span class="line"><span class="function"><span class="title">add_handler</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  gen_event:add_handler(?SERVER, ?MODULE, []).</span><br><span class="line"></span><br><span class="line"><span class="comment">%%%===================================================================</span></span><br><span class="line"><span class="comment">%%% gen_event callbacks</span></span><br><span class="line"><span class="comment">%%%===================================================================</span></span><br><span class="line"><span class="function"><span class="title">init</span><span class="params">(Args)</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;*** my_alarm_handler init:~p~n&quot;</span>, [Args]),</span><br><span class="line">  &#123;ok, <span class="number">0</span>&#125;.</span><br><span class="line"><span class="function"><span class="title">handle_event</span><span class="params">(&#123;set_alarm, tooHot&#125;, N)</span> -&gt;</span></span><br><span class="line">  error_logger:error_msg(<span class="string">&quot;***Tell the Engineer to turn on the fan~n&quot;</span>),</span><br><span class="line">  &#123;ok, N + <span class="number">1</span>&#125;;</span><br><span class="line"><span class="function"><span class="title">handle_event</span><span class="params">(&#123;clear_alarm, tooHot&#125;, N)</span> -&gt;</span></span><br><span class="line">  error_logger:error_msg(<span class="string">&quot;*** Danger over. turn off the fan~n&quot;</span>),</span><br><span class="line">  &#123;ok, N&#125;;</span><br><span class="line"><span class="function"><span class="title">handle_event</span><span class="params">(Event, N)</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;*** unmatched event:~p~n&quot;</span>, [Event]),</span><br><span class="line">  &#123;ok, N&#125;.</span><br><span class="line"><span class="function"><span class="title">handle_call</span><span class="params">(_Request, N)</span> -&gt;</span></span><br><span class="line">  Reply = N,</span><br><span class="line">  &#123;ok, Reply, N&#125;.</span><br><span class="line"><span class="function"><span class="title">handle_info</span><span class="params">(_Info, N)</span> -&gt;</span></span><br><span class="line">  &#123;ok, N&#125;.</span><br><span class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, _N)</span> -&gt;</span> ok.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, State, _Extra)</span> -&gt;</span></span><br><span class="line">  &#123;ok, State&#125;.</span><br></pre></td></tr></table></figure><p>添加到alarm_handler</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\hz\Desktop\ErlangProject\learn-erlang\otp_example&gt; erl -boot start_sasl -config elog3</span><br><span class="line">=PROGRESS REPORT==== 3-Jul-2023::12:08:13.337000 ===</span><br><span class="line">    supervisor: &#123;local,logger_sup&#125;</span><br><span class="line">    started: [&#123;pid,&lt;0.81.0&gt;&#125;,</span><br><span class="line">              &#123;id,error_logger&#125;,</span><br><span class="line">              &#123;mfargs,&#123;error_logger,start_link,[]&#125;&#125;,</span><br><span class="line">              &#123;restart_type,transient&#125;,</span><br><span class="line">              &#123;significant,false&#125;,</span><br><span class="line">              &#123;shutdown,2000&#125;,</span><br><span class="line">              &#123;child_type,worker&#125;]</span><br><span class="line"></span><br><span class="line">=PROGRESS REPORT==== 3-Jul-2023::12:08:13.368000 ===</span><br><span class="line">    supervisor: &#123;local,sasl_safe_sup&#125;</span><br><span class="line">    started: [&#123;pid,&lt;0.84.0&gt;&#125;,</span><br><span class="line">              &#123;id,alarm_handler&#125;,</span><br><span class="line">              &#123;mfargs,&#123;alarm_handler,start_link,[]&#125;&#125;,</span><br><span class="line">              &#123;restart_type,permanent&#125;,</span><br><span class="line">              &#123;significant,false&#125;,</span><br><span class="line">              &#123;restart_type,permanent&#125;,</span><br><span class="line">              &#123;significant,false&#125;,</span><br><span class="line">              &#123;shutdown,2000&#125;,</span><br><span class="line">              &#123;child_type,worker&#125;]</span><br><span class="line"></span><br><span class="line">=PROGRESS REPORT==== 3-Jul-2023::12:08:13.368000 ===</span><br><span class="line">    application: sasl</span><br><span class="line">    started_at: nonode@nohost</span><br><span class="line"></span><br><span class="line">Eshell V12.3.2.2  (abort with ^G)</span><br><span class="line">1&gt; alarm_handler:set_alarm(tooHot).</span><br><span class="line">ok</span><br><span class="line">2&gt; =INFO REPORT==== 3-Jul-2023::12:22:13.423000 ===</span><br><span class="line">    alarm_handler: &#123;set,tooHot&#125;</span><br><span class="line">2&gt; gen_event:swap_handler(alarm_handler, &#123;alarm_handler, swap&#125;, &#123;my_alarm_handler, xyz&#125;).</span><br><span class="line">*** my_alarm_handler init:&#123;xyz,&#123;alarm_handler,[tooHot]&#125;&#125;</span><br><span class="line">ok</span><br><span class="line">3&gt; alarm_handler:set_alarm(tooHot).</span><br><span class="line">=ERROR REPORT==== 3-Jul-2023::12:22:39.079000 ===</span><br><span class="line">***Tell the Engineer to turn on the fan</span><br><span class="line"></span><br><span class="line">ok</span><br><span class="line">4&gt; alarm_handler:clear_alarm(tooHot). </span><br><span class="line">=ERROR REPORT==== 3-Jul-2023::12:22:44.065000 ===</span><br><span class="line">*** Danger over. turn off the fan</span><br><span class="line"></span><br><span class="line">ok</span><br></pre></td></tr></table></figure><h2 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h2><p>发送事件 </p><ul><li>notify(EventMgrRef, Event) -&gt; ok</li><li>sync_notify(EventMgrRef, Event) -&gt; ok</li><li>send_request(EventMgrRef :: emgr_ref(),<pre><code>Handler :: handler(),Request :: term()) -&gt;   ReqId :: request_id()</code></pre></li><li>send_request(EventMgrRef :: emgr_ref(),<pre><code>Handler :: handler(),Request :: term(),Label :: term(),ReqIdCollection :: request_id_collection()) -&gt;   NewReqIdCollection :: request_id_collection()</code></pre></li><li>wait_response(ReqId, WaitTime) -&gt; Result</li><li>wait_response(ReqIdCollection, WaitTime, Delete) -&gt; Result</li></ul><ul><li>直接调用函数（过时）</li><li>显示调用</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gen_event:notify(error_man, no_reply).</span><br></pre></td></tr></table></figure><p>处理事件 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module:handle_event(Event, State) -&gt; Result</span><br></pre></td></tr></table></figure><ul><li>Event是一个{EventType,Event-Arg}形式的<strong>二元组</strong>，其中EventType是<strong>set_event</strong>或<strong>clear_event</strong>（event是自定义的事件名），而EventArg是一个用户提供的参数。</li><li>返回 {ok, NewState}。</li></ul><p>实质上，事件表示系统状态的改变，事件管理器就是维护<code>&#123;Module, State&#125;</code>二元组列表。</p><p>注：Module is an event handler, and State is the internal state of that event handler.</p><h2 id="处理其他消息"><a href="#处理其他消息" class="headerlink" title="处理其他消息"></a>处理其他消息</h2><ul><li>Module:handle_info(Info, State) -&gt; Result</li></ul><h2 id="停止"><a href="#停止" class="headerlink" title="停止"></a>停止</h2><ul><li>stop(EventMgrRef) -&gt; ok</li><li>stop(EventMgrRef, Reason, Timeout) -&gt; ok</li><li>Module:terminate(Arg, State) -&gt; term()</li></ul><p>停止事件管理器 </p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gen_event:stop(error_man).</span><br></pre></td></tr></table></figure><h1 id="日志和警报"><a href="#日志和警报" class="headerlink" title="日志和警报"></a>日志和警报</h1><p><a href="https://www.erlang.org/doc/man/sasl_app.html">Erlang – sasl</a></p><p>日志和警报是sasl中实现的两个事件处理器。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>sasl的配置</p><ul><li>start_prg = string()</li><li>masters = [atom()]</li><li>client_directory = string()</li><li>static_emulator = true | false</li><li>releases_dir = string()</li></ul><p><code>elog1.config</code></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[&#123;sasl,[</span><br><span class="line">        &#123;sasl_error_logger, false&#125;</span><br><span class="line">        ]</span><br><span class="line">&#125;].</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：Erlang/OTP 21.0中，日志采用新api：<a href="https://www.erlang.org/doc/apps/kernel/logger_chapter.html">Erlang – Logging</a>。erlang程序设计中提到的sasl_error_logger、errlog_type等配置已经过时。</p><p><a href="https://www.erlang.org/doc/man/alarm_handler.html">https://www.erlang.org/doc/man/alarm_handler.html</a>)</p><h2 id="旧日志"><a href="#旧日志" class="headerlink" title="旧日志"></a>旧日志</h2><p><a href="https://www.erlang.org/doc/man/error_logger.html">Erlang – error_logger</a></p><p><strong>已弃用</strong>，由<a href="https://www.erlang.org/doc/apps/kernel/logger_chapter.html">Erlang – Logging</a>代替</p><ul><li>添加，不再默认启动，需要通过以下两个函数添加<ul><li>add_report_handler(Handler) -&gt; any()<br> add_report_handler(Handler, Args) -&gt; Result</li></ul></li><li>删除<ul><li> delete_report_handler(Handler) -&gt; Result</li></ul></li><li>记录错误<ul><li> error_logger:error_msg(String)</li><li> error_logger:error_msg(Format, Data)</li><li> error_logger:error_report(Report)</li><li> 此外还有info和warning两种日志</li></ul></li><li>配置：错误记录器在何处以及如何保存数据； <ul><li> 显示在erlang shell （默认） </li><li> 文本文件 </li><li>滚动日志：新消息进来后会被附加到日志的末尾，如果日志满了，最早的条目就会被删除。<br> 极其有用。你决定日志应当占据多少个文件，以及每个日志文件能有多大，然后系统负责在一个大型循环缓冲区里删除旧日志文件和创建新文件。可以调整日志的大小来保存最近几天的操作记录 </li></ul></li></ul><p>分析日志：使用rb模块 </p><h2 id="新日志"><a href="#新日志" class="headerlink" title="新日志"></a>新日志</h2><p><a href="https://www.erlang.org/doc/apps/kernel/logger_chapter.html">Erlang – Logging</a></p><h2 id="alarm-handler"><a href="#alarm-handler" class="headerlink" title="alarm_handler"></a>alarm_handler</h2><ul><li>clear_alarm(AlarmId) -&gt; void()</li><li>get_alarms() -&gt; [alarm()]<br>返回已添加的警报处理器</li><li>set_alarm(alarm())<br>发送事件set_alarm到所有事件处理器<br>alarm() = {AlarmId, AlarmDescription}<br>AlarmId = term()<br>AlarmDescription = term()</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EUnit</title>
      <link href="/2023/06/27/%E6%B5%8B%E8%AF%95/"/>
      <url>/2023/06/27/%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>简单学习测试框架使用</p><span id="more"></span><p><a href="https://www.erlang.org/doc/apps/eunit/users_guide.html">https://www.erlang.org/doc/apps/eunit/users_guide.html</a><br><a href="https://www.erlang.org/doc/apps/common_test/users_guide.html">https://www.erlang.org/doc/apps/common_test/users_guide.html</a></p><h1 id="Eunit"><a href="#Eunit" class="headerlink" title="Eunit"></a>Eunit</h1><h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><p>简单测试函数</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include_lib</span><span class="params">(<span class="string">&quot;eunit/include/eunit.hrl&quot;</span>)</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">reverse_test</span><span class="params">()</span> -&gt;</span></span><br><span class="line">lists:reverse([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">reverse_nil_test</span><span class="params">()</span> -&gt;</span> </span><br><span class="line">[] = lists:reverse([]).</span><br><span class="line"><span class="function"><span class="title">reverse_one_test</span><span class="params">()</span> -&gt;</span> </span><br><span class="line">[<span class="number">1</span>] = lists:reverse([<span class="number">1</span>]).</span><br><span class="line"><span class="function"><span class="title">reverse_two_test</span><span class="params">()</span> -&gt;</span> </span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>] = lists:reverse([<span class="number">1</span>, <span class="number">2</span>]).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">crash_test</span><span class="params">()</span>-&gt;</span></span><br><span class="line"><span class="number">1</span>/<span class="number">0</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">output_test</span><span class="params">()</span>-&gt;</span></span><br><span class="line">io:format(<span class="string">&quot;this is a wrong test&quot;</span>).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">length_test</span><span class="params">()</span> -&gt;</span> </span><br><span class="line">?assert(length([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) =:= <span class="number">3</span>).</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行Eunit</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eunit:test(module_name).</span><br><span class="line"></span><br><span class="line">module_name:test().</span><br></pre></td></tr></table></figure><p>Eunit的表示方式<br><a href="https://www.erlang.org/doc/apps/eunit/chapter.html#EUnit_test_representation">https://www.erlang.org/doc/apps/eunit/chapter.html#EUnit_test_representation</a></p><p>生成测试函数的函数<br>好处是不用起名</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">basic_test_</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="keyword">fun</span> () -&gt; ?assert(<span class="number">1</span> + <span class="number">1</span> =:= <span class="number">2</span>) <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">simple_test</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    ?assert(<span class="number">1</span> + <span class="number">1</span> =:= <span class="number">2</span>).</span><br></pre></td></tr></table></figure><p>使用Eunit宏可以写出更紧凑的测试</p><ul><li>?_test把里面的东西放到一个fun函数里<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">basic_test_</span><span class="params">()</span> -&gt;</span></span><br><span class="line">     ?_test(?assert(<span class="number">1</span> + <span class="number">1</span> =:= <span class="number">2</span>)).</span><br></pre></td></tr></table></figure></li></ul><p>还有更紧凑的写法是下划线开头的宏，会自动添加?_test的wrapper</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">basic_test_</span><span class="params">()</span> -&gt;</span></span><br><span class="line">     ?_assert(<span class="number">1</span> + <span class="number">1</span> =:= <span class="number">2</span>).</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  -module(fib).</span><br><span class="line">  -export([fib/<span class="number">1</span>]).</span><br><span class="line">  -include_lib(<span class="string">&quot;eunit/include/eunit.hrl&quot;</span>).</span><br><span class="line"></span><br><span class="line">  fib(<span class="number">0</span>) -&gt; <span class="number">1</span>;</span><br><span class="line">  fib(<span class="number">1</span>) -&gt; <span class="number">1</span>;</span><br><span class="line">  fib(N) <span class="keyword">when</span> N &gt; <span class="number">1</span> -&gt; fib(N-<span class="number">1</span>) + fib(N-<span class="number">2</span>).</span><br><span class="line"></span><br><span class="line">  fib_test_() -&gt;</span><br><span class="line">      [?_assert(fib(<span class="number">0</span>) =:= <span class="number">1</span>),</span><br><span class="line">?_assert(fib(<span class="number">1</span>) =:= <span class="number">1</span>),</span><br><span class="line">?_assert(fib(<span class="number">2</span>) =:= <span class="number">2</span>),</span><br><span class="line">?_assert(fib(<span class="number">3</span>) =:= <span class="number">3</span>),</span><br><span class="line">?_assert(fib(<span class="number">4</span>) =:= <span class="number">5</span>),</span><br><span class="line">?_assert(fib(<span class="number">5</span>) =:= <span class="number">8</span>),</span><br><span class="line">?_assertException(error, function_clause, fib(-<span class="number">1</span>)),</span><br><span class="line">?_assert(fib(<span class="number">31</span>) =:= <span class="number">2178309</span>)</span><br><span class="line">      ].</span><br></pre></td></tr></table></figure><h2 id="测试套件"><a href="#测试套件" class="headerlink" title="测试套件"></a>测试套件</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(my_module_test)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-include_lib</span><span class="params">(<span class="string">&quot;eunit/include/eunit.hrl&quot;</span>)</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">my_test_1</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="comment">% 这里写测试用例的代码</span></span><br><span class="line">    ok.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">my_test_2</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="comment">% 这里写测试用例的代码</span></span><br><span class="line">    ok.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">my_test_3</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="comment">% 这里写测试用例的代码</span></span><br><span class="line">    ok.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">suite</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    [ &#123;my_test_1, fun my_test_1/0&#125;,</span><br><span class="line">      &#123;my_test_2, fun my_test_2/0&#125;,</span><br><span class="line">      &#123;my_test_3, fun my_test_3/0&#125; ].</span><br><span class="line"></span><br><span class="line"><span class="keyword">-ifdef</span><span class="params">(TEST)</span>.</span><br><span class="line"><span class="function"><span class="title">main_test_</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    &#123;setup, fun setup/0, fun cleanup/0, fun suite/0&#125;.</span><br><span class="line"><span class="keyword">-endif</span>.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步和异步</title>
      <link href="/2023/06/27/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5/"/>
      <url>/2023/06/27/%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<p>IO概念区分</p><span id="more"></span><p><a href="https://stackoverflow.com/questions/2625493/asynchronous-and-non-blocking-calls-also-between-blocking-and-synchronous">asynchronous and non-blocking calls? also between blocking and synchronous - Stack Overflow</a></p><p><a href="https://www.zhihu.com/question/19732473">怎样理解阻塞非阻塞与同步异步的区别？ - 知乎 (zhihu.com)</a></p><p>同步和异步是表示两个模块之间的关系，阻塞和非阻塞是描述一个模块的状态。</p><p>socket 中的三种IO模型</p><ul><li>同步=阻塞，线程会挂起直到调用的函数执行完成并返回结果</li><li>非阻塞，如果不能快速返回结果，就返回一个错误，需要提供某种方式查询（轮询）是否能够返回。</li><li>异步（异步非阻塞），总是立即返回，需要以某种方式来获取结果。</li></ul><p>阻塞和非阻塞</p><ul><li>阻塞式发送（blocking send）. 发送方进程会被一直阻塞， 直到消息被接受方进程收到。</li><li>非阻塞式发送（nonblocking send）。 发送方进程调用 send() 后， 立即就可以其他操作。</li><li>阻塞式接收（blocking receive） 接收方调用 receive() 后一直阻塞， 直到消息到达可用。</li><li>非阻塞式接受（nonblocking receive） 接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。</li></ul><p>同步通信和异步通信</p><p>同步通信是指通信双方在通信过程中必须按照一定的协议进行通信，必须同时在线并保持同步状态。在同步通信中，发送方必须等待接收方的响应，才能继续发送下一个数据包，而接收方在接收到数据包后必须及时响应，否则发送方会认为通信失败。</p><p>相比之下，异步通信则不存在这种同步状态的要求。在异步通信中，发送方可以在任何时候发送数据包，而接收方可以在任何时候接收数据包，也不需要立即响应。异步通信可以提高通信的效率和灵活性，但也可能导致数据的丢失或者乱序。</p><p>总的来说，同步通信适合于需要保证数据的可靠性和顺序的场景，而异步通信则适合于需要高效的通信和灵活性的场景。在实际应用中，通常需要根据具体的需求和场景来选择使用哪种通信方式。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fun的用法</title>
      <link href="/2023/06/25/Fun/"/>
      <url>/2023/06/25/Fun/</url>
      
        <content type="html"><![CDATA[<p>介绍erlang中Fun的用法和函数式编程的思想和技巧。</p><span id="more"></span><p><a href="https://www.erlang.org/doc/programming_examples/funs.html">Erlang – Funs</a></p><h1 id="函数式编程简介"><a href="#函数式编程简介" class="headerlink" title="函数式编程简介"></a>函数式编程简介</h1><p>函数式编程（Functional Programming）是一种编程范式，它将计算看作是数学函数的组合。函数式编程强调函数的纯洁性（pureness）、不可变性（immutability）和无副作用（side-effect free）。在函数式编程中，函数被视为一等公民（first-class citizen），可以像其他数据类型一样传递和操作。</p><p>比起指令式编程，函数式编程更加强调程序执行的结果而非执行的过程，倡导利用若干简单的执行单元让计算结果不断渐进，逐层推导复杂的运算，而不是设计一个复杂的执行过程。</p><h1 id="Erlang中的Fun"><a href="#Erlang中的Fun" class="headerlink" title="Erlang中的Fun"></a>Erlang中的Fun</h1><h2 id="Fun的作用"><a href="#Fun的作用" class="headerlink" title="Fun的作用"></a>Fun的作用</h2><ul><li>对列表里的每一个元素执行相同的操作。在这个案例里，将fun作为参数传递给lists:map/2和lists:filter/2等函数。fun的这种用法是极其普遍的。</li><li>创建自己的控制抽象。这一技巧极其有用。例如，Erlang没有for循环，但我们可以轻松创建自己的for循环。创建控制抽象的优点是可以让它们精确实现我们想要的做法，而不是依赖一组预定义的控制抽象，因为它们的行为可能不完全是我们想要的。</li><li>实现可重入解析代码（reentrant parsing code）、解析组合器（parser combinator）或惰性求值器（lazy evaluator）等事物。在这个案例里，我们编写返回fun的函数。这种技术很强大，但可能会导致程序难以调试。</li></ul><h2 id="创建Fun"><a href="#创建Fun" class="headerlink" title="创建Fun"></a>创建Fun</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fun = <span class="keyword">fun</span></span><br><span class="line">         () -&gt;</span><br><span class="line">          <span class="number">1</span>;</span><br><span class="line">         (arg) -&gt;</span><br><span class="line">          <span class="number">2</span></span><br><span class="line">      <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>从命名函数创建</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add</span><span class="params">(A, B)</span> -&gt;</span></span><br><span class="line">  A + B.</span><br><span class="line"></span><br><span class="line">Fun = <span class="keyword">fun</span> add/<span class="number">2</span>.</span><br><span class="line">Fun = <span class="keyword">fun</span> module:add/<span class="number">2</span>.</span><br></pre></td></tr></table></figure><p>变量绑定</p><ul><li>参数列表的变量是局部参数，和外部变量的值不同</li><li>函数体外已经定义的变量是全局的，函数体内的值和外部一致</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">print_list</span><span class="params">(File, List)</span> -&gt;</span></span><br><span class="line">  &#123;ok, Stream&#125; = file:open(File, write),</span><br><span class="line">  <span class="comment">% X未绑定 Stream已绑定</span></span><br><span class="line">  lists:foreach(<span class="keyword">fun</span>(X) -&gt; io:format(Stream,<span class="string">&quot;~p~n&quot;</span>,[X]) <span class="keyword">end</span>, List),</span><br><span class="line">  file:close(Stream).</span><br></pre></td></tr></table></figure><h2 id="以fun作为参数的函数"><a href="#以fun作为参数的函数" class="headerlink" title="以fun作为参数的函数"></a>以fun作为参数的函数</h2><p>通过自引用的技巧，可以写出递归的Fun</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 计算阶乘</span></span><br><span class="line"><span class="number">1</span>&gt;   Fun = <span class="keyword">fun</span> </span><br><span class="line">          (This, <span class="number">0</span>, Acc) -&gt;</span><br><span class="line">            Acc;           </span><br><span class="line">          (This, N, Acc) -&gt;</span><br><span class="line">            This(This, N - <span class="number">1</span>, Acc * N)</span><br><span class="line">        <span class="keyword">end</span>.                          </span><br><span class="line">#Fun&lt;erl_eval.<span class="number">18.118419387</span>&gt;</span><br><span class="line"><span class="number">2</span>&gt; Fun(Fun, <span class="number">4</span>, <span class="number">1</span>).         </span><br><span class="line"><span class="number">24</span> </span><br></pre></td></tr></table></figure><h2 id="返回fun的函数"><a href="#返回fun的函数" class="headerlink" title="返回fun的函数"></a>返回fun的函数</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9</span>&gt; Fruit = [apple, pear, orange].</span><br><span class="line">[apple,pear,orange]</span><br><span class="line"><span class="number">10</span>&gt; MakeTest = <span class="keyword">fun</span></span><br><span class="line">               (L) -&gt;</span><br><span class="line">                 (<span class="keyword">fun</span>(X) -&gt; lists:member(X, L) <span class="keyword">end</span>)</span><br><span class="line">             <span class="keyword">end</span>.</span><br><span class="line">#Fun&lt;erl_eval.<span class="number">6.118419387</span>&gt;</span><br><span class="line"><span class="number">11</span>&gt; IsFruit = MakeTest(Fruit). </span><br><span class="line">#Fun&lt;erl_eval.<span class="number">6.118419387</span>&gt;</span><br><span class="line"><span class="number">12</span>&gt; IsFruit(pear).</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>可用于实现以下应用</p><ul><li>抽象控制流程：返回函数的函数可以用来抽象控制流程，例如在循环中使用递归进行迭代。这可以使代码更加简单和易于理解。</li><li>延迟求值：返回函数的函数可以用于实现延迟求值。例如，在惰性求值器中，我们可以返回一个函数，该函数在需要时才计算结果。</li><li>动态代码生成：返回函数的函数可以用于动态生成代码。例如，在编写编译器或解析器时，我们可以返回一个函数，该函数用于生成解析树或代码。</li><li>部分应用：返回函数的函数可以用于部分应用。例如，我们可以返回一个函数，该函数接受一个参数并返回另一个函数，该函数接受另一个参数并返回结果。这可以用来生成特定的函数，例如增量器函数。</li></ul><h2 id="定义控制抽象"><a href="#定义控制抽象" class="headerlink" title="定义控制抽象"></a>定义控制抽象</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">for</span><span class="params">(Max, Max, F)</span> -&gt;</span></span><br><span class="line">  [F(Max)];</span><br><span class="line"><span class="function"><span class="title">for</span><span class="params">(I, Max, F)</span> -&gt;</span></span><br><span class="line">  [F(I) | for(I + <span class="number">1</span>, Max, F)].</span><br><span class="line"></span><br><span class="line"><span class="comment">%%</span></span><br><span class="line"><span class="function"><span class="title">for</span><span class="params">(<span class="number">1</span>, <span class="number">10</span>, <span class="keyword">fun</span>(I) -&gt; I <span class="keyword">end</span>)</span>.</span></span><br><span class="line"><span class="function">[1,2,3,4,5,6,7,8,9,10]</span></span><br></pre></td></tr></table></figure><h2 id="可重入解析代码"><a href="#可重入解析代码" class="headerlink" title="可重入解析代码"></a>可重入解析代码</h2><p>可重入解析代码是指可以被多个线程同时调用的解析代码</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解析组合器"><a href="#解析组合器" class="headerlink" title="解析组合器"></a>解析组合器</h2><p><a href="https://juejin.cn/post/7165305514480369701">https://juejin.cn/post/7165305514480369701</a></p><p><a href="https://serokell.io/blog/parser-combinators-in-elixir">https://serokell.io/blog/parser-combinators-in-elixir</a></p><p>将小型解析器组合成更大解析器的技术</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="惰性求值器"><a href="#惰性求值器" class="headerlink" title="惰性求值器"></a>惰性求值器</h2><p>惰性求值器（lazy evaluator）是一种计算模型，它只在需要时才计算表达式的值。惰性求值器通常用于处理无限列表、大型数据集或需要计算代价很高的表达式的程序。Erlang中支持惰性求值，可以使用列表推导式或流（stream）来实现。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h1 id="深入函数式编程"><a href="#深入函数式编程" class="headerlink" title="深入函数式编程"></a>深入函数式编程</h1><p><a href="https://www.zhihu.com/question/28292740">https://www.zhihu.com/question/28292740</a></p><p><a href="https://tech.meituan.com/2022/10/13/dive-into-functional-programming-01.html">https://tech.meituan.com/2022/10/13/dive-into-functional-programming-01.html</a></p><p><a href="https://tech.meituan.com/2022/10/13/dive-into-functional-programming-02.html">https://tech.meituan.com/2022/10/13/dive-into-functional-programming-02.html</a></p><p><a href="https://www.ruanyifeng.com/blog/2012/04/functional_programming.html">https://www.ruanyifeng.com/blog/2012/04/functional_programming.html</a></p><p><a href="https://www.defmacro.org/2006/06/19/fp.html">https://www.defmacro.org/2006/06/19/fp.html</a></p><p>TODO：整理中</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gen_statem</title>
      <link href="/2023/06/24/gen_statem/"/>
      <url>/2023/06/24/gen_statem/</url>
      
        <content type="html"><![CDATA[<p>介绍四大行为模式之一的gen_statem</p><span id="more"></span><p><a href="https://www.erlang.org/doc/design_principles/statem.html">Erlang – gen_statem Behaviour</a></p><p><a href="https://zhuanlan.zhihu.com/p/46347732">https://zhuanlan.zhihu.com/p/46347732</a></p><p><a href="https://ruby-china.org/topics/33559">https://ruby-china.org/topics/33559</a></p><h1 id="有限状态机"><a href="#有限状态机" class="headerlink" title="有限状态机"></a>有限状态机</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>有限状态机（FSM）是一种数学模型，用于描述一些系统或过程的行为。这些系统或过程可以被看作是由一系列<strong>状态</strong>和在这些状态之间进行<strong>转移的规则</strong>组成的，FSM 可以用来描述这些状态和规则的结构和行为。</p><p>FSM 通常包括一个有限状态集合、输入符号集合、输出符号集合、转移函数以及初始状态和终止状态。在 FSM 中，系统从一个状态开始，依照一定规则接受输入，并根据规则进行状态转移，最终到达某个终止状态。</p><p>状态机中的要素：</p><ul><li>现态：是指当前所处的状态。</li><li>条件：又称为“<strong>事件</strong>”，当一个条件被满足（接收输入或信号），可以触发一次状态的<strong>转移</strong>或执行一个<strong>动作</strong>。</li><li>动作（Action）：条件满足后执行的动作。动作执行完毕后，可以转移到新的状态，也可以仍旧保持原状态。动作不是必需的，当条件满足后，也可以不执行任何动作，直接转移到新状态。</li><li>次态：条件满足后要转移的新状态。“次态”是相对于“现态”而言的，“次态”一旦被激活，就转变成新的“现态”了。</li></ul><p>状态机在运行过程中，根据事件和当前状态，判断是否满足条件，如果满足条件，则执行相应的动作，并进行状态转移到次态；否则，保持现态等待下一个事件的到来。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>TCP（传输控制协议）是一个使用 FSM 的计算机网络协议的例子。TCP 是一种可靠的、面向连接的、基于字节流的传输协议，用于在计算机之间进行数据通信。</p><p>TCP 中的 FSM 用于描述 TCP 连接的建立、维护和关闭过程。在 TCP 连接的建立过程中，客户端和服务器通过交换 SYN 和 ACK 报文来协商连接参数，并建立一个连接。在连接建立后，TCP 使用 FSM 来维护连接状态，包括数据传输、流量控制和拥塞控制等。</p><p>TCP FSM 包括多个状态，如 CLOSED、LISTEN、SYN-SENT、SYN-RECEIVED、ESTABLISHED、FIN-WAIT-1、FIN-WAIT-2、CLOSE-WAIT、CLOSING、LAST-ACK 和 TIME-WAIT 等。每个状态具有一组规则，用于确定连接的下一步状态和行为。TCP FSM 的设计使得 TCP 协议能够在不同的网络环境下，如高延迟、高带宽、拥塞等情况下，保证数据的可靠传输和网络性能的优化。</p><h2 id="用erlang实现fsm"><a href="#用erlang实现fsm" class="headerlink" title="用erlang实现fsm"></a>用erlang实现fsm</h2><p>FSM （有限状态机）是一种抽象模型，它由有限数量的状态（ state ）以及事件（ event ）构成。当程序处于各个状态时，它可以从环境中接收一些特定的事件一一井且只接收这些事件。当事件抵达，而FSM 处于特定的状态时， 程序就会执行一些与当前状态对应的预先决定好的动作，使得当前状态转移为另一个新的状态。然后FSM 以此新状态、等待下一个新的事件。</p><p>在Erlang中，每个状态（ state ）以一个内含<strong>尾递归</strong>的函数表示，而事件（ event ）则以<strong>消息</strong>（ message ）表示。</p><p>实例</p><ul><li>状态<ul><li>白天<ul><li>事件<ul><li>eclipse</li><li>sunset</li></ul></li></ul></li><li>黑夜<ul><li>事件<ul><li>sunrise</li></ul></li></ul></li></ul></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">start</span><span class="params">()</span>-&gt;</span></span><br><span class="line">  spawn(?MODULE, init, []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">init</span><span class="params">()</span>-&gt;</span></span><br><span class="line">  create_earth(),</span><br><span class="line">  day().</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">day</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  <span class="keyword">receive</span></span><br><span class="line">    eclipse -&gt; day();</span><br><span class="line">    sunset  -&gt; night()</span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">night</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  <span class="keyword">receive</span></span><br><span class="line">    sunrise -&gt;</span><br><span class="line">      make_roosters_crow(),</span><br><span class="line">      day()</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><h1 id="gen-statem"><a href="#gen-statem" class="headerlink" title="gen_statem"></a>gen_statem</h1><p>由于gen_fsm已经过时，由gen_statem取代，因此本文介绍gen_statem的使用。</p><p>本文中的<strong>例子</strong>来自erlang官网上的一个<a href="https://www.erlang.org/doc/design_principles/statem.html#example">示例</a>，该示例的状态和事件如下：</p><p>状态</p><ul><li>locked</li><li>open</li></ul><p>事件</p><ul><li>collect_buttons()</li><li>clear_buttonss()</li><li>state_timeout(10)</li><li>do_lock()</li><li>do_unlock()</li></ul><h2 id="启动gen-statem"><a href="#启动gen-statem" class="headerlink" title="启动gen_statem"></a>启动gen_statem</h2><p>启动的函数基本和gen_server相同</p><ul><li>start(Module :: module(), Args :: term(), Opts :: [start_opt()]) -&gt;<pre><code>start_ret()</code></pre></li><li>start(ServerName :: server_name(),<pre><code>Module :: module(),Args :: term(),Opts :: [start_opt()]) -&gt;   start_ret()</code></pre></li><li>start_link(Module :: module(),<pre><code>Args :: term(),Opts :: [start_opt()]) -&gt;   start_ret()</code></pre></li><li>start_link(ServerName :: server_name(),<pre><code>Module :: module(),Args :: term(),Opts :: [start_opt()]) -&gt;   start_ret()</code></pre></li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><ul><li>Module:init(Args) -&gt; Result(StateType)<ul><li>Result(StateType) 可以是<ul><li>{ok, State :: StateType, Data :: DataType}<br>成功初始化，State是初始状态，Data是初始数据</li><li>{ok,<pre><code> State :: StateType, Data :: DataType, Actions :: [action()] | action()&#125;</code></pre></li><li>ignore</li><li>{stop, Reason :: term()}</li><li>{error, Reason :: term()}</li></ul></li></ul></li></ul><h3 id="回调模式（Callback-Modes）"><a href="#回调模式（Callback-Modes）" class="headerlink" title="回调模式（Callback Modes）"></a>回调模式（Callback Modes）</h3><p>gen_statem 支持两种回调模式</p><ul><li><a href="https://www.erlang.org/doc/man/gen_statem.html#type-callback_mode">state_functions</a>，每种状态都分别有一个回调函数处理，相当于有限状态机</li><li><a href="https://www.erlang.org/doc/man/gen_statem.html#type-callback_mode">handle_event_function</a>，所有事件都统一由一个回调函数处理。</li></ul><p>通过实现强制的回调函数<code>callback_mode/0</code>来选择回调模式，回调模式可能由于代码的升降级和更改回调模块而更改。</p><ul><li>Module:callback_mode() -&gt; CallbackMode<br>CallbackMode = callback_mode() | [ callback_mode() | state_enter() ]</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">callback_mode</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    state_functions.</span><br><span class="line"><span class="function"><span class="title">callback_mode</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    state_functions.</span><br><span class="line"><span class="function"><span class="title">callback_mode</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    [state_functions,state_enter].</span><br><span class="line"><span class="function"><span class="title">callback_mode</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    [handle_event_function,state_enter].</span><br></pre></td></tr></table></figure><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>启动进程，设置为state_functions模式</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-define</span><span class="params">(NAME, code_lock)</span>.</span><br><span class="line"><span class="function"><span class="title">start_link</span><span class="params">(Code)</span> -&gt;</span></span><br><span class="line">  gen_statem:start_link(&#123;local, ?NAME&#125;, ?MODULE, Code, []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">init</span><span class="params">(Code)</span> -&gt;</span></span><br><span class="line">  do_lock(),</span><br><span class="line">  Data = #&#123;code =&gt; Code, length =&gt; length(Code), buttons =&gt; []&#125;,</span><br><span class="line">  &#123;ok, locked, Data&#125;.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">callback_mode</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  state_functions.</span><br></pre></td></tr></table></figure><h2 id="发出事件"><a href="#发出事件" class="headerlink" title="发出事件"></a>发出事件</h2><h3 id="异步事件"><a href="#异步事件" class="headerlink" title="异步事件"></a>异步事件</h3><ul><li>cast(ServerRef :: server_ref(), Msg :: term()) -&gt; ok</li><li>send_request(ServerRef :: server_ref(), Request :: term()) -&gt; ReqId :: request_id()</li><li>send_request(ServerRef :: server_ref(), Request :: term(), Label :: term(), ReqIdCollection :: request_id_collection()) -&gt; NewReqIdCollection :: request_id_collection()</li><li>check_response(Msg, ReqId) -&gt; Result</li><li>check_response(Msg, ReqIdCollection, Delete) -&gt; Result</li><li>receive_response(ReqId, Timeout) -&gt; Result</li></ul><p>cast方法用于向状态机发送不需要响应的异步消息。这类消息通常用于状态机内部的事件通知，例如通知状态机启动一个新的异步任务或者通知状态机进行某个操作。cast方法不会阻塞发送方，因为它不需要等待状态机的响应。</p><p>send_request方法用于向状态机发送需要响应的异步消息。这类消息通常用于向状态机请求某些操作的执行结果，例如请求状态机执行某个查询操作并返回结果。send_request方法会阻塞发送方，直到状态机响应了消息并返回结果，或者消息超时。send_request方法通常与handle_info回调函数一起使用，以处理状态机的异步消息。</p><h3 id="同步事件"><a href="#同步事件" class="headerlink" title="同步事件"></a>同步事件</h3><p>TODO</p><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">button</span><span class="params">(Button)</span> -&gt;</span></span><br><span class="line">  gen_statem:cast(?NAME, &#123;button, Button&#125;).</span><br></pre></td></tr></table></figure><h2 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h2><h3 id="状态回调（State-Callback）"><a href="#状态回调（State-Callback）" class="headerlink" title="状态回调（State Callback）"></a>状态回调（State Callback）</h3><p><strong>处理</strong>现态下的事件的回调<strong>函数</strong>，具体是哪个函数取决于回调模式：</p><ul><li>state_functions 模式，由<code>StateName</code>处理（StateName是自定义的处理函数名）<ul><li>EventType有三种<ul><li><strong><a href="https://www.erlang.org/doc/man/gen_statem.html#type-external_event_type">external</a></strong><ul><li>cast，Generated by gen_statem:cast(ServerRef, Msg)，Msg是EventContent </li><li>{call,From}，Generated by gen_statem:call(ServerRef, Request)，Request是EventContent </li><li>info，Generated by any regular process message sent to the gen_statem process. 进程传过来的是EventContent </li></ul></li><li><strong><a href="https://www.erlang.org/doc/man/gen_statem.html#type-timeout_event_type">timeout</a></strong><ul><li>state_timeout，Generated by transition action {state_timeout,Time,EventContent}</li><li>{timeout,Name}，Generated by transition action { {timeout,Name},Time,EventContent} generic timer timing out.</li><li>timeout，Generated by transition action {timeout,Time,EventContent} (or its short form Time) event timer timing out. </li></ul></li><li>internal，Generated by transition action {next_event,internal,EventContent}</li><li>所有事件类型还可以由{next_event,EventType,EventContent}生成</li></ul></li></ul></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module:StateName(EventType, EventContent, Data) -&gt; StateFunctionResult</span><br></pre></td></tr></table></figure><ul><li>handle_event_function模式，由<code>handle_event</code>处理</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module:handle_event(EventType, EventContent, State, Data) -&gt; HandleEventResult</span><br></pre></td></tr></table></figure><h3 id="进入回调（State-Enter-Calls）"><a href="#进入回调（State-Enter-Calls）" class="headerlink" title="进入回调（State Enter Calls）"></a>进入回调（State Enter Calls）</h3><p>特殊的回调函数，每次状态改变时（进入一个状态）会被调用</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Module:StateName(enter, OldState, Data) -&gt; StateEnterResult(StateName) </span><br></pre></td></tr></table></figure><h3 id="过渡动作（Transition-Actions）"><a href="#过渡动作（Transition-Actions）" class="headerlink" title="过渡动作（Transition Actions）"></a>过渡动作（Transition Actions）</h3><p>TODO</p><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>从状态回调退出时开始计算，三种超时：</p><ul><li>state_timeout</li><li>{timeout, Name}</li><li>timeout</li></ul><h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>前面定义的是state_functions模式，这里用 <code>StateName</code> 的回调来处理。</p><ul><li>在lock状态下需要接收按键，最大长度是正确密码的长度</li><li>open状态，用state_timeout的方式停留10秒，转移到lock状态</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">locked</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    cast, &#123;button, Button&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    #&#123;code := Code, length := Length, buttons := Buttons&#125; = Data)</span> -&gt;</span></span><br><span class="line">  NewButtons =</span><br><span class="line">    <span class="keyword">if</span></span><br><span class="line">      length(Buttons) &lt; Length -&gt;</span><br><span class="line">        Buttons;</span><br><span class="line">      <span class="literal">true</span> -&gt;</span><br><span class="line">        tl(Buttons)</span><br><span class="line">    <span class="keyword">end</span> ++ [Button],</span><br><span class="line">  <span class="keyword">if</span></span><br><span class="line">    NewButtons =:= Code -&gt; <span class="comment">% Correct</span></span><br><span class="line">      do_unlock(),</span><br><span class="line">      &#123;next_state, open, Data#&#123;buttons := []&#125;,</span><br><span class="line">        [&#123;state_timeout, <span class="number">10000</span>, lock&#125;]&#125;; <span class="comment">% Time in milliseconds</span></span><br><span class="line">    <span class="literal">true</span> -&gt; <span class="comment">% Incomplete | Incorrect</span></span><br><span class="line">      &#123;next_state, locked, Data#&#123;buttons := NewButtons&#125; &#125;</span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">open</span><span class="params">(state_timeout, lock, Data)</span> -&gt;</span></span><br><span class="line">  do_lock(),</span><br><span class="line">  &#123;next_state, locked, Data&#125;;</span><br><span class="line"><span class="function"><span class="title">open</span><span class="params">(cast, &#123;button, _&#125;, Data)</span> -&gt;</span></span><br><span class="line">  &#123;next_state, open, Data&#125;.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">do_lock</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;Lock~n&quot;</span>, []).</span><br><span class="line"><span class="function"><span class="title">do_unlock</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;Unlock~n&quot;</span>, []).</span><br></pre></td></tr></table></figure><h2 id="例子的完整代码"><a href="#例子的完整代码" class="headerlink" title="例子的完整代码"></a>例子的完整代码</h2><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(code_lock)</span>.</span><br><span class="line"><span class="keyword">-behaviour</span><span class="params">(gen_statem)</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">%% API</span></span><br><span class="line"><span class="keyword">-define</span><span class="params">(NAME, code_lock)</span>.</span><br><span class="line"></span><br><span class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">1</span>])</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([button/<span class="number">1</span>])</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([init/<span class="number">1</span>, callback_mode/<span class="number">0</span>, terminate/<span class="number">3</span>])</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([locked/<span class="number">3</span>, open/<span class="number">3</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">start_link</span><span class="params">(Code)</span> -&gt;</span></span><br><span class="line">  gen_statem:start_link(&#123;local, ?NAME&#125;, ?MODULE, Code, []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">button</span><span class="params">(Button)</span> -&gt;</span></span><br><span class="line">  gen_statem:cast(?NAME, &#123;button, Button&#125;).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">init</span><span class="params">(Code)</span> -&gt;</span></span><br><span class="line">  do_lock(),</span><br><span class="line">  Data = #&#123;code =&gt; Code, length =&gt; length(Code), buttons =&gt; []&#125;,</span><br><span class="line">  &#123;ok, locked, Data&#125;.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">callback_mode</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  state_functions.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">locked</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    cast, &#123;button, Button&#125;,</span></span></span><br><span class="line"><span class="params"><span class="function">    #&#123;code := Code, length := Length, buttons := Buttons&#125; = Data)</span> -&gt;</span></span><br><span class="line">  NewButtons =</span><br><span class="line">    <span class="keyword">if</span></span><br><span class="line">      length(Buttons) &lt; Length -&gt;</span><br><span class="line">        Buttons;</span><br><span class="line">      <span class="literal">true</span> -&gt;</span><br><span class="line">        tl(Buttons)</span><br><span class="line">    <span class="keyword">end</span> ++ [Button],</span><br><span class="line">  <span class="keyword">if</span></span><br><span class="line">    NewButtons =:= Code -&gt; <span class="comment">% Correct</span></span><br><span class="line">      do_unlock(),</span><br><span class="line">      &#123;next_state, open, Data#&#123;buttons := []&#125;,</span><br><span class="line">        [&#123;state_timeout, <span class="number">10000</span>, lock&#125;]&#125;; <span class="comment">% Time in milliseconds</span></span><br><span class="line">    <span class="literal">true</span> -&gt; <span class="comment">% Incomplete | Incorrect</span></span><br><span class="line">      &#123;next_state, locked, Data#&#123;buttons := NewButtons&#125; &#125;</span><br><span class="line">  <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">open</span><span class="params">(state_timeout, lock, Data)</span> -&gt;</span></span><br><span class="line">  do_lock(),</span><br><span class="line">  &#123;next_state, locked, Data&#125;;</span><br><span class="line"><span class="function"><span class="title">open</span><span class="params">(cast, &#123;button, _&#125;, Data)</span> -&gt;</span></span><br><span class="line">  &#123;next_state, open, Data&#125;.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">do_lock</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;Lock~n&quot;</span>, []).</span><br><span class="line"><span class="function"><span class="title">do_unlock</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;Unlock~n&quot;</span>, []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, State, _Data)</span> -&gt;</span></span><br><span class="line">  State =/= locked <span class="keyword">andalso</span> do_lock(),</span><br><span class="line">  ok.</span><br></pre></td></tr></table></figure><p>运行方式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1&gt; c(code_lock).                  </span><br><span class="line">&#123;ok,code_lock&#125;</span><br><span class="line">2&gt; code_lock:start_link([1,2,3]).</span><br><span class="line">Lock</span><br><span class="line">&#123;ok,&lt;0.62.0&gt;&#125;</span><br><span class="line">3&gt; code_lock:button(1). </span><br><span class="line">ok</span><br><span class="line">4&gt; code_lock:button(2). </span><br><span class="line">ok</span><br><span class="line">5&gt; code_lock:button(3). </span><br><span class="line">Unlock</span><br><span class="line">ok</span><br><span class="line">6&gt; Lock</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>gen_server</title>
      <link href="/2023/06/24/gen_server/"/>
      <url>/2023/06/24/gen_server/</url>
      
        <content type="html"><![CDATA[<p>介绍四大行为模式之一的gen_server</p><span id="more"></span><p><a href="https://www.erlang.org/doc/design_principles/gen_server_concepts.html">Erlang – gen_server Behaviour</a></p><h1 id="gen-server开发步骤"><a href="#gen-server开发步骤" class="headerlink" title="gen_server开发步骤"></a>gen_server开发步骤</h1><p>gen_server用于实现<strong>客户端/服务器</strong>模型，代码包括三部分：api，回调函数，实现函数（Internal functions）</p><p>回调模块的编写步骤：</p><ol><li> 确定回调模块名。 </li><li> 编写接口函数。 </li><li>在回调模块里编写六个必需的回调函数。 <ul><li> init 服务器初始化 </li><li> handle_call 处理同步请求 </li><li> handle_cast 处理异步请求 </li><li> handle_info 处理其他请求时必须实现 </li><li> terminate 终止服务器 </li><li> code_change 处理其他请求时必须实现 </li></ul></li><li> 回调函数更多是处理请求的发送和回复，具体的逻辑要编写一些私有函数（Internal functions）来实现。 </li></ol><h1 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h1><p><code>gen_server</code> 进程维护一个称为“状态”（state）的内部数据结构，它代表了服务器进程在某一时刻的状态，客户端可以通过向服务器发送请求来查询或修改这个状态。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-record</span><span class="params">(area_server_state, </span></span><br><span class="line"><span class="params">        &#123;</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">        &#125;)</span>.</span><br></pre></td></tr></table></figure><h1 id="启动gen-server"><a href="#启动gen-server" class="headerlink" title="启动gen_server"></a>启动gen_server</h1><ul><li><strong>start</strong><br> 启动独立的gen_server，standalone ，不包括在监督树的一部分。 <ul><li>start(Module :: module(),Args :: term(), Options :: [start_opt()]) -&gt; start_ret()</li><li>start(ServerName :: server_name(), Module :: module(), Args :: term(), Options :: [start_opt()]) -&gt; start_ret()</li></ul></li><li><strong>start_link</strong><br> 启动一个在监控树中的gen_server，这个函数应该直接或间接<strong>被supervision调用</strong> <ul><li> start_link(Module :: module(), Args :: term(), Options :: [start_opt()]) -&gt; start_ret() </li><li>start_link(ServerName :: server_name(), Module :: module(), Args :: term(), Options :: [start_opt()]) -&gt; start_ret() <ul><li>server_name() =<pre><code> &#123;local, LocalName :: atom()&#125; | &#123;global, GlobalName :: term()&#125; | &#123;via, RegMod :: module(), ViaName :: term()&#125;</code></pre> 和三参相比会<strong>注册</strong>进程，按ServerName注册到local或global </li><li> Module 是<strong>回调模块</strong>的名字，其中应当包含各种<strong>回调函数</strong>以及与server相关的代码 </li><li> Args 可以是任意Term，会被传递给<code>Module:init</code>用于初始化server 状态。 </li><li> Opts 是一列表，其中包括与进程和调试相关的各种选项 </li><li>start_ret() =<pre><code> &#123;ok, Pid :: pid()&#125; | ignore | &#123;error, Reason :: term()&#125;</code></pre></li></ul></li></ul></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">start_link</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  gen_server:start_link(&#123;local, ?SERVER&#125;, ?MODULE, [], []).</span><br></pre></td></tr></table></figure><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><ul><li>Module:init(Args) -&gt; Result<ul><li>Args对应start_link中的Args</li><li>Result = <ul><li>{ok,State} 成功返回</li><li>{ok,State,Timeout}<br>| {ok,State,hibernate}<br>| {ok,State,{continue,Continue}}<br>| {stop,Reason}<br>| {error,Reason}<br>| ignore</li></ul></li></ul></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">init</span><span class="params">([])</span> -&gt;</span></span><br><span class="line">  process_flag(trap_exit, true),</span><br><span class="line">  io:format(<span class="string">&quot;~p starting~n&quot;</span>, [?MODULE]),</span><br><span class="line">  &#123;ok, <span class="number">0</span>&#125;.</span><br></pre></td></tr></table></figure><h1 id="同步请求"><a href="#同步请求" class="headerlink" title="同步请求"></a>同步请求</h1><p>api使用call函数，实现远程过程调用，将所有的数据包装成Request来发送</p><ul><li><p>gen_server:call(ServerRef :: server_ref(), Request :: term()) -&gt; Reply :: term()</p></li><li><p>gen_server:call(ServerRef :: server_ref(), Request :: term(), Timeout :: timeout()) -&gt; Reply :: term()<br>发出同步请求</p><ul><li>ServerRef是Pid或注册名</li><li>Timeout 单位为ms</li></ul></li><li><p>Module:handle_call(Request, From, State) -&gt; Result<br>处理同步请求</p><ul><li><p>Result</p><ul><li><p>Reply会返回客户端，成为gen_server:call的返回值。NewState则是服务器接下来的状态。</p><ul><li>{reply,Reply,NewState}</li><li>{reply,Reply,NewState,Timeout}</li><li>{reply,Reply,NewState,hibernate}</li><li>{reply,Reply,NewState,{continue,Continue}}</li></ul></li><li><p>no reply会让服务器继续工作，但客户端会等待一个回复，所以服务器必须把回复的任务委派给其他进程</p><ul><li>{noreply,NewState} </li><li>{noreply,NewState,Timeout}</li><li>{noreply,NewState,hibernate}</li><li>{noreply,NewState,{continue,Continue}}</li></ul></li><li><p>用适当的参数调用stop会停止服务器</p><ul><li>{stop,Reason,Reply,NewState}</li><li>{stop,Reason,NewState}</li></ul></li></ul></li></ul></li></ul><p>复杂程度更高的应用程序经常会让gen_server回复一个noreply返回值，并把真正的回复任务委派给另一个进程。要了解更多这方面的信息，请阅读“Design Principles”①（设计原则）文档，以及sys和proc_lib模块的手册页。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">area</span><span class="params">(Thing)</span> -&gt;</span></span><br><span class="line">  gen_server:call(?MODULE, &#123;area, Thing&#125;).</span><br></pre></td></tr></table></figure><h1 id="异步请求"><a href="#异步请求" class="headerlink" title="异步请求"></a>异步请求</h1><p>实现了一个播发（cast），也就是没有返回值的调用（实际上就是一个消息，但习惯上称它为播发来与远程过程调用相区分）。异步请求是<strong>不期待回应</strong>的，因此handle_cast没有From参数。</p><ul><li>cast(ServerRef :: server_ref(), Request :: term()) -&gt; ok<br>发起异步请求</li><li>Module:handle_cast(Request, State) -&gt; Result <ul><li>Result<ul><li>{noreply, NewState} 改变服务器状态<ul><li>{noreply,NewState}</li><li>{noreply,NewState,Timeout}</li><li>{noreply,NewState,hibernate}</li><li>{noreply,NewState,{continue,Continue}}</li></ul></li><li>{stop, …} 停止服务器<ul><li>stop,Reason,NewState}</li></ul></li></ul></li></ul></li></ul><h1 id="处理自发性消息"><a href="#处理自发性消息" class="headerlink" title="处理自发性消息"></a>处理自发性消息</h1><p>回调函数handle_info(Info, State)被用来处理发给服务器的自发性消息。自发性消息是一切未经显式调用gen_server:call或gen_server:cast而到达服务器的消息。</p><ul><li><p>Module:handle_info(Info, State) -&gt; Result</p><ul><li><p>Result</p><ul><li><p>{noreply, NewState} 改变服务器状态</p><ul><li>{noreply,NewState}</li><li>{noreply,NewState,Timeout}</li><li>{noreply,NewState,hibernate}</li><li>{noreply,NewState,{continue,Continue}}</li></ul></li><li><p>{stop, …} 停止服务器</p><ul><li>stop,Reason,NewState}</li></ul></li></ul></li></ul></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">handle_call</span><span class="params">(&#123;area, Thing&#125;, _From, N)</span> -&gt;</span></span><br><span class="line">  &#123;reply, compute_area(Thing), N + <span class="number">1</span>&#125;.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">compute_area</span><span class="params">(&#123;square, X&#125;)</span> -&gt;</span> X * X;</span><br><span class="line"><span class="function"><span class="title">compute_area</span><span class="params">(&#123;rectangle, X, Y&#125;)</span> -&gt;</span> X * Y.</span><br></pre></td></tr></table></figure><h1 id="停止gen-server"><a href="#停止gen-server" class="headerlink" title="停止gen_server"></a>停止gen_server</h1><p>若gen_server是监控树的一部分，不需要关闭，由监控者的关闭策略来关闭。</p><p>如果是独立的gen_server，使用terminate函数关闭</p><ul><li>Module:terminate(Reason, State)</li></ul><p>当我们从单个服务器转向系统时，就会用到很多服务器。我们希望能以一致的方式监视它们、重启退出的服务器以及记录错误。这就是下一章的主题</p><p>构建系统</p><ul><li>当服务器崩溃时，需要一种机制来检测这种情况并重启它，为此将用到监控树（supervisiontree）这个概念。创建一个<strong>监控</strong>器来管理服务器，如果服务器崩溃就重启它们。</li><li>如果服务器确实崩溃了，我们希望知道它崩溃的原因，这样就能在未来修复这个问题。<br>为了记录所有错误，可以使用OTP的错误记录器。我们会展示<strong>如何配置错误记录器</strong>，以及如何根据错误日志生成错误报告。</li><li>计算质数（特别是大质数）时，CPU可能会过热，这就需要开启一个强力风扇来避免这种情况。要做到这一点，需要考虑警报。我们会用OTP<strong>事件处理框架</strong>来生成和处理警报</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">terminate</span><span class="params">(_Reason, _State = #area_server_state&#123;&#125;)</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;~p stopping~n&quot;</span>, [?MODULE]),</span><br><span class="line">  ok.</span><br></pre></td></tr></table></figure><h1 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h1><ul><li>Module:code_change(OldVsn, State, Extra) -&gt; {ok, NewState} | {error, Reason}<br>在代码更改时转换进程状态</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">code_change</span><span class="params">(_OldVsn, State = #area_server_state&#123;&#125;, _Extra)</span> -&gt;</span></span><br><span class="line">  &#123;ok, State&#125;.</span><br></pre></td></tr></table></figure><p>TODO：深入了解热更新再来看</p><h1 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start_link() -&gt;</span><br><span class="line">  gen_server:start_link(&#123;local, ?SERVER&#125;, ?MODULE, [], []).</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3&gt; c(area_server).</span><br><span class="line">&#123;ok,area_server&#125;</span><br><span class="line">4&gt; area_server:start_link().</span><br><span class="line">area_server starting</span><br><span class="line">&#123;ok,&lt;0.66.0&gt;&#125;</span><br><span class="line">5&gt; area_server:area(&#123;square, 2&#125;).</span><br><span class="line">4</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>erlang中的容器</title>
      <link href="/2023/06/24/erlang%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/"/>
      <url>/2023/06/24/erlang%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>介绍erlang中各种容器的用法。</p><span id="more"></span><h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>容器，存储可变数量数据，类似是带头节点的单链表，所有操作从头开始。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[area,<span class="number">100</span>,<span class="number">200</span>,<span class="string">&quot;你好&quot;</span>]</span><br></pre></td></tr></table></figure><h2 id="模式匹配的列表操作"><a href="#模式匹配的列表操作" class="headerlink" title="模式匹配的列表操作"></a>模式匹配的列表操作</h2><p>列表的第一个元素被称为列表头（head），把列表头去掉，剩下的就被称为列表尾（tail）。<br>[H|T] ，其中一个是元素，一个是列表，并且前面必须是元素，后面是列表，开头可以有多个元素</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThingsToBuy = [&#123;apples, <span class="number">10</span>&#125;,&#123;pears,<span class="number">6</span>&#125;,&#123;milk,<span class="number">3</span>&#125;].</span><br><span class="line">ThingsToBuy1 = [&#123;oranges,<span class="number">4</span>&#125;,&#123;newspaper,<span class="number">1</span>&#125;|ThingsToBuy]</span><br></pre></td></tr></table></figure><h2 id="列表推导（list-comprehension）"><a href="#列表推导（list-comprehension）" class="headerlink" title="列表推导（list comprehension）"></a>列表推导（list comprehension）</h2><p>能够生成元素并对生成的元素做测试的表达式。</p><ul><li>语法：<code>[X || Qualifier1, Qualifier2, ... ]</code><br>Qualifier1可以是生成器、位串生成器或过滤器 <ul><li>生成器（generator），<code>Pattern &lt;- ListExpr</code></li><li>位串（bitstring）生成器，<code>BitStringPattern &lt;= BitStringExpr</code></li><li>过滤器（filter）<br>判断函数（返回true或false）或布尔表达式，只有true的值会被加入列表</li></ul></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>].</span><br><span class="line"><span class="comment">% 从L中提取X，并加倍</span></span><br><span class="line">[<span class="number">2</span>*X || X &lt;- L].</span><br><span class="line"></span><br><span class="line"><span class="comment">%</span></span><br><span class="line">[ &#123;X,Y&#125; || x&lt;-[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], y &lt;- [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] ].</span><br><span class="line"></span><br><span class="line"><span class="comment">% 强制判断</span></span><br><span class="line">[throw(<span class="string">&quot;this_fun_not_use_uid_prop&quot;</span>) || z_prop_kit:get_prop_max(EncodeProp) =:= <span class="number">1</span>],</span><br></pre></td></tr></table></figure><h2 id="归集器"><a href="#归集器" class="headerlink" title="归集器"></a>归集器</h2><p>尾递归优化方法，程序<strong>只遍历列表一次</strong>，把奇偶参数分别添加到合适的列表里。这些列表被称为归集器（accumulator）。<br>区别在于：奇偶列表里的元素顺序是反转的</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">odds_and_evens</span><span class="params">(L)</span>-&gt;</span></span><br><span class="line">  odds_and_evens_acc(L, [], []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">odds_and_evens_acc</span><span class="params">([H|T],Odds, Events)</span>-&gt;</span></span><br><span class="line">  <span class="keyword">case</span> (H <span class="keyword">rem</span> <span class="number">2</span>) <span class="keyword">of</span></span><br><span class="line">    <span class="number">1</span>-&gt;</span><br><span class="line">      odds_and_evens_acc(T, [H|Odds], Events);</span><br><span class="line">    <span class="number">0</span>-&gt;</span><br><span class="line">      odds_and_evens_acc(T, Odds, [H|Events])</span><br><span class="line">  <span class="keyword">end</span>;</span><br><span class="line"><span class="function"><span class="title">odds_and_evens_acc</span><span class="params">([],Odds, Events)</span>-&gt;</span></span><br><span class="line">  &#123;Odds, Events&#125;.</span><br></pre></td></tr></table></figure><h2 id="常用BIF"><a href="#常用BIF" class="headerlink" title="常用BIF"></a>常用BIF</h2><ul><li>hd(List) -&gt; term()<br>取列表头</li><li>tl(List) -&gt; term()<br>取除列表头的部分</li><li>length(List) -&gt; integer() &gt;= 0<br>列表长度</li></ul><h2 id="lists模块提供的处理函数"><a href="#lists模块提供的处理函数" class="headerlink" title="lists模块提供的处理函数"></a>lists模块提供的处理函数</h2><ul><li>member(Elem, List) -&gt; boolean()<br>是否是成员</li><li>append(ListOfLists) -&gt; List1</li><li>append(List1, List2) -&gt; List3<br>调的也是++，++是复制左边，append是复制List1</li><li>reverse(List1) -&gt; List2</li><li>reverse(List1, Tail) -&gt; List2<br>反转List1并将Tail插入到列表尾</li><li>delete(Elem, List1) -&gt; List2</li><li>filter(Pred, List1) -&gt; List2<br>List2是Pred函数返回True的结果</li><li>sort(List1) -&gt; List2</li><li>sort(Fun, List1) -&gt; List2<br>使用自定义排序函数Fun来排序<br>对fun(A,B)，当A&lt;=B返回true，否则返回false</li><li>nth(N, List) -&gt; Elem</li><li>nthtail(N, List) -&gt; Tail</li><li>sublist(List1, Len) -&gt; List2</li><li>sublist(List1, Start, Len) -&gt; List2</li><li>search(Pred, List) -&gt; {value, Value} | false</li></ul><p>遍历，基本都是用匿名函数</p><ul><li>foldl(Fun, Acc0, List) -&gt; Acc1<br>对List里的元素连续调用Fun(Elem, AccIn)，Acc0是累加器的初始值</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  Fun = <span class="keyword">fun</span></span><br><span class="line">          (Elem, Acc) -&gt;</span><br><span class="line">            [Elem | Acc]</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">  lists:foldl(Fun, [], [a, b]).</span><br><span class="line"><span class="comment">% [b,a]</span></span><br></pre></td></tr></table></figure><ul><li>foldr(Fun, Acc0, List) -&gt; Acc1<br>和foldl的遍历顺序相反，是从右到左</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  Fun = <span class="keyword">fun</span></span><br><span class="line">          (Elem, Acc) -&gt;</span><br><span class="line">            [Elem | Acc]</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">  lists:foldr(Fun, [], [a, b]).</span><br><span class="line"><span class="comment">% [a,b]</span></span><br></pre></td></tr></table></figure><ul><li>map(Fun, List1) -&gt; List2<br>获取映射</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  Fun = <span class="keyword">fun</span></span><br><span class="line">          (a) -&gt;</span><br><span class="line">            x;</span><br><span class="line">          (b)-&gt;</span><br><span class="line">            y</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">  lists:map(Fun, [a,b]).</span><br><span class="line"><span class="comment">% [x,y]</span></span><br></pre></td></tr></table></figure><ul><li>mapfoldl(Fun, Acc0, List1) -&gt; {List2, Acc1}<br>结合map和foldl</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  Fun = <span class="keyword">fun</span></span><br><span class="line">          (X, Acc) -&gt;</span><br><span class="line">            &#123;<span class="number">2</span>*X, [X + <span class="number">1</span> | Acc]&#125;</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">  lists:mapfoldl(Fun, [], [<span class="number">1</span>, <span class="number">2</span>]).</span><br><span class="line"><span class="comment">% &#123;[2,4],[3,2]&#125;</span></span><br></pre></td></tr></table></figure><ul><li>mapfoldr(Fun, Acc0, List1) -&gt; {List2, Acc1}<br>结合map和foldr</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  Fun = <span class="keyword">fun</span></span><br><span class="line">          (X, Acc) -&gt;</span><br><span class="line">            &#123;<span class="number">2</span>*X, [X + <span class="number">1</span> | Acc]&#125;</span><br><span class="line">        <span class="keyword">end</span>,</span><br><span class="line">  lists:mapfoldl(Fun, [], [<span class="number">1</span>, <span class="number">2</span>]).</span><br><span class="line"><span class="comment">% &#123;[2,4],[2,3]&#125;</span></span><br></pre></td></tr></table></figure><ul><li>foreach(Fun, List) -&gt; ok<br>对List的每个元素执行Fun操作</li></ul><p>元组列表的操作</p><ul><li>keydelete(Key, N, TupleList1) -&gt; TupleList2</li><li>keyfind(Key, N, TupleList) -&gt; Tuple | false</li><li>keymap(Fun, N, TupleList1) -&gt; TupleList2</li><li>keymember(Key, N, TupleList) -&gt; boolean()</li><li>keymerge(N, TupleList1, TupleList2) -&gt; TupleList3</li><li>keyreplace(Key, N, TupleList1, NewTuple) -&gt; TupleList2</li><li>keysearch(Key, N, TupleList) -&gt; {value, Tuple} | false</li><li>keysort(N, TupleList1) -&gt; TupleList2</li><li>keystore(Key, N, TupleList1, NewTuple) -&gt; TupleList2</li><li>keytake(Key, N, TupleList1) -&gt; {value, Tuple, TupleList2} | false</li></ul><h2 id="z-lib提供的处理函数"><a href="#z-lib提供的处理函数" class="headerlink" title="z_lib提供的处理函数"></a>z_lib提供的处理函数</h2><ul><li>get_list_range/1<br>get_list_range(List::[term()]) -&gt; return() where return() = {Len::integer(), Min::term(), Max::term()} | false.<br>获得列表的最大最小值</li><li>get_value(List, Key, Default) -&gt; any()<br>从元组列表或Tree中，获得指定的键值，如果键不存在，使用默认值</li><li>get_value(List, Key, ValuePos, Default) -&gt; any()<br>从元组列表或Tree中，获得指定的键值，如果键不存在，使用默认值，可以指定值的位置</li><li>get_value(List, Key, KeyPos, ValuePos, Default)<br>可以指定键和值的位置</li><li>get_values(KVList, KeyDefaultList)<br>从元组列表或Tree中，获得指定的键值，如果键不存在，使用默认值</li><li>get_values(KVList, ValuePos,KeyDefaultList)</li><li>get_values(KVList, KeyPos, ValuePos, KeyDefaultList)</li></ul><h1 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h1><p>容器，存放固定数目的数据，类似于数组，可随机存取。用元组管理的项数不宜超过五六项。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;area,<span class="number">100</span>,<span class="number">200</span>,<span class="string">&quot;你好&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="常用BIF-1"><a href="#常用BIF-1" class="headerlink" title="常用BIF"></a>常用BIF</h2><ul><li>element(N, Tuple) -&gt; term()<br>获取指定位置数据</li><li>size(Item) -&gt; integer() &gt;= 0<br>获取元组长度</li><li>erlang:insert_element(Index, Tuple1, Term) -&gt; Tuple2<br>在Index位置插入Term</li><li>erlang:append_element(Tuple1, Term) -&gt; Tuple2<br>在尾部插入</li><li>erlang:delete_element(Index, Tuple1) -&gt; Tuple2<br>删除指定位置元素</li><li>setelement(Index, Tuple1, Value) -&gt; Tuple2<br>将Index位置更新为Value，返回新元组</li><li>erlang:make_tuple(Arity, InitialValue) -&gt; tuple()<br>创建具有Arity个InitialValue的元组</li><li>erlang:make_tuple(Arity, DefaultValue, InitList) -&gt; tuple()<br>创建具有Arity个DefaultValue的元组，并以InitList指定<br>如下指定第5个元素为zz，第2个元素（多次出现以最后一个为准）为aa</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; erlang:make_tuple(<span class="number">5</span>, [], [&#123;<span class="number">2</span>,ignored&#125;,&#123;<span class="number">5</span>,zz&#125;,&#123;<span class="number">2</span>,aa&#125;]).</span><br><span class="line">&#123;[],aa,[],[],zz&#125;</span><br></pre></td></tr></table></figure><p>遍历元组的方法，核心是传入索引</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">foreach</span><span class="params">(Tuple, F, A)</span> -&gt;</span></span><br><span class="line">  foreach(Tuple, <span class="number">1</span>, tuple_size(Tuple), F, A).</span><br><span class="line"><span class="function"><span class="title">foreach</span><span class="params">(Tuple, I, N, F, A)</span> <span class="title">when</span> I =&lt; N -&gt;</span></span><br><span class="line">  F(A, element(I, Tuple)),</span><br><span class="line">  foreach(Tuple, I + <span class="number">1</span>, N, F, A);</span><br><span class="line"><span class="function"><span class="title">foreach</span><span class="params">(_Tuple, _I, _N, _F, A)</span> -&gt;</span></span><br><span class="line">  A.</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>元组可用于实现字典</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MY_Dict = dict:new(),</span><br><span class="line">MY_Dict1 = dict:append(<span class="string">&quot;key&quot;</span>, <span class="string">&quot;value&quot;</span>, MY_Dict),</span><br><span class="line">dict:fetch_keys(MY_Dict1).</span><br></pre></td></tr></table></figure><h1 id="映射组"><a href="#映射组" class="headerlink" title="映射组"></a>映射组</h1><p>和记录一样也是键值对结构，但key可以不是原子，用于当<strong>键不能预先知道</strong>时用来表示键-值数据结构；</p><ul><li>当存在大量不同的键时用来表示数据；</li><li>当方便使用很重要而效率无关紧要时作为万能的数据结构使用；</li><li>用作“自解释型”的数据结构，也就是说，用户容易从键名猜出值的含义；</li><li>用来表示键-值解析树，例如XML或配置文件；</li><li>用JSON来和其他编程语言通信。</li></ul><ol><li><p>操作符</p><ul><li><code>=&gt;</code>，更新现有键或创建新键</li><li><code>:=</code>，更新现有键    </li></ul></li><li><p>原生操作</p><ul><li>创建映射组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&gt; #&#123;a=&gt;1,b=&gt;2&#125;.   #&#123;a =&gt; 1,b =&gt; 2&#125;</span><br></pre></td></tr></table></figure><ul><li>更新映射组</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">F1 = #&#123;a=&gt;1,b=&gt;2&#125;. F2 = #&#123;b=&gt;2,a=&gt;1&#125;. %F1=F2. F3 = F1#&#123;c=&gt;xx&#125; F4 = F3#&#123;c:=3&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用api操作</p><ul><li>创建映射组<br>maps:new().</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1&gt; MapGroup = maps:new().</span><br><span class="line">#&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>向映射组中添加映射<br>put(Key, Value, Map1) -&gt; Map2</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2&gt; MapGroup1 = maps:put(a, 1, MapGroup).</span><br><span class="line">#&#123;a =&gt; 1&#125;</span><br></pre></td></tr></table></figure><ul><li>从映射组中获取<strong>值</strong><ul><li>get(Key, Map) -&gt; Value</li><li>get(Key, Map, Default) -&gt; Value | Default</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3&gt; Value = maps:get(a, MapGroup1). </span><br><span class="line">1</span><br><span class="line">4&gt; Value1 = maps:get(c, MapGroup1, 1).</span><br><span class="line">1</span><br></pre></td></tr></table></figure><ul><li><p>更新</p><ul><li><p>update(Key, Value, Map1) -&gt; Map2<br>Map1不是Map抛badmap<br>Key不存在抛badkey</p></li><li><p>update_with(Key, Fun, Map1) -&gt; Map2</p></li><li><p>update_with(Key, Fun, Init, Map1) -&gt; Map2</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MapGroup2 = maps:update(a, <span class="number">2</span>, MapGroup1).</span><br></pre></td></tr></table></figure></li></ul></li><li><p>从映射组中删除映射</p><ul><li><p>remove(Key, Map1) -&gt; Map2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5&gt; MapGroup2= maps:remove(a, MapGroup1).</span><br><span class="line">#&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>遍历</strong>映射组，打印每个映射</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6&gt; Fun = fun(Key, Value, Acc) -&gt;</span><br><span class="line">                io:format(&quot;Key: ~p, Value: ~p~n&quot;, [Key, Value]), Acc       </span><br><span class="line">          end,</span><br><span class="line">maps:fold(Fun, [], MapGroup).</span><br><span class="line">[]</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>模式匹配<br>和列表一样，在函数<strong>参数</strong>中使用映射组可以提取相应的字段</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get_puid(#login&#123;puid=V&#125;) -&gt; V.</span><br></pre></td></tr></table></figure><p>、</p></li></ol><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>构造队列</p><ul><li>new() -&gt; queue(none())</li><li>from_list(L :: [Item]) -&gt; queue(Item)</li></ul><p>访问元素</p><ul><li>in(Item, Q1 :: queue(Item)) -&gt; Q2 :: queue(Item)<br>队尾入</li><li>in_r(Item, Q1 :: queue(Item)) -&gt; Q2 :: queue(Item)<br>队头入</li><li>out(Q1 :: queue(Item)) -&gt;<pre><code>&#123;&#123;value, Item&#125;, Q2 :: queue(Item)&#125; |&#123;empty, Q1 :: queue(Item)&#125;</code></pre>队头出</li><li>out_r(Q1 :: queue(Item)) -&gt;<pre><code>&#123;&#123;value, Item&#125;, Q2 :: queue(Item)&#125; |&#123;empty, Q1 :: queue(Item)&#125;</code></pre>队尾出</li><li>get(Q :: queue(Item)) -&gt; Item</li><li>get_r(Q :: queue(Item)) -&gt; Item</li><li>head(Q :: queue(Item)) -&gt; Item</li><li>last(Q :: queue(Item)) -&gt; Item</li></ul><p>其他</p><ul><li><code>queue:len(Queue)</code>：返回队列中元素的数量</li><li><code>queue:is_empty(Queue)</code>：检查队列是否为空</li><li><code>queue:reverse(Queue)</code>：返回一个反转顺序的队列副本</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt; Q=queue:new().</span><br><span class="line">&#123;[],[]&#125;</span><br><span class="line"><span class="number">2</span>&gt; Q1 = queue:in(a, Q). </span><br><span class="line">&#123;[a],[]&#125;</span><br><span class="line"><span class="number">3</span>&gt; Q2 = queue:in(b, Q1). </span><br><span class="line">&#123;[b],[a]&#125;</span><br><span class="line"><span class="number">4</span>&gt; Q3 = queue:out(Q2).   </span><br><span class="line">&#123;&#123;value,a&#125;,&#123;[],[b]&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>erlang并发和分布式编程</title>
      <link href="/2023/06/23/erlang%E5%B9%B6%E5%8F%91%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/06/23/erlang%E5%B9%B6%E5%8F%91%E5%92%8C%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.erlang.org/doc/reference_manual/processes.html">https://www.erlang.org/doc/reference_manual/processes.html</a><br><a href="https://www.erlang.org/doc/reference_manual/distributed.html">https://www.erlang.org/doc/reference_manual/distributed.html</a></p><p>erlang中关于并发和分布式编程的内容。</p><span id="more"></span><h1 id="Erlang中的通信"><a href="#Erlang中的通信" class="headerlink" title="Erlang中的通信"></a>Erlang中的通信</h1><p>在Erlang中，通信通过相互传递异步信号实现，通信的对象有进程和端口，进程用于内部通信，端口用于外部通信，常见的信号有exit, link, unlink, monitor, and demonitor signals等。</p><h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><p>Erlang中的并发是基于进程的并发，每个进程都带有一个邮箱，这个邮箱是和进程同步创建的。</p><ul><li>self(). % 显示当前进程号</li><li>i() % 显示所有进程信息</li></ul><p>在erlang中进行并发编程有三类基本并发函数：创建进程、发送消息和接受消息。</p><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><p>进程是自包含、独立的计算单元，单节点的创建方式有以下两种</p><ul><li>spawn(Fun) -&gt; pid()<br>不关心动态代码升级，或者确定程序不会在未来进行修改时用</li><li>spawn(Module, Function, Args) -&gt; pid()<br>支持热更新，确保运行进程能够正确 升级为新版模块代码</li></ul><h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>向一个进程发送消息有三种方式：Pid、注册名和别名</p><ul><li><p>Pid</p></li><li><p>注册名</p><ul><li>register(RegName, PidOrPort) -&gt; true<br>注册进程，注册名必须是atom类型</li><li>registered()<br>返回所有已注册的名字</li><li>whereis(Name)<br>通过注册名获取Pid<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt; c(area_server_final).</span><br><span class="line">&#123;ok,area_server_final&#125;</span><br><span class="line"><span class="number">2</span>&gt; Pid = spawn(area_server_final, loop, []).      </span><br><span class="line">&lt;<span class="number">0.62</span>.<span class="number">0</span>&gt;</span><br><span class="line"><span class="number">3</span>&gt; register(area,Pid).</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="number">4</span>&gt; area!&#123;rectangle,<span class="number">4</span>,<span class="number">5</span>&#125;.</span><br><span class="line">&#123;rectangle,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="number">9</span>&gt; erlang:send(Pid, &#123;circle, <span class="number">2</span>&#125;). </span><br></pre></td></tr></table></figure></li></ul></li><li><p>别名<br>进程别名本质上是一种引用类型，别名设计的典型用例是请求/回复场景。发送回复时使用进程别名可以使回复接收方在操作超时或进程之间的连接丢失时防止回复到达其消息队列。</p></li></ul><h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p>进程实际上隐藏了信息，我们无法直接访问这个函数的执行信息，但是可以通过发送和接受消息来进行交互，这点和服务器很像。在Fun中递归调用自身实现重复发送和接受消息。</p><ul><li>start 隐藏spawn和rpc</li><li>rpc 隐藏通信过程</li><li>loop 处理逻辑，要导出才能被spawn调用<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-export</span><span class="params">([start/<span class="number">0</span>, area/<span class="number">2</span>, loop/<span class="number">0</span>])</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">start</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    spawn(area_server, loop, []).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">area</span><span class="params">(Pid, What)</span> -&gt;</span></span><br><span class="line">    rpc(Pid, What).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">rpc</span><span class="params">(Pid, Request)</span> -&gt;</span></span><br><span class="line">    Pid ! &#123;self(), Request&#125;,</span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">     &#123;Pid, Response&#125; -&gt;</span><br><span class="line">         Response</span><br><span class="line"> <span class="keyword">end</span>.</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">loop</span><span class="params">()</span> -&gt;</span></span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">     &#123;From, &#123;rectangle, Width, Height&#125;&#125; -&gt;</span><br><span class="line">         From ! &#123;self(), Width * Height&#125;,</span><br><span class="line">         loop();</span><br><span class="line">     &#123;From, &#123;circle, R&#125;&#125; -&gt;</span><br><span class="line">         From ! &#123;self(), <span class="number">3.14159</span> * R * R&#125;,</span><br><span class="line">         loop();</span><br><span class="line">     &#123;From, Other&#125; -&gt;</span><br><span class="line">         From ! &#123;self(), &#123;error, Other&#125;&#125;,</span><br><span class="line">         loop()</span><br><span class="line"> <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>&gt; area_server:start().  </span><br><span class="line">&lt;<span class="number">0.89</span>.<span class="number">0</span>&gt;</span><br><span class="line"><span class="number">13</span>&gt; Server=area_server:start().   </span><br><span class="line">&lt;<span class="number">0.91</span>.<span class="number">0</span>&gt;</span><br><span class="line"><span class="number">14</span>&gt; area_server:area(Server, &#123;rectangle, <span class="number">1</span>,<span class="number">2</span>&#125;).</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="接收高级选项"><a href="#接收高级选项" class="headerlink" title="接收高级选项"></a>接收高级选项</h3><ol><li> 带超时的接收 </li></ol><ul><li>使用after指定</li><li>超时值为0，立即执行</li><li>超时值为原子<code>infinity</code>，永远不会超时<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">receive</span></span><br><span class="line">    &#123;From, Message&#125;-&gt;</span><br><span class="line">        ...</span><br><span class="line"><span class="keyword">after</span> Time-&gt;</span><br><span class="line">    Expressions</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></li></ul><ol start="2"><li> 选择性接收 </li></ol><h2 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h2><ol><li>当指定的函数执行完毕，进程正常终止，退出原因是原子 normal</li><li>异常终止，在erlang中，将运行时错误和生成错误表示为以下三类：<ul><li>exit(Reason)</li><li>erlang:error(Reason)</li><li>erlang:error(Reason, Args)</li></ul></li></ol><h2 id="顺序代码的错误处理"><a href="#顺序代码的错误处理" class="headerlink" title="顺序代码的错误处理"></a>顺序代码的错误处理</h2><h3 id="错误的分类"><a href="#错误的分类" class="headerlink" title="错误的分类"></a>错误的分类</h3><p>程序的错误大致可分为以下四类：</p><ul><li><strong>Compile-time errors</strong>，编译产生的错误，例如一些语法错误，可以借助编译器和静态代码分析器找出错误。</li><li><strong>Logical errors</strong>，程序的行为与预想中的不同，例如点击按钮没有反应。</li><li><strong>Run-time errors</strong>，使程序发生崩溃的严重错误，例如运算符作用在错误的类型，也可以用error(Reason)来生成。</li><li><strong>Generated errors</strong>，在代码中调用 <a href="https://www.erlang.org/doc/man/erlang.html#exit-1">exit/1</a>和<code>[throw/1](https://www.erlang.org/doc/man/erlang.html#throw-1)</code>来生成错误。</li></ul><p>Erlang中，将<strong>Run-time errors</strong>和<strong>Generated errors</strong>表示为三类：error、exit、throw。</p><h3 id="用try-catch处理异常"><a href="#用try-catch处理异常" class="headerlink" title="用try catch处理异常"></a>用try catch处理异常</h3><p>程序结构：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> FuncOrExpressionSeq <span class="keyword">of</span></span><br><span class="line">    Patern1 [<span class="keyword">when</span> Guard1] -&gt; Expressions1;</span><br><span class="line">    Patern1 [<span class="keyword">when</span> Guard2] -&gt; Expressions2;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">catch</span></span><br><span class="line">ExceptionType1: ExPattern1 [<span class="keyword">when</span> ExGuard1] -&gt; ExExpressions1;</span><br><span class="line">ExceptionType2: ExPattern2 [<span class="keyword">when</span> ExGuard2] -&gt; ExExpressions2;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">after</span></span><br><span class="line">    AfterExpressions</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ol><li> 捕获错误，在try中编写可能出错的代码，可以使用可选的of进行分支选择。 </li><li> 匹配错误 </li></ol><ul><li> 冒号前的ExceptionType取值为error、exit、throw中一种。 </li><li> 冒号后的ExPattern用于匹配<strong>catch的返回值</strong>，一般是错误的原因，以便进行处理。 </li><li>可选的Stacktrace用于匹配exit类型错误的堆栈信息</li></ul><ol start="3"><li> 处理错误，若模式匹配成功可以在-&gt;后处理，处理完成后执行after子句的内容。 </li></ol><p>实例</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">try</span></span><br><span class="line"><span class="comment">%%    exit(basketball),</span></span><br><span class="line"><span class="comment">%%    error(football),</span></span><br><span class="line">    throw(&#123;my_exception, <span class="string">&quot;Something happened&quot;</span>&#125;)</span><br><span class="line">  <span class="keyword">catch</span></span><br><span class="line">    exit:Reason -&gt;</span><br><span class="line">      io:format(<span class="string">&quot;error Reason:~w~n&quot;</span>, [Reason]);</span><br><span class="line">    error: Reason -&gt;</span><br><span class="line">      io:format(<span class="string">&quot;error Reason:~w~n&quot;</span>, [Reason]);</span><br><span class="line">    throw:&#123;my_exception, Desc&#125; -&gt;</span><br><span class="line">      io:format(standard_error, <span class="string">&quot;Error: ~s~n&quot;</span>, [Desc])</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>常见错误原因</p><table><thead><tr><th><strong>Reason</strong></th><th><strong>Type of Error</strong></th></tr></thead><tbody><tr><td>badarg</td><td>Bad argument. The argument is of wrong data type, or is otherwise badly formed.</td></tr><tr><td>badarith</td><td>Bad argument in an arithmetic expression.</td></tr><tr><td>{badmatch,V}</td><td>Evaluation of a match expression failed. The value V did not match.</td></tr><tr><td>function_clause</td><td>No matching function clause is found when evaluating a function call.</td></tr><tr><td>{case_clause,V}</td><td>No matching branch is found when evaluating a case expression. The value V did not match.</td></tr><tr><td>if_clause</td><td>No true branch is found when evaluating an if expression.</td></tr><tr><td>{try_clause,V}</td><td>No matching branch is found when evaluating the of-section of a try expression. The value V did not match.</td></tr><tr><td>undef</td><td>The function cannot be found when evaluating a function call.</td></tr><tr><td>{badfun,F}</td><td>Something is wrong with a fun F.</td></tr><tr><td>{badarity,F}</td><td>A fun is applied to the wrong number of arguments. F describes the fun and the arguments.</td></tr><tr><td>timeout_value</td><td>The timeout value in a receive..after expression is evaluated to something else than an integer or infinity.</td></tr><tr><td>noproc</td><td>Trying to link or monitor to a non-existing process or port.</td></tr><tr><td>noconnection</td><td>A link or monitor to a remote process was broken because a connection between the nodes could not be established or was severed.</td></tr><tr><td>{nocatch,V}</td><td>Trying to evaluate a throw outside a catch. V is the thrown term.</td></tr><tr><td>system_limit</td><td>A system limit has been reached. See <a href="https://www.erlang.org/doc/efficiency_guide/advanced.html">Efficiency Guide</a></td></tr><tr><td>for information about system limits.</td><td></td></tr></tbody></table><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">try</span></span><br><span class="line"><span class="comment">%%    1 / 0,</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> <span class="keyword">of</span></span><br><span class="line">      <span class="number">0</span>-&gt;</span><br><span class="line">        ok</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">catch</span></span><br><span class="line">    error: badarith -&gt;</span><br><span class="line">      io:format(<span class="string">&quot;arith error&quot;</span>);</span><br><span class="line">    error:&#123;case_clause,V&#125;-&gt;</span><br><span class="line">      io:format(<span class="string">&quot;Unmatch Pattern: ~w~n&quot;</span>,[V])</span><br><span class="line">  <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><h3 id="用catch处理异常"><a href="#用catch处理异常" class="headerlink" title="用catch处理异常"></a>用catch处理异常</h3><p>使用catch语句捕获异常，<strong>单独的catch语句和try catch里的catch的使用方式不同</strong>，会将错误转换为元组或Term。</p><ul><li>catch exit(Reason)-&gt; {‘EXIT’,Reason}</li><li>catch error(Reason) -&gt; {‘EXIT’,{Reason,Stack}} </li><li>catch throw(Any) -&gt; Any<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span>&gt; exit(foobar).</span><br><span class="line">** exception exit: foobar</span><br><span class="line"><span class="number">19</span>&gt; <span class="keyword">catch</span> exit(foobar).</span><br><span class="line">&#123;&#x27;EXIT&#x27;,foobar&#125;</span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="number">20</span>&gt; error(football).     </span><br><span class="line">** exception error: football</span><br><span class="line"><span class="number">21</span>&gt; <span class="keyword">catch</span> error(foobar). </span><br><span class="line">&#123;&#x27;EXIT&#x27;,&#123;foobar,[&#123;shell,apply_fun,<span class="number">3</span>,</span><br><span class="line">                        [&#123;file,<span class="string">&quot;shell.erl&quot;</span>&#125;,&#123;line,<span class="number">899</span>&#125;]&#125;,</span><br><span class="line">                 &#123;erl_eval,do_apply,<span class="number">6</span>,[&#123;file,<span class="string">&quot;erl_eval.erl&quot;</span>&#125;,&#123;line,<span class="number">674</span>&#125;]&#125;,</span><br><span class="line">                 &#123;erl_eval,expr,<span class="number">5</span>,[&#123;file,<span class="string">&quot;erl_eval.erl&quot;</span>&#125;,&#123;line,<span class="number">431</span>&#125;]&#125;,</span><br><span class="line">                 &#123;shell,exprs,<span class="number">7</span>,[&#123;file,<span class="string">&quot;shell.erl&quot;</span>&#125;,&#123;line,<span class="number">686</span>&#125;]&#125;,</span><br><span class="line">                 &#123;shell,eval_exprs,<span class="number">7</span>,[&#123;file,<span class="string">&quot;shell.erl&quot;</span>&#125;,&#123;line,<span class="number">641</span>&#125;]&#125;,</span><br><span class="line">                 &#123;shell,eval_loop,<span class="number">3</span>,[&#123;file,<span class="string">&quot;shell.erl&quot;</span>&#125;,&#123;line,<span class="number">626</span>&#125;]&#125;]&#125;&#125;</span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="number">22</span>&gt; throw(test).         </span><br><span class="line">** exception throw: test</span><br><span class="line"><span class="number">23</span>&gt; <span class="keyword">catch</span> throw(test). </span><br><span class="line">test</span><br></pre></td></tr></table></figure></li></ul><h2 id="并发中的异常处理"><a href="#并发中的异常处理" class="headerlink" title="并发中的异常处理"></a>并发中的异常处理</h2><blockquote><p>让其他进程修复错误”和“任其崩溃”</p></blockquote><p>基本思想是用一个进程监视另一个进程，发生错误时修复错误。<br>监视关系有两种，Link和monitor，进程间可以建立link关系，对<strong>进程、端口</strong>和节点的<strong>时间偏移量</strong> 可以建立monitor关系。</p><ul><li>连接（link）<ul><li>link(PidOrPort) -&gt; true</li><li>链接进程退出，收到的是退出信号，这意味着只有<strong>系统进程</strong>能够处理错误，普通进程会<strong>传递退出信号</strong>并一同退出<br>转换为系统进程的函数：process_flag(trap_exit, true)</li></ul></li><li>监视（monitor）<ul><li>monitor(Type :: process, Item :: monitor_process_identifier()) -&gt; MonitorRef</li><li>monitor(Type :: port, Item :: monitor_port_identifier()) -&gt; MonitorRef</li><li>monitor(Type :: time_offset, Item :: clock_service) -&gt; MonitorRef</li><li>监视进程收到的是DOWN<strong>消息</strong>而不是退出信号，通常会被服务器用来监视客户端的行为<br>DOWN信号：{‘DOWN’, Ref, process, Pid2, Reason}</li></ul></li></ul><p>案例</p><ul><li><p>退出时监控者执行某些计算</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">on_exit</span><span class="params">(Pid, Fun)</span> -&gt;</span></span><br><span class="line">spawn(<span class="keyword">fun</span>() -&gt;</span><br><span class="line">Ref = monitor(process, Pid),</span><br><span class="line"><span class="keyword">receive</span></span><br><span class="line">&#123;&#x27;DOWN&#x27;, Ref, process, Pid, Why&#125; -&gt;</span><br><span class="line">Fun(Why)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>).</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建工作者进程</span></span><br><span class="line"><span class="number">2</span>&gt; Fun = <span class="keyword">fun</span>() -&gt;</span><br><span class="line">            <span class="keyword">receive</span></span><br><span class="line">            X -&gt; list_to_atom(X)</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">          <span class="keyword">end</span>.</span><br><span class="line">#Fun&lt;erl_eval.<span class="number">20.118419387</span>&gt;</span><br><span class="line"><span class="number">3</span>&gt; Pid = spawn(Fun).</span><br><span class="line"></span><br><span class="line"><span class="comment">% 监控进程</span></span><br><span class="line"><span class="number">8</span>&gt; tt:on_exit(Pid,<span class="keyword">fun</span>(Why)-&gt;io:format(<span class="string">&quot;~p died with: ~p~n&quot;</span>, [Pid, Why])<span class="keyword">end</span>).</span><br><span class="line">&lt;<span class="number">0.79</span>.<span class="number">0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 使进程发送错误</span></span><br><span class="line"><span class="number">9</span>&gt; Pid ! hello.</span><br><span class="line">&lt;<span class="number">0.64</span>.<span class="number">0</span>&gt; died with: &#123;badarg,[&#123;erlang,list_to_atom,[hello],[]&#125;]&#125;</span><br></pre></td></tr></table></figure></li><li><p>让一组进程共同终止</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">start</span><span class="params">(Fs)</span> -&gt;</span></span><br><span class="line">  spawn(<span class="keyword">fun</span>() -&gt;</span><br><span class="line">    [spawn_link(F) || F &lt;- Fs],</span><br><span class="line">    <span class="keyword">receive</span></span><br><span class="line">    <span class="keyword">after</span></span><br><span class="line">      infinity -&gt; <span class="literal">true</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span>).</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">67</span>&gt;  Fun1 = <span class="keyword">fun</span>()-&gt;<span class="number">1</span><span class="keyword">end</span>.</span><br><span class="line">#Fun&lt;erl_eval.<span class="number">20.118419387</span>&gt;</span><br><span class="line"><span class="number">68</span>&gt; Fun2 = <span class="keyword">fun</span>()-&gt;<span class="number">2</span><span class="keyword">end</span>.</span><br><span class="line">#Fun&lt;erl_eval.<span class="number">20.118419387</span>&gt;</span><br><span class="line"><span class="number">69</span>&gt; Pid=spawn_test:start([Fun1,Fun2]). </span><br><span class="line">&lt;<span class="number">0.231</span>.<span class="number">0</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建永不终止的进程（退出时重启进程）</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">keep_alive</span><span class="params">(Name, Fun)</span> -&gt;</span></span><br><span class="line">register(Name, Pid = spawn(Fun)),</span><br><span class="line">on_exit(Pid, <span class="keyword">fun</span>(_Why) -&gt; keep_alive(Name, Fun) <span class="keyword">end</span>).</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>&gt; tt:keep_alive(worker,Fun).    </span><br><span class="line">&lt;<span class="number">0.64</span>.<span class="number">0</span>&gt;</span><br><span class="line"><span class="number">5</span>&gt; worker!hello.</span><br><span class="line">hello</span><br><span class="line"><span class="number">6</span>&gt;</span><br><span class="line">=ERROR REPORT==== <span class="number">21</span>-Jun-<span class="number">2023</span>::<span class="number">17</span>:<span class="number">35</span>:<span class="number">47</span> ===</span><br><span class="line">Error in process &lt;<span class="number">0.63</span>.<span class="number">0</span>&gt; with exit value:</span><br><span class="line">&#123;badarg,[&#123;erlang,list_to_atom,[hello],[]&#125;]&#125;</span><br><span class="line"><span class="number">6</span>&gt; worker!hello.</span><br><span class="line"></span><br><span class="line"><span class="number">7</span>&gt; worker!hello.</span><br><span class="line">=ERROR REPORT==== <span class="number">21</span>-Jun-<span class="number">2023</span>::<span class="number">17</span>:<span class="number">35</span>:<span class="number">51</span> ===</span><br><span class="line">Error in process &lt;<span class="number">0.69</span>.<span class="number">0</span>&gt; with exit value:</span><br><span class="line">&#123;badarg,[&#123;erlang,list_to_atom,[hello],[]&#125;]&#125;</span><br><span class="line">hello</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2></li></ul><p>TODO</p><h2 id="链接Link"><a href="#链接Link" class="headerlink" title="链接Link"></a>链接Link</h2><p>TODO</p><h2 id="监督Monitor"><a href="#监督Monitor" class="headerlink" title="监督Monitor"></a>监督Monitor</h2><p>TODO</p><h2 id="进程字典"><a href="#进程字典" class="headerlink" title="进程字典"></a>进程字典</h2><p>进程字典是一个属于<strong>本进程</strong>的键值对数据结构，每个进程都存在一个进程区域存放进程字典。</p><ul><li><code>put(Key,value)-&gt;OldValue</code><br>注意会返回旧值</li><li><code>get(Key-&gt;Value)</code></li><li><code>get()-[&#123;Key,Value&#125;]</code></li><li><code>erase(Key)-&gt;Value</code></li><li><code>erase()-&gt;[&#123;Key,Value&#125;]</code><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">7</span>&gt; put(a,<span class="number">1</span>).</span><br><span class="line">undefined</span><br><span class="line"><span class="number">8</span>&gt; get(a).</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">9</span>&gt; put(a,<span class="number">2</span>). </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">10</span>&gt; get().</span><br><span class="line">[&#123;a,<span class="number">2</span>&#125;]</span><br></pre></td></tr></table></figure>注意：进程字典在实际中较少用，因为可能会给程序引入不易察觉的bug（有时会忘记使用了进程字典），让调试变得困难。<br>建议使用进程字典来保存“<strong>一次性写入</strong>”的变量。如果某个键一次性获得一个值而且不会改变它，那么将其保存在进程字典里在某些时候还是可以接受的。</li></ul><h1 id="分布式编程"><a href="#分布式编程" class="headerlink" title="分布式编程"></a>分布式编程</h1><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>分布式erlang以节点为中心，节点是一个命名的ERTS，可以在同一台机器或在不同机器上，许多个节点组成一个分布式系统。</p><ul><li><p>节点命名，在一个分布式系统内，所有节点都必须使用同种命名模式，例如全是短命名，或者全是长命名。</p><ul><li><p>命名格式：<a href="mailto:&#110;&#x61;&#x6d;&#101;&#x40;&#x68;&#111;&#115;&#116;&#46;&#x6e;&#97;&#x6d;&#101;">&#110;&#x61;&#x6d;&#101;&#x40;&#x68;&#111;&#115;&#116;&#46;&#x6e;&#97;&#x6d;&#101;</a></p><ul><li>name为<code>-sname</code>或<code>-name</code>指定的节点名</li><li>host.name为主机标识，例如：”<a href="http://www.example.com&quot;或&quot;server1&quot;/">www.example.com&quot;或&quot;server1&quot;</a><br>配置hostname</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hostname</span><br><span class="line">sudo hostnamectl set-hostname your-new-hostname</span><br><span class="line">sudo systemctl restart NetworkManager</span><br><span class="line">%%</span><br><span class="line">sudo hostname new-hostname</span><br></pre></td></tr></table></figure></li></ul></li><li><p>节点间通信，为了能够相互通信， Erlang 的节点问必须共享一个私密的cookie 值。</p><ul><li><p>本机通信，可以使用短命名</p></li><li><p>局域网通信，可以使用短命名</p></li><li><p>外网通信</p><p>为了找到host，需要配置host文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost</span><br><span class="line">::1         localhost</span><br><span class="line"></span><br><span class="line">192.168.142.129 server.com server</span><br><span class="line">192.168.142.130 client.com client</span><br></pre></td></tr></table></figure></li><li><p>检测连通性<br><code>net_adm:ping(&#39;gandalf@server.com&#39;).</code></p></li></ul></li><li><p>连接节点，采用松散连接的方式，会在第一次用到节点名时连接：spawn(Node,M,F,A) or net_adm:ping(Node)</p></li></ul><p>注意事项：</p><p>hostname必须有点，单独一个server会报错，必须是<a href="http://www.server.com的形式/">www.server.com的形式</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(bilbo@client)1&gt; rpc:call(&#x27;gandalf@server&#x27;, kvs, store, [weather, cold]).</span><br><span class="line">=ERROR REPORT==== 24-Jun-2023::15:57:51.579811 ===</span><br><span class="line">** System running to use fully qualified hostnames **</span><br><span class="line">** Hostname server is illegal **</span><br></pre></td></tr></table></figure><h2 id="防火墙和端口"><a href="#防火墙和端口" class="headerlink" title="防火墙和端口"></a>防火墙和端口</h2><p>关闭防火墙</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure><p>打开所有端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure><h2 id="局域网通信"><a href="#局域网通信" class="headerlink" title="局域网通信"></a>局域网通信</h2><p>服务器</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[hz@server socket_dist]$ erl -name gandalf -setcookie abc</span><br><span class="line">Erlang/OTP <span class="number">25</span> [erts-<span class="number">13.2</span>.<span class="number">1</span>] [source] [<span class="number">64</span>-bit] [smp:<span class="number">4</span>:<span class="number">4</span>] [ds:<span class="number">4</span>:<span class="number">4</span>:<span class="number">10</span>] [async-threads:<span class="number">1</span>] [jit:ns]</span><br><span class="line"></span><br><span class="line">Eshell V13.<span class="number">2.1</span>  (abort with ^G)</span><br><span class="line">(gandalf@server.com)<span class="number">1</span>&gt; kvs:start().</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[hz@client ~]$ erl -name bilbo -setcookie abc</span><br><span class="line">Erlang/OTP 25 [erts-13.2.1] [source] [64-bit] [smp:4:4] [ds:4:4:10] [async-threads:1] [jit:ns]</span><br><span class="line"></span><br><span class="line">Eshell V13.2.1  (abort with ^G)</span><br><span class="line">(bilbo@client.com)1&gt; net_adm:ping(&#x27;gandalf@server.com&#x27;).</span><br><span class="line">pong</span><br><span class="line">(bilbo@client.com)2&gt; rpc:call(&#x27;gandalf@server.com&#x27;, kvs, store, [weather, cold]).</span><br><span class="line">true</span><br><span class="line">(bilbo@client.com)3&gt; rpc:call(&#x27;gandalf@server.com&#x27;, kvs, lookup, [weather]). </span><br><span class="line">&#123;ok,cold&#125;</span><br></pre></td></tr></table></figure><h2 id="外网通信"><a href="#外网通信" class="headerlink" title="外网通信"></a>外网通信</h2><ol><li><p>确保4369端口对TCP和UDP流量，都开放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -L</span><br><span class="line"># 如果防火墙规则中没有针对4369端口的条目，则新增</span><br><span class="line">sudo iptables -A INPUT -p tcp --dport 4369 -j ACCEPT</span><br><span class="line">sudo iptables -A INPUT -p udp --dport 4369 -j ACCEPT</span><br><span class="line"># 让设置生效</span><br><span class="line">sudo yum install iptables-services</span><br><span class="line">sudo systemctl enable iptables</span><br><span class="line">sudo service iptables save</span><br><span class="line"># </span><br><span class="line">sudo iptables -L</span><br></pre></td></tr></table></figure></li><li><p>选择一个或一段连续端口给分布式Erlang使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">erl -name gandalf -setcookie abc -kernel inet_dist_listen_min 1024 \ inet_dist_listen_max 65536</span><br></pre></td></tr></table></figure></li></ol><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3><p>在阿里云的ecs上测试，用net_adm:ping不通，暂不知道是端口还是host设置有问题，待解决。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二进制型与位语法</title>
      <link href="/2023/06/22/%E4%BD%8D%E8%AF%AD%E6%B3%95/"/>
      <url>/2023/06/22/%E4%BD%8D%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>二进制型与位语法（bit-syntax）<span id="more"></span></p><p>[<a href="https://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax">https://www.erlang.org/doc/reference_manual/expressions.html#bit_syntax</a></p><h1 id="二进制型"><a href="#二进制型" class="headerlink" title="二进制型"></a>二进制型</h1><p>二进制型就是由尖括号 <strong>&lt;&lt;** 和 **&gt;&gt;</strong> 包围的整数（0-255）或字符串。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span>&gt; &lt;&lt;<span class="number">1</span>,<span class="string">&quot;abc&quot;</span>&gt;&gt;.     </span><br><span class="line">&lt;&lt;<span class="number">1</span>,<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&gt;&gt;</span><br><span class="line"><span class="number">7</span>&gt; &lt;&lt;<span class="number">256</span>,<span class="string">&quot;abc&quot;</span>&gt;&gt;. </span><br><span class="line">&lt;&lt;<span class="number">0</span>,<span class="number">97</span>,<span class="number">98</span>,<span class="number">99</span>&gt;&gt;</span><br></pre></td></tr></table></figure><p>IoList是包含字符列表和二进制型的列表，可以嵌套来标识复杂的结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5&gt; [&quot;hello&quot;, [32], &lt;&lt;&quot;world&quot;&gt;&gt;].</span><br><span class="line">[&quot;hello&quot;,&quot; &quot;,&lt;&lt;&quot;world&quot;&gt;&gt;]</span><br><span class="line">6&gt; iolist_to_binary([&quot;hello&quot;, [32], &lt;&lt;&quot;world&quot;&gt;&gt;]). </span><br><span class="line">&lt;&lt;&quot;hello world&quot;&gt;&gt;</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/iteye_13453/article/details/82343274">https://blog.csdn.net/iteye_13453/article/details/82343274</a></p><p>BIF</p><ul><li><p>list_to_binary(IoList) -&gt; binary()<br>将IOList拍扁为一个大二进制数据</p></li><li><p>split_binary(Bin, Pos) -&gt; {binary(), binary()}</p></li><li><p>term_to_binary(Term) -&gt; ext_binary()</p></li><li><p>term_to_binary(Term, Options) -&gt; ext_binary()</p></li><li><p>binary_to_term(Binary) -&gt; term()</p></li><li><p>binary_to_term(Binary, Opts) -&gt; term() | {term(), Used}</p></li><li><p>bit_size(Bitstring) -&gt; integer() &gt;= 0<br>返回所占字节数</p></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 创建包含两个字节的二进制</span></span><br><span class="line">&lt;&lt;<span class="number">16</span>, <span class="number">32</span>&gt;&gt;.</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建包含字符 &#x27;A&#x27; 和 &#x27;B&#x27; 的二进制</span></span><br><span class="line">&lt;&lt;<span class="number">65</span>, <span class="number">66</span>&gt;&gt;.</span><br><span class="line">&lt;&lt;$A, $B&gt;&gt;.  <span class="comment">% 使用字符表示</span></span><br><span class="line"><span class="comment">%  &lt;&lt;&quot;abc&quot;&gt;&gt;实际上是 `&lt;&lt;$a,$b,$c&gt;&gt;`的语法糖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建包含字符串 &quot;Hello&quot; 的二进制</span></span><br><span class="line">&lt;&lt;<span class="string">&quot;Hello&quot;</span>&gt;&gt;.</span><br><span class="line"></span><br><span class="line"><span class="comment">% 嵌套二进制</span></span><br><span class="line">&lt;&lt;<span class="number">1</span>, &lt;&lt;<span class="number">2</span>, <span class="number">3</span>&gt;&gt;, <span class="number">4</span>&gt;&gt;.</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建具有变量的二进制</span></span><br><span class="line">Value = <span class="number">42</span>,</span><br><span class="line">&lt;&lt;Value&gt;&gt;.</span><br><span class="line"></span><br><span class="line"><span class="comment">% 创建二进制的部分片段</span></span><br><span class="line">Binary = &lt;&lt;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&gt;&gt;,</span><br><span class="line">SubBinary = &lt;&lt;Binary/binary, <span class="number">3</span>:<span class="number">1</span>&gt;&gt;.  <span class="comment">% 从 Binary 的第 3 字节开始，取 1 字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 对应大于255的整数似乎会截断</span></span><br><span class="line"><span class="number">1</span>&gt; byte_size(&lt;&lt;<span class="number">999999999999999999999999999999999999999999999999999999999999999</span>&gt;&gt;).   </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span>&gt; byte_size(term_to_binary(<span class="number">999999999999999999999999999999999999999999999999999999999999999</span>)). </span><br><span class="line"><span class="number">31</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="number">3</span>&gt; split_binary(list_to_binary(<span class="string">&quot;0123456789&quot;</span>),<span class="number">3</span>). </span><br><span class="line">&#123;&lt;&lt;<span class="string">&quot;012&quot;</span>&gt;&gt;,&lt;&lt;<span class="string">&quot;3456789&quot;</span>&gt;&gt;&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：二进制是<strong>不可变</strong>的数据类型，一旦创建，就不能直接修改其中的字节或位。但可以使用模式匹配和一些函数来提取和处理二进制数据。<br> 操作二进制型，可以使用以下两种方式： </p><ul><li> 内置函数 </li><li> 位语法 </li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%X占3位 Y占7位 Z占6位 共16位</span></span><br><span class="line">M = &lt;&lt;X:<span class="number">3</span>, Y:<span class="number">7</span>, Z:<span class="number">6</span>&gt;&gt;.</span><br><span class="line"></span><br><span class="line">Red=<span class="number">2</span>.</span><br><span class="line">Green=<span class="number">61</span>.</span><br><span class="line">Blue=<span class="number">20</span>.</span><br><span class="line">Mem=&lt;&lt;Red:<span class="number">5</span>,Green:<span class="number">6</span>,Blue:<span class="number">5</span>&gt;&gt;.</span><br><span class="line">&lt;&lt;R1:<span class="number">5</span>,G2:<span class="number">6</span>,B3:<span class="number">5</span>&gt;&gt;=Mem.</span><br><span class="line">binary作为**模式**时，没有指定size的binary必须放在最后，&lt;&lt;Char, Rest/binary&gt;&gt;</span><br><span class="line">用于构造二进制型时，binary可以在任意位置，&lt;&lt;Acc/binary, Char&gt;&gt;</span><br></pre></td></tr></table></figure><p>type还是建议标上，否则容易发生segment的格式错误</p><p>关于位数有以下几种</p><ul><li>bit_size(Bitstring)<br>字节数乘以八</li><li>byte_size(Bitstring)</li><li>iolist_size(Item)</li><li>map_size(Map)</li><li>size(Item) -&gt; integer() &gt;= 0<br>返回字节数</li></ul><h1 id="位语法"><a href="#位语法" class="headerlink" title="位语法"></a>位语法</h1><p>用于从二进制数据里<strong>提取</strong>或<strong>加入</strong>单独的位或者位串，语法如下：</p><p>位串由一系列的段（segment）组成，每个segment用逗号 <strong>,</strong> 分隔。<br>segment的表示如下，size和type是可选的：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;E1,...,En&gt;&gt;</span><br><span class="line"></span><br><span class="line">Ei = Value |</span><br><span class="line">     Value:Size |</span><br><span class="line">     Value/TypeSpecifierList |</span><br><span class="line">     Value:Size/TypeSpecifierList</span><br></pre></td></tr></table></figure><ul><li><p>整数段<br>bit=size*units<br>高位会被截断，<code>&lt;&lt;16#ff:4&gt;&gt;</code>变成<code>&lt;&lt;15:4&gt;&gt;</code></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;<span class="number">1</span>:<span class="number">1</span>, <span class="number">0</span>:<span class="number">7</span>&gt;&gt;.</span><br></pre></td></tr></table></figure></li><li><p>浮点段<br>bits=size*units，size必须是16,32,64<br>构造位串时<br>位串匹配时</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">21</span>&gt; &lt;&lt;<span class="number">3.14159</span>:<span class="number">64</span>/float&gt;&gt;.</span><br><span class="line">&lt;&lt;<span class="number">64</span>,<span class="number">9</span>,<span class="number">33</span>,<span class="number">249</span>,<span class="number">240</span>,<span class="number">27</span>,<span class="number">134</span>,<span class="number">110</span>&gt;&gt;</span><br><span class="line"><span class="number">23</span>&gt; &lt;&lt;<span class="number">3.14159</span>:<span class="number">64</span>/float&gt;&gt; =:= &lt;&lt;<span class="number">3.14159</span>:<span class="number">64</span>/float&gt;&gt;. </span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure></li><li><p>二进制段<br>type可以是binary, bitstring, bytes, and bits任意一种<br>binary类型长度必须是整字节</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt; &lt;&lt;(&lt;&lt;<span class="string">&quot;abc&quot;</span>&gt;&gt;)/bitstring&gt;&gt;.</span><br><span class="line">&lt;&lt;<span class="string">&quot;abc&quot;</span>&gt;&gt;</span><br><span class="line"><span class="number">2</span>&gt; &lt;&lt;(&lt;&lt;<span class="string">&quot;abc&quot;</span>&gt;&gt;)/binary-unit:<span class="number">1</span>&gt;&gt;.</span><br><span class="line">&lt;&lt;<span class="string">&quot;abc&quot;</span>&gt;&gt;</span><br><span class="line"><span class="number">3</span>&gt; &lt;&lt;(&lt;&lt;<span class="string">&quot;abc&quot;</span>&gt;&gt;)/binary&gt;&gt;.</span><br><span class="line">&lt;&lt;<span class="string">&quot;abc&quot;</span>&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>&gt; &lt;&lt;(&lt;&lt;<span class="number">1</span>:<span class="number">1</span>&gt;&gt;)/binary&gt;&gt;.</span><br><span class="line">** exception error: bad argument</span><br><span class="line"><span class="number">2</span>&gt; &lt;&lt;(&lt;&lt;<span class="number">1</span>:<span class="number">1</span>&gt;&gt;)/bitstring&gt;&gt;.</span><br><span class="line">&lt;&lt;<span class="number">1</span>:<span class="number">1</span>&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p>Unicode段<br>type为utf8, utf16, and utf32</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li></ul><p>TODO：具体使用还是不熟悉</p><h1 id="位串"><a href="#位串" class="headerlink" title="位串"></a>位串</h1><p>位串（bitstring），位数不是8的整数倍的二进制型，可用于简化网络编程</p><p>获取size</p><ul><li>bit_size(Bitstring) -&gt; integer() &gt;= 0<br>返回比特数</li><li>byte_size(Bitstring) -&gt; integer() &gt;= 0<br>返回字节数</li><li>size(Item) -&gt; integer() &gt;= 0<br>获取元组或binary中的字节数</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>erlang运行过程</title>
      <link href="/2023/06/22/Erlang%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/06/22/Erlang%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>erlang的编译运行过程</p><span id="more"></span><p><a href="https://www.erlang.org/doc/apps/kernel/users_guide.html">https://www.erlang.org/doc/apps/kernel/users_guide.html</a><br><a href="https://www.erlang.org/doc/apps/erts/users_guide.html">https://www.erlang.org/doc/apps/erts/users_guide.html</a><br><a href="https://www.erlang.org/doc/man/code.html">https://www.erlang.org/doc/man/code.html</a></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p><a href="https://www.erlang.org/doc/apps/compiler/internal_docs.html">https://www.erlang.org/doc/apps/compiler/internal_docs.html</a></p><h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p><a href="https://www.erlang.org/doc/reference_manual/modules.html">https://www.erlang.org/doc/reference_manual/modules.html</a></p><p>模块是编译的最小单位</p><ul><li>预定义模块属性，需要放在函数定义前<ul><li>-compile(Options).</li><li>-vsn(Vsn)</li><li>-on_load(Function)</li><li>-nifs(Functions)</li></ul></li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-export</span><span class="params">([start_link/<span class="number">0</span>, stop/<span class="number">0</span>])</span>.</span><br></pre></td></tr></table></figure><ul><li>行为属性，指定本模块是一个行为的回调模块</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-behaviour</span><span class="params">(gen_server)</span>.</span><br></pre></td></tr></table></figure><ul><li>定义记录</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-record</span><span class="params">(Record,Fields)</span>.</span><br></pre></td></tr></table></figure><ul><li>预处理器</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-include</span><span class="params">(<span class="string">&quot;SomeFile.hrl&quot;</span>)</span>.</span><br><span class="line"><span class="keyword">-define</span><span class="params">(Macro,Replacement)</span>.</span><br></pre></td></tr></table></figure><ul><li>设置预定义宏<code>?FILE</code>和<code>LINE</code></li></ul><p>用于获取当前代码所在源文件路径和行数</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">-module</span><span class="params">(example)</span>.</span><br><span class="line"><span class="keyword">-export</span><span class="params">([test/<span class="number">0</span>])</span>.</span><br><span class="line"><span class="function"><span class="title">test</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;This code is in file ~p\n&quot;</span>, [?FILE]),</span><br><span class="line">  io:format(<span class="string">&quot;This code is on line ~p\n&quot;</span>, [?LINE]).</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span>&gt; test:t().</span><br><span class="line">This code is in file <span class="string">&quot;test.erl&quot;</span></span><br><span class="line">This code is on line <span class="number">18</span></span><br><span class="line">ok</span><br></pre></td></tr></table></figure><p>获取模块信息</p><ul><li>Module:module_info/0<br>获取全部</li><li>Module:module_info/1<br>获取指定</li></ul><p>既可以在内部调用，也可以在外部调用</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">test</span><span class="params">()</span> -&gt;</span></span><br><span class="line">  io:format(<span class="string">&quot;module_info(): ~w~n&quot;</span>, [module_info()]),</span><br><span class="line">  io:format(<span class="string">&quot;module_info(exports): ~w~n&quot;</span>, [module_info(exports)]).</span><br></pre></td></tr></table></figure><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>&gt; test:test().</span><br><span class="line"><span class="function"><span class="title">module_info</span><span class="params">()</span>: [&#123;<span class="title">module</span>,<span class="title">test</span>&#125;,&#123;<span class="title">exports</span>,[&#123;<span class="title">t</span>,0&#125;,&#123;<span class="title">module_info</span>,0&#125;,&#123;<span class="title">module_info</span>,1&#125;]&#125;,&#123;<span class="title">attributes</span>,[&#123;<span class="title">vsn</span>,[143092041070811311060369436838556452033]&#125;,&#123;<span class="title">author</span>,[104,122]&#125;]&#125;,&#123;<span class="title">compile</span>,[&#123;<span class="title">options</span>,[]&#125;</span></span><br><span class="line"><span class="function">,&#123;<span class="title">version</span>,[55,46,48,46,52]&#125;,&#123;<span class="title">source</span>,[99,58,47,85,115,101,114,115,47,104,122,47,68,101,115,107,116,111,112,47,69,114,108,97,110,103,80,114,111,106,101,99,116,47,108,101,97,114,110,45,10</span></span><br><span class="line"><span class="function">1,114,108,97,110,103,47,116,101,115,116,46,101,114,108]&#125;]&#125;,&#123;<span class="title">md5</span>,&lt;&lt;107,166,134,80,200,224,177,195,62,104,95,214,83,233,196,193&gt;&gt;&#125;]</span></span><br><span class="line"><span class="function"><span class="title">module_info</span><span class="params">(exports)</span>: [&#123;<span class="title">t</span>,0&#125;,&#123;<span class="title">module_info</span>,0&#125;,&#123;<span class="title">module_info</span>,1&#125;]</span></span><br><span class="line"><span class="function">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span></span><br><span class="line"><span class="function">14&gt; <span class="title">test</span>:<span class="title">module_info</span><span class="params">()</span>.</span></span><br><span class="line"><span class="function">[&#123;<span class="title">module</span>,<span class="title">test</span>&#125;,</span></span><br><span class="line"><span class="function"> &#123;<span class="title">exports</span>,[&#123;<span class="title">t</span>,0&#125;,&#123;<span class="title">module_info</span>,0&#125;,&#123;<span class="title">module_info</span>,1&#125;]&#125;,</span></span><br><span class="line"><span class="function"> &#123;<span class="title">attributes</span>,[&#123;<span class="title">vsn</span>,[143092041070811311060369436838556452033]&#125;,</span></span><br><span class="line"><span class="function">              &#123;<span class="title">author</span>,&quot;<span class="title">hz</span>&quot;&#125;]&#125;,</span></span><br><span class="line"><span class="function"> &#123;<span class="title">compile</span>,[&#123;<span class="title">options</span>,[]&#125;,</span></span><br><span class="line"><span class="function">           &#123;<span class="title">version</span>,&quot;7.0.4&quot;&#125;,</span></span><br><span class="line"><span class="function">           &#123;<span class="title">source</span>,&quot;<span class="title">c</span>:/U<span class="title">sers</span>/<span class="title">hz</span>/D<span class="title">esktop</span>/E<span class="title">rlangProject</span>/<span class="title">learn</span>-<span class="title">erlang</span>/<span class="title">test</span>.<span class="title">erl</span>&quot;&#125;]&#125;,</span></span><br><span class="line"><span class="function"> &#123;<span class="title">md5</span>,&lt;&lt;107,166,134,80,200,224,177,195,62,104,95,214,83,</span></span><br><span class="line"><span class="function">        233,196,193&gt;&gt;&#125;]</span></span><br></pre></td></tr></table></figure><p>其他接口</p><ul><li>code: get_object_code(Module) -&gt; {Module, Binary, Filename} | error<br>获取指定模块的BEAM字节码</li><li>which(Module) -&gt; Which<br>获取指定模块的文件路径</li></ul><h2 id="Compile-Server"><a href="#Compile-Server" class="headerlink" title="Compile Server"></a>Compile Server</h2><p>编译服务器可以避免为每个要编译的文件启动 Erlang 系统，从而潜在地加速多文件项目的构建。是否会加快构建速度取决于项目的性质和构建机器。</p><p>默认情况下编译服务器是关闭的，需要用指定 -server选项或者把环境变量ERLC_USE_SERVER 设置为yes or true</p><h1 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h1><h2 id="Code-Server"><a href="#Code-Server" class="headerlink" title="Code Server"></a>Code Server</h2><p>Code Server负责将已编译的代码加载到运行时系统（ERTS）中。</p><h2 id="ERTS启动模式"><a href="#ERTS启动模式" class="headerlink" title="ERTS启动模式"></a>ERTS启动模式</h2><p>有interactive和embedded两种启动方式</p><ul><li>interactive，启动时加载ERTS需要的模块，其他代码使用时在搜索路径尝试搜索和加载</li><li>embedded，不会自动加载代码，使用引导脚本加载全部模块时使用这种方式启动。</li></ul><p>可以看到embedded模式下搜索路径只有kernel和stdlib。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">erl -mode embedded </span><br><span class="line"><span class="number">1</span>&gt; code:get_path().</span><br><span class="line">[<span class="string">&quot;c:/Program Files/erl8.3/lib/kernel-5.2/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/stdlib-3.3/ebin&quot;</span>]</span><br><span class="line"></span><br><span class="line">erl -mode interactive </span><br><span class="line"><span class="number">1</span>&gt; code:get_path().</span><br><span class="line">[<span class="string">&quot;.&quot;</span>,<span class="string">&quot;c:/Program Files/erl8.3/lib/kernel-5.2/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/stdlib-3.3/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/xmerl-1.3.13/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/wx-1.8/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/typer-0.9.12/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/tools-2.9.1/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/syntax_tools-2.1.1/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/ssl-8.1.1/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/ssh-4.4.1/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/snmp-5.2.5/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/sasl-3.0.3/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/runtime_tools-1.11.1/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/reltool-0.7.3/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/public_key-1.4/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/percept-0.9/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/parsetools-2.1.4/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/otp_mibs-1.1.1/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/os_mon-2.4.2/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/orber-3.8.2/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/odbc-2.12/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/mnesia-4.14.3/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/megaco-3.18.1/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/jinterface-1.7.1/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/inets-6.3.6/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/ic-4.4.2/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/hipe-3.15.4/ebin&quot;</span>,</span><br><span class="line"> [...]|...]</span><br></pre></td></tr></table></figure><h2 id="搜索路径"><a href="#搜索路径" class="headerlink" title="搜索路径"></a>搜索路径</h2><p>interactive模式下Code Server维护一个搜索路径，称为<strong>code path，</strong>用于实现代码的按需加载。<br>添加路径的方式</p><ul><li>add_patha(Dir) -&gt; add_path_ret()<br>向载入路径的开头添加一个新目录Dir</li><li>add_pathz(Dir) -&gt; add_path_ret()<br>向载入路径的末端添加一个新目录Dir</li></ul><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>&gt; code:get_path().</span><br><span class="line">[<span class="string">&quot;c:/Program Files/erl8.3/lib/kernel-5.2/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/stdlib-3.3/ebin&quot;</span>]</span><br><span class="line"><span class="number">2</span>&gt; code:add_patha(<span class="string">&quot;.&quot;</span>).</span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="number">3</span>&gt; code:get_path().     </span><br><span class="line">[<span class="string">&quot;.&quot;</span>,<span class="string">&quot;c:/Program Files/erl8.3/lib/kernel-5.2/ebin&quot;</span>,</span><br><span class="line"> <span class="string">&quot;c:/Program Files/erl8.3/lib/stdlib-3.3/ebin&quot;</span>]</span><br></pre></td></tr></table></figure><h2 id="热更新（动态代码载入）"><a href="#热更新（动态代码载入）" class="headerlink" title="热更新（动态代码载入）"></a>热更新（动态代码载入）</h2><h3 id="热更新简介"><a href="#热更新简介" class="headerlink" title="热更新简介"></a>热更新简介</h3><p>a是主模块，b是被调用的回调模块<br><code>a.erl</code></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">start</span><span class="params">(Tag)</span> -&gt;</span></span><br><span class="line">spawn(<span class="keyword">fun</span>()-&gt;loop(Tag)<span class="keyword">end</span>).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">loop</span><span class="params">(Tag)</span> -&gt;</span></span><br><span class="line">sleep(),</span><br><span class="line">Val = b:get_value(),</span><br><span class="line">io:format(<span class="string">&quot;Vsn1 (~p) Val is ~p~n&quot;</span>,[Tag, Val]),</span><br><span class="line">loop(Tag).</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">sleep</span><span class="params">()</span> -&gt;</span> <span class="keyword">receive</span></span><br><span class="line"> <span class="keyword">after</span></span><br><span class="line"> <span class="number">3000</span> -&gt;</span><br><span class="line"> ok</span><br><span class="line"> <span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p><code>b.erl</code></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">get_value</span><span class="params">()</span> -&gt;</span></span><br><span class="line"><span class="number">1</span>.</span><br></pre></td></tr></table></figure><p>实验1<br>把b模块get_value返回值改为9，<strong>回调模块重新编译，旧程序会调用新的函数</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>&gt; a:start(one).</span><br><span class="line">&lt;<span class="number">0.67</span>.<span class="number">0</span>&gt;</span><br><span class="line"><span class="number">4</span>&gt; Vsn1 (one) Val is <span class="number">1</span></span><br><span class="line"><span class="number">4</span>&gt; Vsn1 (one) Val is <span class="number">1</span></span><br><span class="line"><span class="number">5</span>&gt; Vsn1 (one) Val is <span class="number">9</span></span><br></pre></td></tr></table></figure><p>实验2<br>把a模块中loop中的Vsn1改为Vsn2，<strong>主模块重新编译启动，两个程序同时存在</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>&gt; c(a).</span><br><span class="line"><span class="number">6</span>&gt; a:start(two).</span><br><span class="line">&lt;<span class="number">0.79</span>.<span class="number">0</span>&gt;</span><br><span class="line"><span class="number">7</span>&gt; Vsn1 (one) Val is <span class="number">9</span></span><br><span class="line"><span class="number">7</span>&gt; Vsn2 (two) Val is <span class="number">9</span></span><br></pre></td></tr></table></figure><p>实验3<br>把a模块中loop中的Vsn2改为Vsn3，<strong>主模块再次重新编译启动，Vsn1已经消失，即只会存在两个版本的程序，添加第三个以后的版本会终止第一个版本的程序</strong></p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span>&gt; c(a).</span><br><span class="line"><span class="number">9</span>&gt; a:start(two).</span><br><span class="line">&lt;<span class="number">0.86</span>.<span class="number">0</span>&gt;</span><br><span class="line"><span class="number">9</span>&gt; Vsn2 (two) Val is <span class="number">9</span></span><br><span class="line"><span class="number">9</span>&gt; Vsn3 (three) Val is <span class="number">9</span></span><br></pre></td></tr></table></figure><h3 id="热更新原理"><a href="#热更新原理" class="headerlink" title="热更新原理"></a>热更新原理</h3><p>TODO</p><h1 id="编译和运行程序"><a href="#编译和运行程序" class="headerlink" title="编译和运行程序"></a>编译和运行程序</h1><ol><li> Erlang shell中编译运行 </li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c(hello).</span><br><span class="line">hello:hello().</span><br></pre></td></tr></table></figure><ol start="2"><li>命令行中编译运行 </li></ol><ul><li><ul><li>-noshell 以不带交互式shell的方式启动Erlang（因此不会看到Erlang的“徽标”，也就是通常系统启动时首先显示的那些信息）。</li></ul></li><li><ul><li>-s hello start 运行hello:start()函数。注意：使用-s Mod …选项时，Mod必须是已编译的。</li></ul></li><li><ul><li>-s init stop 在之前的命令完成后执行init:stop()函数，从而停止系统。</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">erlc hello.erl</span><br><span class="line">erl -noshell -s hello start -s init stop</span><br></pre></td></tr></table></figure><ol start="3"><li>作为Escript运行 </li></ol><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env escript</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">main</span><span class="params">(Args)</span>-&gt;</span></span><br><span class="line">    io:format(<span class="string">&quot;hello world ~n&quot;</span>).</span><br></pre></td></tr></table></figure><h1 id="erl和erlc使用"><a href="#erl和erlc使用" class="headerlink" title="erl和erlc使用"></a>erl和erlc使用</h1><h2 id="erl"><a href="#erl" class="headerlink" title="erl"></a>erl</h2><p><a href="https://www.erlang.org/doc/man/erl.html">Erlang – erl</a></p><p><strong>emulator flags</strong></p><p>+开头，模拟器选项，指定一些，如异步线程池中线程的建议堆栈大小、ETS表数量上限等。</p><p><strong>flags</strong></p><p>传入ERTS中的init系统进程</p><p><strong>plain arguments</strong>:</p><p>也传入到init进程中，不会以任何方式解析，可以用<code>init:get_plain_arguments/0 </code>获取，个人理解是作为类似常量的方式使用。</p><ul><li>-noshell </li><li>-pa<br>将指定目录加入到搜索路径</li><li>-s Mod [Func [Arg1, Arg2, …]] (init flag)<br>初始化要处理MFA，例如 <code>-s z_compile compile_change ../boot/Emakefile</code> 表示让init进程调用z_compile模块的compile_change/1 方法，参数为一个Emakefile文件位置</li></ul><h2 id="erlc"><a href="#erlc" class="headerlink" title="erlc"></a>erlc</h2><p>TODO</p><h1 id="Erts"><a href="#Erts" class="headerlink" title="Erts"></a>Erts</h1><p>TODO</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> erlang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> erlang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统监控</title>
      <link href="/2023/06/22/Linux%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/"/>
      <url>/2023/06/22/Linux%E7%B3%BB%E7%BB%9F%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<p>Linux中系统监控的工具，进程、IO、网络等。</p><span id="more"></span><h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><h3 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h3><ul><li><p>ps：显示当前所有<strong>进程</strong>的运行情况。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ ps</span><br><span class="line">  PID TTY          TIME CMD</span><br><span class="line">13316 pts/0    00:00:00 bash</span><br><span class="line">16999 pts/0    00:00:00 ps</span><br></pre></td></tr></table></figure></li><li><p>top：<strong>实时显示</strong>当前所有<strong>任务</strong>的资源占用情况。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                                </span><br><span class="line"> 1173 root      10 -10  166140  49928  10452 S   1.7  2.8   2:24.79 AliYunDunMonito                                                                        </span><br><span class="line">13233 hz        20   0  709408  46020  15864 S   1.0  2.6   0:06.84 node                                                                                   </span><br><span class="line"> 1109 root      20   0  815440  14616   7292 S   0.3  0.8   0:08.32 aliyun-service                                                                         </span><br><span class="line">    1 root      20   0   43628   4000   2600 S   0.0  0.2   0:00.77 systemd                                                                                </span><br><span class="line">    2 root      20   0       0      0      0 S   0.0  0.0   0:00.00 kthreadd                                                                               </span><br><span class="line">    4 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H                                                                           </span><br><span class="line">    6 root      20   0       0      0      0 S   0.0  0.0   0:00.12 ksoftirqd/0             </span><br></pre></td></tr></table></figure></li><li><p>pstree 以树状的模式输出进程列表，该模式显示了进程间的父/子关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ pstree</span><br><span class="line">systemd─┬─AliYunDun───9*[&#123;AliYunDun&#125;]</span><br><span class="line">        ├─AliYunDunMonito───25*[&#123;AliYunDunMonito&#125;]</span><br><span class="line">        ├─AliYunDunUpdate───6*[&#123;AliYunDunUpdate&#125;]</span><br><span class="line">        ├─2*[agetty]</span><br><span class="line">        ├─aliyun-service───7*[&#123;aliyun-service&#125;]</span><br><span class="line">        ├─assist_daemon───7*[&#123;assist_daemon&#125;]</span><br><span class="line">        ├─atd</span><br><span class="line">        ├─auditd───&#123;auditd&#125;</span><br><span class="line">        ├─chronyd</span><br><span class="line">        ├─crond</span><br><span class="line">        ├─dbus-daemon</span><br><span class="line">        ├─dhclient</span><br><span class="line">        ├─epmd</span><br><span class="line">        ├─gssproxy───5*[&#123;gssproxy&#125;]</span><br><span class="line">        ├─master─┬─pickup</span><br><span class="line">        │        └─qmgr</span><br><span class="line">        ├─polkitd───6*[&#123;polkitd&#125;]</span><br><span class="line">        ├─rpcbind</span><br><span class="line">        ├─rsyslogd───2*[&#123;rsyslogd&#125;]</span><br><span class="line">        ├─sshd───sshd───sshd───bash─┬─sh───node─┬─node─┬─bash─┬─pstree</span><br><span class="line">        │                           │           │      │      └─python3</span><br><span class="line">        │                           │           │      ├─bash</span><br><span class="line">        │                           │           │      └─12*[&#123;node&#125;]</span><br><span class="line">        │                           │           ├─node─┬─node───6*[&#123;node&#125;]</span><br><span class="line">        │                           │           │      └─11*[&#123;node&#125;]</span><br><span class="line">        │                           │           ├─node───12*[&#123;node&#125;]</span><br><span class="line">        │                           │           └─10*[&#123;node&#125;]</span><br><span class="line">        │                           └─sleep</span><br><span class="line">        ├─systemd-journal</span><br><span class="line">        ├─systemd-logind</span><br><span class="line">        ├─systemd-udevd</span><br><span class="line">        └─tuned───4*[&#123;tuned&#125;]</span><br></pre></td></tr></table></figure></li><li><p>vmstat<br>虚拟内存统计，报告有关进程、内存、分页、块 IO、中断和 CPU 活动等信息。<br>如果想要持续查看输出，可以在命令后面加上一个间隔时间（以秒为单位），命令将按照间隔时间来动态更新显示的内容（比如，vmstat 5）。按下Ctrl-C键可以终止输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ vmstat 5</span><br><span class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 1  0      0 158636  49584 1228320    0    0    38    52  936 1747  2  1 98  0  0</span><br></pre></td></tr></table></figure></li><li><p>jobs：列出所有活动作业的状态信息。</p></li></ul><h3 id="控制进程"><a href="#控制进程" class="headerlink" title="控制进程"></a>控制进程</h3><h4 id="暂停和中断进程"><a href="#暂停和中断进程" class="headerlink" title="暂停和中断进程"></a>暂停和中断进程</h4><p>按下<strong>Ctrl-Z</strong>键，程序将会暂停，此时可以用fg和bg让其继续工作。</p><p>在终端里按下<strong>Ctrl-C</strong>键将会中断（interrupt）一个程序，它意味着我们委婉地<strong>请求程序结束</strong>。许多（但不是所有）命令行程序都可以使用这种方法来实现中断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ jobs</span><br><span class="line">[hz@aliyun erlang-project]$ python3</span><br><span class="line">Python 3.6.8 (default, Nov 16 2020, 16:55:22) </span><br><span class="line">[GCC 4.8.5 20150623 (Red Hat 4.8.5-44)] on linux</span><br><span class="line">Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">[1]+  Stopped                 python3</span><br><span class="line">[hz@aliyun erlang-project]$ jobs</span><br><span class="line">[1]+  Stopped                 python3</span><br></pre></td></tr></table></figure><h4 id="使进程后台运行"><a href="#使进程后台运行" class="headerlink" title="使进程后台运行"></a>使进程后台运行</h4><p>在命令后面加上和号字符（&amp;）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gedit &amp;</span><br></pre></td></tr></table></figure><h4 id="使进程回到前台运行"><a href="#使进程回到前台运行" class="headerlink" title="使进程回到前台运行"></a>使进程回到前台运行</h4><p>使用fg设置在前台中运行作业，要用到作业编号（jobspec选项），一般先用jobs命令查看挂起的进程的作业号，再用fg命令使其运行</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fg</span> %1</span><br></pre></td></tr></table></figure><h4 id="在后台运行"><a href="#在后台运行" class="headerlink" title="在后台运行"></a>在后台运行</h4><p>此时可以用fg命令设置在前台中运行作业，也可以用bg命令设置在后台中运行作业。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bg</span> %1</span><br></pre></td></tr></table></figure><h2 id="IO相关"><a href="#IO相关" class="headerlink" title="IO相关"></a>IO相关</h2><ul><li><p>iostat CPU 的使用情况，以及设备、分区和网络文件系统（NFS）的 IO 统计信息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ iostat </span><br><span class="line">Linux 3.10.0-1160.90.1.el7.x86_64 (aliyun.ecs)  06/24/2023      _x86_64_        (2 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           1.58    0.00    0.60    0.06    0.00   97.76</span><br><span class="line"></span><br><span class="line">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line">vda               5.12        68.74        95.46     593791     824644</span><br></pre></td></tr></table></figure></li><li><p>iotop 命令利用 Linux 内核监控 I/O 使用情况，它按进程或线程的顺序显示 I/O 使用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> sudo iotop</span><br><span class="line"> </span><br><span class="line"> TID  PRIO  USER     DISK READ  DISK WRITE  SWAPIN     IO&gt;    COMMAND                                                                                     </span><br><span class="line">13312 be/4 hz          0.00 B/s    0.00 B/s  0.00 %  0.00 % node /home/hz/.vscode-server/bin/97dec172d3256f~onServerMain --node-ipc --clientProcessId=13267</span><br><span class="line">    1 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % systemd --switched-root --system --deserialize 22</span><br><span class="line">    2 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kthreadd]</span><br><span class="line">13315 be/4 hz          0.00 B/s    0.00 B/s  0.00 %  0.00 % node /home/hz/.vscode-server/bin/97dec172d3256f~onServerMain --node-ipc --clientProcessId=13267</span><br><span class="line">    4 be/0 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [kworker/0:0H]</span><br><span class="line"> 1029 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % python2 -Es /usr/sbin/tuned -l -P</span><br><span class="line">    6 be/4 root        0.00 B/s    0.00 B/s  0.00 %  0.00 % [ksoftirqd/0]</span><br></pre></td></tr></table></figure></li></ul><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><ul><li><p>ping：向网络主机发送ICMP ECHO_REQUEST数据包。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ ping youkia.com</span><br><span class="line">PING youkia.com (117.78.38.96) 56(84) bytes of data.</span><br><span class="line">64 bytes from ecs-117-78-38-96.compute.hwclouds-dns.com (117.78.38.96): icmp_seq=1 ttl=46 time=55.3 ms</span><br><span class="line">64 bytes from ecs-117-78-38-96.compute.hwclouds-dns.com (117.78.38.96): icmp_seq=2 ttl=46 time=55.3 ms</span><br><span class="line">64 bytes from ecs-117-78-38-96.compute.hwclouds-dns.com (117.78.38.96): icmp_seq=3 ttl=46 time=55.3 ms</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li><li><p>traceroute：显示数据包到网络主机的路由路径。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ traceroute youkia.com</span><br><span class="line">traceroute to youkia.com (117.78.38.96), 30 hops max, 60 byte packets</span><br><span class="line"> 1  11.63.116.46 (11.63.116.46)  1.122 ms  1.124 ms  1.137 ms</span><br><span class="line"> 2  11.63.116.113 (11.63.116.113)  1.233 ms 10.124.228.125 (10.124.228.125)  1.290 ms 10.124.228.81 (10.124.228.81)  1.281 ms</span><br><span class="line"> 3  11.88.168.49 (11.88.168.49)  1.557 ms 11.48.239.121 (11.48.239.121)  1.137 ms 11.48.239.197 (11.48.239.197)  0.825 ms</span><br><span class="line"> 4  45.112.220.65 (45.112.220.65)  1.807 ms 45.112.220.89 (45.112.220.89)  1.356 ms 45.112.220.13 (45.112.220.13)  1.865 ms</span><br><span class="line"> 5  117.49.54.102 (117.49.54.102)  9.292 ms  9.277 ms 117.49.54.50 (117.49.54.50)  5.757 ms</span><br><span class="line"> 6  11.94.166.53 (11.94.166.53)  45.763 ms * 11.94.136.185 (11.94.136.185)  60.216 ms</span><br><span class="line"> 7  45.112.223.250 (45.112.223.250)  50.328 ms 10.102.154.246 (10.102.154.246)  41.797 ms 45.112.216.34 (45.112.216.34)  44.119 ms</span><br><span class="line"> 8  103.216.40.49 (103.216.40.49)  43.525 ms  43.945 ms  43.536 ms</span><br></pre></td></tr></table></figure></li><li><p>netstat：显示网络连接、路由表、网络接口数据、伪连接以及多点传送成员等信息。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ netstat -ie</span><br><span class="line">Kernel Interface table</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.173.142  netmask 255.255.240.0  broadcast 172.17.175.255</span><br><span class="line">        inet6 fe80::216:3eff:fe0d:5a2f  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:16:3e:0d:5a:2f  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 24134  bytes 7211877 (6.8 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 24984  bytes 14476371 (13.8 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 28338  bytes 5183587 (4.9 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 28338  bytes 5183587 (4.9 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>ss 获取套接字统计信息，可以显示类似于 netstat 的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 显示所有 TCP 或 UDP 套接字</span><br><span class="line">[hz@aliyun erlang-project]$ ss -t -a</span><br><span class="line">State       Recv-Q Send-Q                              Local Address:Port                                               Peer Address:Port                </span><br><span class="line">LISTEN      0      128                                             *:sunrpc                                                        *:*                    </span><br><span class="line">LISTEN      0      128                                             *:epmd                                                          *:*                   </span><br></pre></td></tr></table></figure></li><li><p>tcpdump</p><ul><li><p><strong>-i</strong> : 选择要捕获的接口，通常是以太网卡或无线网卡，也可以是 <code>vlan</code> 或其他特殊接口。如果该系统上只有一个网络接口，则无需指定。<br>注意：当是本机内部通信时, 走的是lo，此时是抓不到包的，必须指定网卡。</p></li><li><p><strong>-nn</strong> : 单个 n 表示不解析域名，直接显示 IP；两个 n 表示不解析域名和端口。这样不仅方便查看 IP 和端口号，而且在抓取大量数据时非常高效，因为域名解析会降低抓取速度。</p></li><li><p><strong>-s0</strong> : tcpdump 默认只会截取前 <code>96</code> 字节的内容，要想截取所有的报文内容，可以使用 <code>-s number</code>， <code>number</code> 就是你要截取的报文字节数，如果是 0 的话，表示截取报文全部内容。</p></li><li><p><strong>-v</strong> : 使用 <code>-v</code>，<code>-vv</code> 和 <code>-vvv</code> 来显示更多的详细信息，通常会显示更多与特定协议相关的信息。</p></li><li><p><code>port 80</code> : 这是一个常见的端口过滤器，表示仅抓取 <code>80</code> 端口上的流量，通常是 HTTP。</p></li><li><p>-A 以 ASCII 格式打印每个数据包</p></li></ul></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i eth0 -nn -s0 -v port 80</span><br><span class="line">tcpdump -A -s0 port 80 <span class="comment"># 以ASCII字符串 打印数据包</span></span><br><span class="line">tcpdump -i eth0 udp <span class="comment"># 指定协议</span></span><br><span class="line">tcpdump -i eth0 proto 17 <span class="comment"># 同上一条命令</span></span><br><span class="line">tcpdump -i eth0 -s0 -w test.pcap <span class="comment"># 写入文件</span></span><br><span class="line">tcpdump -i eth0 -s0 -l port 80 | grep <span class="string">&#x27;Server:&#x27;</span> <span class="comment"># 要实时将抓取到的数据通过管道传递给其他工具来处理 需要使用行缓冲模式</span></span><br></pre></td></tr></table></figure><ul><li><p>过滤器</p><ul><li><p>过滤host</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcpdump host 1.2.3.4 # 指定主机 </span><br><span class="line">tcpdump -i eth0 dst 10.10.1.20 # src和dst是可选项=</span><br></pre></td></tr></table></figure></li><li><p>过滤网段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tcpdump net 192.168.1 # 三元组 192.168.1.x 发出或发往</span><br><span class="line">tcpdump src net 10 # 一元组 表示子网掩码255.0.0.0</span><br><span class="line"># 二元组 255.255.0.0</span><br><span class="line"># 四元组 某主机</span><br><span class="line">tcpdump src net 172.16.0.0/12 # CIDR</span><br></pre></td></tr></table></figure></li><li><p>过滤协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -n proto \\icmp# 保留字用双斜杠</span><br></pre></td></tr></table></figure></li><li><p>过滤端口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump port 389</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="综合工具"><a href="#综合工具" class="headerlink" title="综合工具"></a>综合工具</h2><ul><li><p>dstat 显示 CPU 使用率、内存使用率、磁盘 I/O、网络流量等系统资源的情况</p><ul><li>-l ：显示负载统计量</li><li>-m ：显示内存使用率（包括used，buffer，cache，free值）</li><li>-r ：显示I/O统计</li><li>-s ：显示交换分区使用情况</li><li>-t ：将当前时间显示在第一行</li><li>–fs ：显示文件系统统计数据（包括文件总数量和inodes值）</li><li>–nocolor ：不显示颜色（有时候有用）</li><li>–socket ：显示网络统计数据</li><li>–tcp ：显示常用的TCP统计</li><li>–udp ：显示监听的UDP接口及其当前用量的一些动态数据</li><li>附带插件<ul><li>-–disk-util ：显示某一时间磁盘的忙碌状况</li><li>-–freespace ：显示当前磁盘空间使用率</li><li>-–proc-count ：显示正在运行的程序数量</li><li>-–top-bio ：指出块I/O最大的进程</li><li>-–top-cpu ：图形化显示CPU占用最大的进程</li><li>-–top-io ：显示正常I/O最大的进程</li><li>-–top-mem ：显示占用最多内存的进程</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[hz@aliyun erlang-project]$ dstat</span><br><span class="line">You did not select any stats, using -cdngy by default.</span><br><span class="line">----total-cpu-usage---- -dsk/total- -net/total- ---paging-- ---system--</span><br><span class="line">usr sys idl wai hiq siq| read  writ| recv  send|  in   out | int   csw </span><br><span class="line">  2   1  98   0   0   0|  71k   98k|   0     0 |   0     0 |1851  3457 </span><br><span class="line">  1   1  98   0   0   0|   0     0 | 840B 3842B|   0     0 |2021  3567 </span><br><span class="line">  1   1  98   0   0   0|   0     0 | 120B  260B|   0     0 |1854  3420 </span><br><span class="line">  2   1  97   0   0   0|   0     0 | 460B  500B|   0     0 |1955  3532 </span><br><span class="line">  1   1  99   0   0   0|   0     0 | 120B  122B|   0     0 |1798  3296 </span><br><span class="line"> </span><br><span class="line"># 监控swap，process，sockets，filesystem并显示监控的时间</span><br><span class="line">[hz@aliyun erlang-project]$ dstat -tsp --socket --fs</span><br><span class="line">----system---- ----swap--- ---procs--- ------sockets------ --filesystem-</span><br><span class="line">     time     | used  free|run blk new|tot tcp udp raw frg|files  inodes</span><br><span class="line">24-06 23:39:21|   0     0 |0.0   0 5.5|223  11   4   0   0| 1280  49802 </span><br><span class="line">24-06 23:39:22|   0     0 |  0   0 8.0|229  11   4   0   0| 1344  49823 </span><br><span class="line">24-06 23:39:23|   0     0 |  0   0 7.0|223  11   4   0   0| 1344  49804 </span><br><span class="line">24-06 23:39:24|   0     0 |  0   0   0|223  11   4   0   0| 1344  49804 ^C</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 Hexo 和 Github Pages 搭建博客</title>
      <link href="/2021/07/22/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/07/22/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>首先需要安装 node.js 和 git，网上有安装教程</p><p><strong>使用Hexo的常用命令先放在开头</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo s <span class="comment"># 调试</span></span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">hexo clean &amp;&amp; hexo deploy <span class="comment"># 发布</span></span><br><span class="line"> <span class="comment"># 新建一博客</span></span><br></pre></td></tr></table></figure><hr><p>正式开始开始搭建博客 <span id="more"></span></p><h2 id="Hexo本地设置"><a href="#Hexo本地设置" class="headerlink" title="Hexo本地设置"></a>Hexo本地设置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br><span class="line">hexo clean   <span class="comment">#清除缓存文件 db.json 和已生成的静态文件 public</span></span><br><span class="line">hexo g       <span class="comment">#生成网站静态文件到默认设置的 public 文件夹(hexo generate 的缩写)</span></span><br><span class="line">hexo s <span class="comment"># 启动服务器查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># hexo d # 自动生成网站静态文件，并部署到设定的仓库(hexo deploy 的缩写)</span></span><br></pre></td></tr></table></figure><h3 id="一键部署到GitHub"><a href="#一键部署到GitHub" class="headerlink" title="一键部署到GitHub"></a>一键部署到GitHub</h3><p>安装 <strong>deployer</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>打开 <strong>_config.yml</strong> 文件，加上</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/honghangzhi/honghangzhi.github.io  #你的仓库网址</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>在命令行执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">git remote add origin git@github.com:honghangzhi/honghangzhi.github.io.git</span><br><span class="line">hexo clean &amp;&amp; hexo deploy</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p>在 <a href="https://xxx.github.io/">https://xxx.github.io</a> 打开</p><h3 id="更新博客"><a href="#更新博客" class="headerlink" title="更新博客"></a>更新博客</h3><p>更新博客每次都重新<strong>部署</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>修改 <strong>_config.yml</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure><p>选择主题 - /themes/next/_config.yml - chemes</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">scheme:</span> <span class="string">Muse</span></span><br></pre></td></tr></table></figure><h3 id="更新主题"><a href="#更新主题" class="headerlink" title="更新主题"></a>更新主题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> themes/next</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="友情链接：几个热门的主题"><a href="#友情链接：几个热门的主题" class="headerlink" title="友情链接：几个热门的主题"></a>友情链接：几个热门的主题</h3><ul><li><a href="https://github.com/theme-next/hexo-theme-next">next</a></li><li><a href="http://theme-next.iissnan.com/">老版next文档</a></li><li><a href="https://github.com/litten/hexo-theme-yilia">yilia</a></li></ul><h2 id="主题美化"><a href="#主题美化" class="headerlink" title="主题美化"></a>主题美化</h2><p>两个配置文件：</p><ul><li>站点配置文件，根目录下的 <strong>_config.yml</strong> 文件</li><li>主题配置文件，\root\themes\next 下的 <strong>_config.yml</strong>  文件</li></ul><h3 id="显示文章字数和阅读时长"><a href="#显示文章字数和阅读时长" class="headerlink" title="显示文章字数和阅读时长"></a>显示文章字数和阅读时长</h3><p>在站点配置文件，根目录下的 <strong>_config.yml</strong> 文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  symbols: <span class="literal">true</span> <span class="comment"># 文章字数</span></span><br><span class="line">  time: <span class="literal">true</span> <span class="comment"># 阅读时长</span></span><br><span class="line">  total_symbols: <span class="literal">false</span> <span class="comment"># 所有文章总字数</span></span><br><span class="line">  total_time: <span class="literal">false</span> <span class="comment"># 所有文章阅读中时长</span></span><br></pre></td></tr></table></figure><p><strong>以下的设置均在主题配置文件中设置</strong></p><h3 id="设置菜单栏"><a href="#设置菜单栏" class="headerlink" title="设置菜单栏"></a>设置菜单栏</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span>                      <span class="comment">#首页</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span>       <span class="comment">#分类</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span>                 <span class="comment">#标签</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span>      <span class="comment">#归档</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span>               <span class="comment">#关于</span></span><br><span class="line">  <span class="comment"># resources: /resources/ || download   #资源</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar    #日历</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap    #站点地图，供搜索引擎爬取</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat      #腾讯公益404</span></span><br></pre></td></tr></table></figure><p>此时菜单栏并没有页面，在根目录执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br><span class="line">hexo new page &quot;tags&quot;</span><br><span class="line">hexo new page &quot;about&quot;</span><br><span class="line">hexo new page &quot;resources&quot;</span><br></pre></td></tr></table></figure><p>来生成页面，sources文件夹下会生成categories、tags、about、resources四个文件，每个文件中有一个<code>index.md</code>文件，修改内容分别如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2020-02-10 22:07:08</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2020-02-10 22:07:08</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 关于</span><br><span class="line">date: 2020-02-10 22:07:08</span><br><span class="line">type: &quot;about&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 资源</span><br><span class="line">date: 2020-02-10 22:07:08</span><br><span class="line">type: &quot;resources&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="菜单栏添加搜索框（Local-Search）"><a href="#菜单栏添加搜索框（Local-Search）" class="headerlink" title="菜单栏添加搜索框（Local Search）"></a>菜单栏添加搜索框（Local Search）</h3><p>安装插件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search</span><br></pre></td></tr></table></figure><p>主题配置文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure><h3 id="设置头像"><a href="#设置头像" class="headerlink" title="设置头像"></a>设置头像</h3><p>将图片 avatar.gif 移动到 \root\themes\next\source\images 目录下，在主题配置文件配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Sidebar Avatar</span><br><span class="line">avatar:</span><br><span class="line">  # Replace the default image and set the url here.</span><br><span class="line">  url: /images/avatar.gif   #图片的位置，也可以是http://xxx.com/avatar.png</span><br><span class="line">  # If true, the avatar will be dispalyed in circle.</span><br><span class="line">  rounded: true   #头像展示在圈里</span><br><span class="line">  # If true, the avatar will be rotated with the cursor.</span><br><span class="line">  rotated: false  #头像随光标旋转</span><br></pre></td></tr></table></figure><h3 id="社交网站链接"><a href="#社交网站链接" class="headerlink" title="社交网站链接"></a>社交网站链接</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/honghangzhi || fab fa-github</span><br></pre></td></tr></table></figure><h3 id="设置网站图标"><a href="#设置网站图标" class="headerlink" title="设置网站图标"></a>设置网站图标</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">favicon:</span><br><span class="line">  small: /images/favicon-16x16.png</span><br><span class="line">  medium: /images/favicon-32x32.png</span><br><span class="line">  apple_touch_icon: /images/apple-touch-icon-next.png</span><br><span class="line">  safari_pinned_tab: /images/logo.svg</span><br><span class="line">  #android_manifest: /images/manifest.json</span><br><span class="line">  #ms_browserconfig: /images/browserconfig.xml</span><br></pre></td></tr></table></figure><h3 id="暗夜模式-新版next主题内置"><a href="#暗夜模式-新版next主题内置" class="headerlink" title="暗夜模式 - 新版next主题内置"></a>暗夜模式 - 新版next主题内置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dark Mode</span></span><br><span class="line"><span class="attr">darkmode:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="设置博文内链接为蓝色"><a href="#设置博文内链接为蓝色" class="headerlink" title="设置博文内链接为蓝色"></a>设置博文内链接为蓝色</h3><p>在 themes/next/source/css/_common/components/post/post.styl文件中末尾加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line">     color: #0593d3;</span><br><span class="line">     border-bottom: none;</span><br><span class="line">     &amp;:hover &#123;</span><br><span class="line">       color: #0477ab;</span><br><span class="line">       text-decoration: underline;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="设置文章末尾”本文结束”标记"><a href="#设置文章末尾”本文结束”标记" class="headerlink" title="设置文章末尾”本文结束”标记"></a>设置文章末尾”本文结束”标记</h3><p>在路径 /themes/next/layout/_macro 中新建 passage-end-tag.swig 文件,并添加以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% if not is_index %&#125;</span><br><span class="line">        &lt;div style=&quot;text-align:center;color: #ccc;font-size:24px;&quot;&gt;（完）&lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>接着打开/themes/next/layout/_macro/post.swig文件，在post-footer前添加代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if not is_index and theme.passage_end_tag.enabled %&#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;% include &#x27;passage-end-tag.swig&#x27; %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><p>在主题配置文件中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure><h3 id="设置建站时间"><a href="#设置建站时间" class="headerlink" title="设置建站时间"></a>设置建站时间</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">footer:</span><br><span class="line">  # Specify the date when the site was setup. If not defined, current year will be used.</span><br><span class="line">  since: 2020-02   #建站时间</span><br></pre></td></tr></table></figure><h3 id="博文置顶"><a href="#博文置顶" class="headerlink" title="博文置顶"></a>博文置顶</h3><h4 id="（1）安装插件"><a href="#（1）安装插件" class="headerlink" title="（1）安装插件"></a>（1）安装插件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure><h4 id="（2）设置置顶标志"><a href="#（2）设置置顶标志" class="headerlink" title="（2）设置置顶标志"></a>（2）设置置顶标志</h4><p>打开blog/themes/next/layout/_macro目录下的post.swig文件，定位到 <code>&lt;div class=&quot;post-meta&quot;&gt;</code> 标签下，插入如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;font color=7D26CD&gt;置顶&lt;/font&gt;</span><br><span class="line">  &lt;span class=&quot;post-meta-divider&quot;&gt;|&lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h4 id="（3）在文章中添加top"><a href="#（3）在文章中添加top" class="headerlink" title="（3）在文章中添加top"></a>（3）在文章中添加top</h4><p>然后在需要置顶的文章的Front-matter中加上top: true即可，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">top: true</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="添加评论（使用valine）"><a href="#添加评论（使用valine）" class="headerlink" title="添加评论（使用valine）"></a>添加评论（使用valine）</h3><p>可以参考这篇<a href="https://blog.csdn.net/blue_zy/article/details/79071414?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162688580716780265414057%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162688580716780265414057&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-79071414.first_rank_v2_pc_rank_v29&utm_term=hexo+%E8%AF%84%E8%AE%BA">文章</a>，步骤</p><h4 id="（1）注册Leancloud"><a href="#（1）注册Leancloud" class="headerlink" title="（1）注册Leancloud"></a>（1）注册Leancloud</h4><p>① <a href="https://console.leancloud.cn/apps">LeanCloud</a>注册<br>② 创建应用<br>③ 应用 - 设置 - 应用凭证，复制<strong>AppID</strong>和<strong>AppKey</strong></p><h4 id="（2）修改主题配置文件"><a href="#（2）修改主题配置文件" class="headerlink" title="（2）修改主题配置文件"></a>（2）修改主题配置文件</h4><p>将复制的<strong>AppID</strong>和<strong>AppKey</strong>添加到配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">comments:</span><br><span class="line">  # Available values: tabs | buttons</span><br><span class="line">  style: tabs</span><br><span class="line">  # Choose a comment system to be displayed by default.</span><br><span class="line">  # Available values: changyan | disqus | disqusjs | gitalk | livere | valine</span><br><span class="line">  active: valine</span><br><span class="line">  </span><br><span class="line">valine:</span><br><span class="line">  enable: true</span><br><span class="line">  appid: # Your leancloud application appid</span><br><span class="line">  appkey # Your leancloud application appkey</span><br></pre></td></tr></table></figure><h3 id="添加多级分类"><a href="#添加多级分类" class="headerlink" title="添加多级分类"></a>添加多级分类</h3><p>next 内置多级分类，在</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories: </span><br><span class="line">- 父目录</span><br><span class="line">- 子目录</span><br></pre></td></tr></table></figure><p>此时查看博文将显示 <code>父目录，子目录</code></p><h4 id="设置多级分类只显示子类别"><a href="#设置多级分类只显示子类别" class="headerlink" title="设置多级分类只显示子类别"></a>设置多级分类只显示子类别</h4><p>搜索 <code>post.in</code> 将</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;%- if post.categories and post.categories.length and theme.post_meta.categories %&#125;</span><br><span class="line">  &lt;span class=&quot;post-meta-item&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;far fa-folder&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&#x27;post.in&#x27;) &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &#123;%- for cat in post.categories.toArray() %&#125;</span><br><span class="line">      &lt;span itemprop=&quot;about&quot; itemscope itemtype=&quot;http://schema.org/Thing&quot;&gt;</span><br><span class="line">        &lt;a href=&quot;&#123;&#123; url_for(cat.path) &#125;&#125;&quot; itemprop=&quot;url&quot; rel=&quot;index&quot;&gt;&lt;span itemprop=&quot;name&quot;&gt;&#123;&#123; cat.name &#125;&#125;&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">      &lt;/span&gt;</span><br><span class="line"></span><br><span class="line">      &#123;%- set cat_length = post.categories.length %&#125;</span><br><span class="line">      &#123;%- if cat_length &gt; 1 and loop.index !== cat_length %&#125;</span><br><span class="line">        &#123;&#123; __(&#x27;symbol.comma&#x27;) &#125;&#125;</span><br><span class="line">      &#123;%- endif %&#125;</span><br><span class="line">    &#123;%- endfor %&#125;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure><p>替换如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;%- if post.categories and post.categories.length and theme.post_meta.categories %&#125;</span><br><span class="line">  &lt;span class=&quot;post-meta-item&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-icon&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;far fa-folder&quot;&gt;&lt;/i&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;post-meta-item-text&quot;&gt;&#123;&#123; __(&#x27;post.in&#x27;) &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &#123;%- for cat in post.categories.toArray() %&#125;</span><br><span class="line"></span><br><span class="line">      &#123;%- if loop.last %&#125;</span><br><span class="line">        &lt;span itemprop=&quot;about&quot; itemscope itemtype=&quot;http://schema.org/Thing&quot;&gt;</span><br><span class="line">          &lt;a href=&quot;&#123;&#123; url_for(cat.path) &#125;&#125;&quot; itemprop=&quot;url&quot; rel=&quot;index&quot;&gt;&lt;span itemprop=&quot;name&quot;&gt;&#123;&#123; cat.name &#125;&#125;&lt;/span&gt;&lt;/a&gt;</span><br><span class="line">        &lt;/span&gt;</span><br><span class="line">      &#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line">      </span><br><span class="line">    &#123;%- endfor %&#125;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure><h4 id="启用fancybox：点击查看图片大图"><a href="#启用fancybox：点击查看图片大图" class="headerlink" title="启用fancybox：点击查看图片大图"></a>启用fancybox：点击查看图片大图</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fancybox: true</span><br></pre></td></tr></table></figure><h2 id="绑定个人域名"><a href="#绑定个人域名" class="headerlink" title="绑定个人域名"></a>绑定个人域名</h2><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><ul><li><p>免费域名：<a href="https://www.freenom.com/zh/index.html?lang=zh">https://www.freenom.com/zh/index.html?lang=zh</a></p></li><li><p>付费域名</p><ul><li><p>阿里云：<a href="https://wanwang.aliyun.com/">https://wanwang.aliyun.com/</a></p></li><li><p>腾讯云：<a href="https://dnspod.cloud.tencent.com/">https://dnspod.cloud.tencent.com/</a></p></li></ul></li></ul><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>TODO</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="Context-Dump-Ends"><a href="#Context-Dump-Ends" class="headerlink" title="Context Dump Ends"></a>Context Dump Ends</h3><p><a href="https://blog.csdn.net/liuarmyliu/article/details/107737361">https://blog.csdn.net/liuarmyliu/article/details/107737361</a></p><p>在<code>hexo g</code>的时候报错，因为我在文章里写了<code>&#123;&#123;&#125;&#125;</code>。</p><p><a href="https://so.csdn.net/so/search?q=hexo&spm=1001.2101.3001.7020">hexo</a> 的文章渲染使用的是 <code>Nunjucks</code> ，因为在使用<code>mathjax</code>公式，造成了<code>&#123; &#123;</code>重叠，而它会在生成文章时将那几个大括号识别成自己的语法，这样就会报错。</p><p><strong>用空格隔开就好</strong>；</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul><li><a href="https://hexo.io/docs/one-command-deployment">Hexo</a></li><li><a href="https://hexo.io/zh-cn/">Hexo中文</a></li><li><a href="https://docs.github.com/cn/pages">Github Pages</a></li></ul><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><ul><li><p><a href="https://blog.csdn.net/wapchief/article/details/54602515?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162677118916780262589207%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162677118916780262589207&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduend~default-1-54602515.pc_v2_rank_blog_default&utm_term=hexo+github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2">搭建教程</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/106060640">主题美化参考</a></p></li><li><p><a href="https://hexo.io/zh-cn/docs/configuration.html">关于写作</a></p></li><li><p><a href="https://juejin.cn/post/6844903720296120328">https://juejin.cn/post/6844903720296120328</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 写作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
