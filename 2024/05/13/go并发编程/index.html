<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":"valine","storage":true,"lazyload":false,"nav":null,"activeClass":"valine"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":10000,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="介绍golang的goroutine、channel和基本的并发编程api">
<meta property="og:type" content="article">
<meta property="og:title" content="go并发编程">
<meta property="og:url" content="http://example.com/2024/05/13/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="HZ&#39;Blog">
<meta property="og:description" content="介绍golang的goroutine、channel和基本的并发编程api">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-05-13T13:33:11.000Z">
<meta property="article:modified_time" content="2024-05-22T20:39:22.938Z">
<meta property="article:author" content="Honghangzhi">
<meta property="article:tag" content="golang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2024/05/13/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>go并发编程 | HZ'Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">HZ'Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/13/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Honghangzhi">
      <meta itemprop="description" content="不积跬步，无以千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="HZ'Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          go并发编程
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-13 21:33:11" itemprop="dateCreated datePublished" datetime="2024-05-13T21:33:11+08:00">2024-05-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-23 04:39:22" itemprop="dateModified" datetime="2024-05-23T04:39:22+08:00">2024-05-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                  <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                    <a href="/categories/%E7%BC%96%E7%A8%8B/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
                  </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2024/05/13/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2024/05/13/go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" itemprop="commentCount"></span>
    </a>
  </span>
  
  <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>8.9k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>8 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>介绍golang的goroutine、channel和基本的并发编程api</p>
<span id="more"></span>



<h1 id="goroutine和channel"><a href="#goroutine和channel" class="headerlink" title="goroutine和channel"></a>goroutine和channel</h1><h2 id="协程概念"><a href="#协程概念" class="headerlink" title="协程概念"></a>协程概念</h2><ul>
<li>进程：是应用程序的启动实例，每个进程都有独立的内存空间，不同的进程通过进程间的通信方式来通信。</li>
<li>线程：从属于进程，每个进程至少包含一个线程，线程是 CPU 调度的基本单位，多个线程之间可以共享进程的资源并通过共享内存等线程间的通信方式来通信。</li>
<li>协程：为轻量级线程，与线程相比，协程不受操作系统的调度，协程的调度器由用户应用程序提供，协程调度器按照调度策略把协程调度到线程中运行</li>
</ul>
<h2 id="goroutine"><a href="#goroutine" class="headerlink" title="goroutine"></a>goroutine</h2><p>Goroutine 是 Go 语言中的轻量级并发执行单元。与操作系统线程相比,goroutine 的<strong>创建和切换成本</strong>非常低,可以轻松地创建成千上万个 goroutine。</p>
<ol>
<li><p><strong>创建 Goroutine</strong>:</p>
<ul>
<li>可以使用 <code>go</code> 关键字来创建一个新的 goroutine。</li>
<li>新创建的 goroutine 与原有的 goroutine 并发执行,相互独立。</li>
</ul>
</li>
<li><p><strong>Goroutine 调度</strong>:</p>
<ul>
<li>Go 运行时会自动管理 goroutine 的调度,将 goroutine 分配到可用的 CPU 核心上执行。</li>
<li>Go 运行时使用 M:N 调度模型,即 M 个 OS 线程映射 N 个 goroutine。</li>
<li>当一个 goroutine 发生阻塞时,Go 运行时会自动切换到其他可运行的 goroutine,从而实现了并发执行。</li>
</ul>
</li>
<li><p><strong>Goroutine 通信</strong>:</p>
<ul>
<li>Go 语言鼓励使用通道(channel)在 goroutine 之间进行通信,而不是使用共享内存和锁。</li>
<li>通道可以在 goroutine 之间传递数据,并提供了同步和互斥的机制。</li>
</ul>
</li>
<li><p><strong>Goroutine 生命周期</strong>:</p>
<ul>
<li>当一个 goroutine 执行完毕后,它会自动退出。</li>
<li>如果主 goroutine 退出,所有其他 goroutine 也会被强制终止。</li>
<li>可以使用 <code>sync.WaitGroup</code> 等机制来等待多个 goroutine 全部执行完毕。</li>
</ul>
</li>
<li><p><strong>Goroutine 状态</strong>:</p>
<ul>
<li>Goroutine 有以下几种状态:<ul>
<li><code>Running</code>: 当前正在执行</li>
<li><code>Runnable</code>: 已就绪,等待被调度</li>
<li><code>Waiting</code>: 正在等待某个条件满足</li>
<li><code>Stopped</code>: 已经停止或退出</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Goroutine 调试</strong>:</p>
<ul>
<li>Go 语言提供了一些工具和库,可以帮助开发者调试和分析 goroutine 的执行情况,如 <code>runtime/pprof</code>、<code>net/http/pprof</code> 等。</li>
</ul>
</li>
</ol>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol>
<li><p><strong>创建 goroutine</strong>:</p>
<ul>
<li>使用 <code>go</code> 关键字启动一个新的 goroutine。</li>
<li>例如: <code>go myFunction()</code></li>
</ul>
</li>
<li><p><strong>退出goroutine</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime.Goexit()</span><br></pre></td></tr></table></figure></li>
<li><p><strong>等待 goroutine 结束</strong>:</p>
<ul>
<li>可以使用 <code>sync.WaitGroup</code> 来等待多个 goroutine 全部执行完毕。</li>
<li>示例代码:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Add(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">go</span> doWork1(&amp;wg)</span><br><span class="line">    <span class="keyword">go</span> doWork2(&amp;wg)</span><br><span class="line">    wg.Wait()</span><br><span class="line">    fmt.Println(<span class="string">&quot;All goroutines completed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork1</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="comment">// do some work</span></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doWork2</span><span class="params">(wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">    <span class="comment">// do some work</span></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>通过通道(channel)进行通信</strong>:</p>
<ul>
<li>goroutine 之间常用通道进行数据交换和同步。</li>
<li>示例代码:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> sender(ch)</span><br><span class="line">    receiver(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sender</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    ch &lt;- <span class="number">42</span></span><br><span class="line">    <span class="built_in">close</span>(ch)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">receiver</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    value := &lt;-ch</span><br><span class="line">    fmt.Println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>限制 goroutine 数量</strong>:</p>
<ul>
<li>可以使用 <code>sync.WaitGroup</code> 和 <code>buffered channel</code> 来限制并发 goroutine 的数量。</li>
<li>示例代码:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sem := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        sem &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; &lt;-sem &#125;()</span><br><span class="line">            <span class="comment">// do some work</span></span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>处理 goroutine 错误</strong>:</p>
<ul>
<li>可以使用 <code>recover()</code> 函数捕获 goroutine 中发生的 panic。</li>
<li>示例代码:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> safeFunction()</span><br><span class="line">    time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">safeFunction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r := <span class="built_in">recover</span>(); r != <span class="literal">nil</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">&quot;Recovered from:&quot;</span>, r)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">&quot;Something went wrong&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>在 Go 编程语言中,通道(channel)是一种用于在 goroutine 之间进行数据通信的机制。它们提供了一种安全和高效的方式来共享数据,并帮助实现并发编程。对于有返回值的go执行函数，需要使用channel来获取返回值。类似进程间通信，管道等。</p>
<p><strong>通道的使用场景</strong>: 通道在实现并发编程、生产者-消费者模式、扇出/扇入模式、管道等场景中非常有用。它们提供了一种安全和高效的方式来在 goroutine 之间传递数据和同步执行。</p>
<h3 id="创建和使用channel"><a href="#创建和使用channel" class="headerlink" title="创建和使用channel"></a>创建和使用channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">channel &lt;- value <span class="comment">//发送value到channel</span></span><br><span class="line">&lt;-channel <span class="comment">//接收并丢弃</span></span><br><span class="line">x := channel <span class="comment">//接收</span></span><br><span class="line">x, ok := &lt;-channel <span class="comment">//接收并检查通道是否关闭或为空</span></span><br></pre></td></tr></table></figure>

<p>channel会同步两个协程，不会出现发送时，接收协程已经死亡的情况</p>
<ul>
<li>无缓冲channel</li>
<li>有缓存channel</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">//无缓冲</span></span><br><span class="line"><span class="comment">//c := make(chan int, 3) //带缓存</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c &lt;- <span class="number">666</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">num := &lt;- c</span><br></pre></td></tr></table></figure>

<h3 id="缓冲区和阻塞"><a href="#缓冲区和阻塞" class="headerlink" title="缓冲区和阻塞"></a>缓冲区和阻塞</h3><p>Go 中的通道可以是有缓冲的,也可以是无缓冲的。缓冲区的大小决定了发送和接收操作是否会阻塞。理解缓冲区和阻塞是掌握 Go 并发编程的关键。</p>
<ol>
<li><p><strong>缓冲区</strong>:</p>
<ul>
<li>缓冲区是通道内部用于存储数据的一块内存空间。</li>
<li>当创建一个通道时,可以指定它的缓冲区大小,也就是它可以存储的最大数据量。</li>
<li>有缓冲通道:<ul>
<li>如果通道的缓冲区未满,向该通道发送数据不会阻塞。数据会先存入缓冲区。</li>
<li>如果通道的缓冲区为空,从该通道接收数据不会阻塞。它会等待直到有数据可以接收。</li>
</ul>
</li>
<li>无缓冲通道:<ul>
<li>缓冲区大小为 0,发送和接收操作都必须立即完成。</li>
<li>发送和接收操作会阻塞,直到另一端准备好进行相应的操作。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>阻塞</strong>:</p>
<ul>
<li>阻塞是指 goroutine 在执行某个操作时被暂时挂起,直到条件满足才能继续执行。</li>
<li>在通道中,发送和接收操作都可能会导致 goroutine 阻塞:<ul>
<li>向无缓冲通道发送数据时,如果没有 goroutine 准备接收,发送操作会阻塞。</li>
<li>从无缓冲通道接收数据时,如果没有 goroutine 准备发送,接收操作会阻塞。</li>
<li>向有缓冲通道发送数据时,如果缓冲区已满,发送操作会阻塞。</li>
<li>从有缓冲通道接收数据时,如果缓冲区为空,接收操作会阻塞。</li>
</ul>
</li>
<li>阻塞可以帮助 goroutine 进行有效的同步和协调,避免资源竞争。</li>
</ul>
</li>
<li><p><strong>示例</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个容量为 2 的有缓冲通道</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向通道发送 3 个数据</span></span><br><span class="line">ch &lt;- <span class="number">1</span></span><br><span class="line">ch &lt;- <span class="number">2</span></span><br><span class="line">fmt.Println(<span class="string">&quot;Sent 2 values, channel is full&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一次发送会阻塞,因为通道已满</span></span><br><span class="line">ch &lt;- <span class="number">3</span></span><br><span class="line">fmt.Println(<span class="string">&quot;This will not be printed&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从通道接收 2 个数据</span></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从空通道接收会阻塞</span></span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">fmt.Println(<span class="string">&quot;This will not be printed&quot;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><strong>使用场景:</strong><br>无缓存channel适用于数据要求同步的场景，而有缓存channel适用于无数据同步的场景。可以根据实现项目需求选择</p>
</li>
</ol>
<h3 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h3><p>可以使用 <code>close()</code> 函数关闭通道,这样可以向通道发送一个特殊的”关闭”信号。关闭后,再向该通道发送数据会导致 panic。从一个已经关闭的通道接收数据会返回通道元素类型的零值和一个 boolean 值,指示通道是否已关闭。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		c &lt;- i</span><br><span class="line">		<span class="built_in">close</span>(c)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> data,ok := &lt;-c ; ok &#123;</span><br><span class="line">		fmt.Println(data)</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭后无法发送数据，向关闭channel发送已经关闭的channel报panic错误</li>
<li>关闭后可以继续接收数据</li>
<li>向nil channel发送和接收数据导致阻塞</li>
</ul>
<h3 id="channel和range"><a href="#channel和range" class="headerlink" title="channel和range"></a>channel和range</h3><p> <code>range</code> 语句从通道中<strong>接收并迭代数据</strong>。<code>range</code> 会一直阻塞,直到通道被关闭,然后它会退出循环。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> data := <span class="keyword">range</span> c &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="channel和select"><a href="#channel和select" class="headerlink" title="channel和select"></a>channel和select</h3><p>用于管理多个channel，<code>select</code> 语句允许 Go 程同时等待<strong>多个通道</strong>的操作。它会阻塞,直到其中一个通道ready,然后执行相应的 case 语句。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> &lt;- chan1:</span><br><span class="line">			<span class="comment">//chan1读到数据执行</span></span><br><span class="line">		<span class="keyword">case</span> &lt;- chan2:</span><br><span class="line">			<span class="comment">//chan2读到数据执行</span></span><br><span class="line">		<span class="keyword">case</span> &lt;- chan3:</span><br><span class="line">			<span class="comment">//chan3读到数据执行</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="comment">//都没有读到执行</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fibonacii</span><span class="params">(c, quit <span class="keyword">chan</span> <span class="keyword">int</span>)</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	x, y := <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> c &lt;- x:</span><br><span class="line">			x = y</span><br><span class="line">			y = x + y</span><br><span class="line">		<span class="keyword">case</span> &lt;-quit:</span><br><span class="line">			fmt.Println(<span class="string">&quot;quit&quot;</span>)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	quit := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">6</span>; i++ &#123;</span><br><span class="line">			fmt.Println(&lt;-c) </span><br><span class="line">		&#125;</span><br><span class="line">			quit&lt;<span class="number">-0</span></span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    fibonacii(c, quit)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h3><p>Go 中的 channel 是由以下几个部分组成的复合数据结构:</p>
<ol>
<li><p><strong>hchan 结构体</strong>:</p>
<ul>
<li>这是 channel 的核心数据结构,定义在 <code>runtime/chan.go</code> 文件中。</li>
<li>它包含了 channel 的基本属性,如缓冲区大小、当前缓冲区内数据量、发送/接收 goroutine 的队列等。</li>
</ul>
</li>
<li><p><strong>sudog 结构体</strong>:</p>
<ul>
<li>这个结构体表示一个阻塞在 channel 上的 goroutine。</li>
<li>它包含了 goroutine 的上下文信息,如 goroutine 指针、发送/接收的值等。</li>
<li>当 goroutine 阻塞在 channel 上时,它会被封装成一个 sudog 结构体,加入到 channel 的等待队列中。</li>
</ul>
</li>
<li><p><strong>环形缓冲区</strong>:</p>
<ul>
<li>对于有缓冲的 channel,它内部维护了一个环形缓冲区,用于存储发送到 channel 但尚未被接收的数据。</li>
<li>缓冲区使用 <code>buf</code> 字段表示,它是一个指向数组的指针。</li>
<li>缓冲区中的数据通过 <code>sendx</code> 和 <code>recvx</code> 字段来跟踪当前的发送和接收位置。</li>
</ul>
</li>
<li><p><strong>互斥锁和条件变量</strong>:</p>
<ul>
<li>channel 的并发访问是通过互斥锁 <code>lock</code> 来保护的。</li>
<li>当 goroutine 阻塞在 channel 上时,它会被放入相应的条件变量 <code>sendq</code> 或 <code>recvq</code> 中等待被唤醒。</li>
</ul>
</li>
</ol>
<h3 id="channel-是否线程安全"><a href="#channel-是否线程安全" class="headerlink" title="channel 是否线程安全"></a>channel 是否线程安全</h3><p>Go 中的 channel 是通过以下几个机制来实现并发安全的:</p>
<ol>
<li><p><strong>互斥锁</strong>:</p>
<ul>
<li>每个 channel 都有一个互斥锁 <code>lock</code>，用于保护 channel 的内部状态。</li>
<li>所有对 channel 的读写操作都需要先获取这个锁，确保同一时刻只有一个 goroutine 能访问 channel 的内部数据。</li>
</ul>
</li>
<li><p><strong>原子操作</strong>:</p>
<ul>
<li>channel 的一些关键字段,如 <code>sendx</code>、<code>recvx</code>、<code>sendq.head</code>、<code>recvq.head</code> 等，都是使用原子操作来访问的。</li>
<li>这确保了即使多个 goroutine 同时访问这些字段,也不会出现数据竞争的问题。</li>
</ul>
</li>
<li><p><strong>条件变量</strong>:</p>
<ul>
<li>当 goroutine 试图向一个已满的 channel 发送数据,或从一个空的 channel 接收数据时,它们会被挂起,并加入到相应的等待队列中。</li>
<li>这些等待队列使用条件变量 <code>sendq</code> 和 <code>recvq</code> 来实现。当 channel 状态发生变化时,条件变量会负责唤醒等待的 goroutine。</li>
</ul>
</li>
<li><p><strong>Goroutine 调度</strong>:</p>
<ul>
<li>Go 运行时会负责调度 goroutine 的执行,确保阻塞在 channel 上的 goroutine 能够在条件满足时被及时唤醒。</li>
</ul>
</li>
</ol>
<p>综上所述,Go 的 channel 实现了以下并发安全特性:</p>
<ol>
<li>使用互斥锁保护 channel 的内部状态,防止数据竞争。</li>
<li>利用原子操作确保关键字段的并发访问安全。</li>
<li>通过条件变量实现 goroutine 的阻塞和唤醒,避免忙等。</li>
<li>依赖 Go 运行时的 goroutine 调度机制,确保公平性和活跃性。</li>
</ol>
<h1 id="sync"><a href="#sync" class="headerlink" title="sync"></a>sync</h1><p><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync">https://pkg.go.dev/sync</a></p>
<h2 id="Cond条件变量"><a href="#Cond条件变量" class="headerlink" title="Cond条件变量"></a>Cond条件变量</h2><p>条件变量提供了一种方法，使得一个或多个 goroutine 可以<strong>等待某个特定条件的发生，并在条件满足时被唤醒</strong>。它允许一个或多个 goroutine 在满足特定条件之前等待，避免了忙等待（busy-waiting）的问题，从而提高了系统的效率。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Cond">type Cond</a><ul>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#NewCond">func NewCond(l Locker) *Cond</a> 使用锁来初始化条件变量</li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Cond.Broadcast">func (c *Cond) Broadcast()</a> 广播，唤醒所有在等待的goroutine</li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Cond.Signal">func (c *Cond) Signal()</a> 唤醒一个在等待的goroutine（具体哪个取决于实现 先进先出）</li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Cond.Wait">func (c *Cond) Wait()</a> 尝试解锁c.Unlock，等待直到被Broadcast或Signal方法唤醒</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">	cond := sync.NewCond(&amp;mu)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 生产者</span></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">		time.Sleep(time.Second)</span><br><span class="line">		fmt.Println(<span class="string">&quot;Producer: Item produced&quot;</span>)</span><br><span class="line"></span><br><span class="line">		cond.L.Lock()</span><br><span class="line">         <span class="comment">//生产</span></span><br><span class="line">		cond.L.Unlock()</span><br><span class="line">         cond.Signal() <span class="comment">// 唤醒一个等待的 goroutine</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 消费者</span></span><br><span class="line">	wg.Add(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">		cond.L.Lock()</span><br><span class="line">		<span class="comment">//消费</span></span><br><span class="line">         cond.L.Unlock()</span><br><span class="line">		cond.Wait() <span class="comment">// 等待条件的发生</span></span><br><span class="line">		fmt.Println(<span class="string">&quot;Consumer: Item consumed&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Main goroutine: Done&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>典型场景，生产者和消费者同时持有中间结构的锁，上锁-生产者生产-解锁-唤醒消费者-上锁-消费者消费-解锁-等待</p>
<h2 id="Locker锁"><a href="#Locker锁" class="headerlink" title="Locker锁"></a>Locker锁</h2><p>锁接口</p>
<h2 id="Mutex互斥锁"><a href="#Mutex互斥锁" class="headerlink" title="Mutex互斥锁"></a>Mutex互斥锁</h2><p>实现了Locker接口</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Mutex">type Mutex</a><ul>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Mutex.Lock">func (m *Mutex) Lock()</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Mutex.TryLock">func (m *Mutex) TryLock() bool</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Mutex.Unlock">func (m *Mutex) Unlock()</a></li>
</ul>
</li>
</ul>
<p>使用场景：单读</p>
<ul>
<li>playerIds map[int]bool  只有服务器单读</li>
</ul>
<h2 id="RWMutex读写锁"><a href="#RWMutex读写锁" class="headerlink" title="RWMutex读写锁"></a>RWMutex读写锁</h2><p>实现了Locker接口</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#RWMutex">type RWMutex</a><ul>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#RWMutex.Lock">func (rw *RWMutex) Lock()</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#RWMutex.RLock">func (rw *RWMutex) RLock()</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#RWMutex.RLocker">func (rw *RWMutex) RLocker() Locker</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#RWMutex.RUnlock">func (rw *RWMutex) RUnlock()</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#RWMutex.TryLock">func (rw *RWMutex) TryLock() bool</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#RWMutex.TryRLock">func (rw *RWMutex) TryRLock() bool</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#RWMutex.Unlock">func (rw *RWMutex) Unlock()</a></li>
</ul>
</li>
</ul>
<p>使用场景：需要多读</p>
<ul>
<li>PropertyMap，多个goroutine需要获取属性</li>
</ul>
<h2 id="Map线程安全的map"><a href="#Map线程安全的map" class="headerlink" title="Map线程安全的map"></a>Map线程安全的map</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Map">type Map</a><ul>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Map.CompareAndDelete">func (m *Map) CompareAndDelete(key, old any) (deleted bool)</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Map.CompareAndSwap">func (m *Map) CompareAndSwap(key, old, new any) bool</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Map.Delete">func (m *Map) Delete(key any)</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Map.Load">func (m *Map) Load(key any) (value any, ok bool)</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Map.LoadAndDelete">func (m *Map) LoadAndDelete(key any) (value any, loaded bool)</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Map.LoadOrStore">func (m *Map) LoadOrStore(key, value any) (actual any, loaded bool)</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Map.Range">func (m *Map) Range(f func(key, value any) bool)</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Map.Store">func (m *Map) Store(key, value any)</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Map.Swap">func (m *Map) Swap(key, value any) (previous any, loaded bool)</a></li>
</ul>
</li>
</ul>
<h2 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h2><p>用于实现只执行一次的操作，确保在并发环境中某个函数只会被执行一次</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Once.Do">func (o *Once) Do(f func())</a></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 定义只执行一次的函数</span></span><br><span class="line">	initFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Initialization function executed.&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 多个 goroutine 尝试执行函数</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			once.Do(initFunc)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 阻塞主 goroutine，等待其他 goroutine 执行完毕</span></span><br><span class="line">	<span class="keyword">select</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用场景</p>
<ul>
<li>初始化操作：某些操作在程序运行期间只需要执行一次，例如初始化全局配置、建立数据库连接池、加载重要的资源等。使用 <code>sync.Once</code> 可以确保这些初始化操作只会执行一次，而不管有多少个 goroutine 尝试执行它们。</li>
<li>单例模式的创建：在某些情况下，需要确保只有一个实例被创建，如单例模式。使用 <code>sync.Once</code> 可以在多个 goroutine 中安全地创建单例实例，保证只有一个实例被创建并被共享。</li>
<li>缓存初始化：在使用缓存的场景中，可能需要在第一次使用缓存时进行初始化，例如加载磁盘上的数据到内存中。使用 <code>sync.Once</code> 可以确保只有第一个需要缓存的请求会触发初始化操作，而后续的请求会直接使用已经初始化好的缓存。</li>
<li>延迟加载：有些操作可能需要在需要时才进行，例如延迟加载配置文件、懒加载昂贵的计算结果等。使用 <code>sync.Once</code> 可以确保这些操作只会在第一次需要时执行，而后续的请求会直接使用已经加载或计算好的结果。</li>
</ul>
<h2 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h2><p>用于存储一组可保存和查询的临时对象，<strong>临时对象可能随时被自动删除，并且没有通知</strong>，可用于实现容量自适应的缓存（典型fmt维护）</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Pool">type Pool</a><ul>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Pool.Get">func (p *Pool) Get() any</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#Pool.Put">func (p *Pool) Put(x any)</a></li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;bytes&quot;</span></span><br><span class="line">	<span class="string">&quot;io&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bufPool = sync.Pool&#123;</span><br><span class="line">	New: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">any</span></span> &#123;</span><br><span class="line">		<span class="comment">// The Pool&#x27;s New function should generally only return pointer</span></span><br><span class="line">		<span class="comment">// types, since a pointer can be put into the return interface</span></span><br><span class="line">		<span class="comment">// value without an allocation:</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">new</span>(bytes.Buffer)</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// timeNow is a fake version of time.Now for tests.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeNow</span><span class="params">()</span> <span class="title">time</span>.<span class="title">Time</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> time.Unix(<span class="number">1136214245</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Log</span><span class="params">(w io.Writer, key, val <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	b := bufPool.Get().(*bytes.Buffer)</span><br><span class="line">	b.Reset()</span><br><span class="line">	<span class="comment">// Replace this with time.Now() in a real logger.</span></span><br><span class="line">	b.WriteString(timeNow().UTC().Format(time.RFC3339))</span><br><span class="line">	b.WriteByte(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">	b.WriteString(key)</span><br><span class="line">	b.WriteByte(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">	b.WriteString(val)</span><br><span class="line">	w.Write(b.Bytes())</span><br><span class="line">	bufPool.Put(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	Log(os.Stdout, <span class="string">&quot;path&quot;</span>, <span class="string">&quot;/search?q=flowers&quot;</span>)</span><br></pre></td></tr></table></figure>





<h2 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h2><p><code>sync.WaitGroup</code> 类型包含一个计数器，可以通过调用 <code>Add</code> 方法增加计数器的值，调用 <code>Done</code> 方法减少计数器的值，以及调用 <code>Wait</code> 方法来阻塞当前 goroutine，直到计数器的值变为零。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#WaitGroup">type WaitGroup</a><ul>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#WaitGroup.Add">func (wg *WaitGroup) Add(delta int)</a> 添加到等待组</li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#WaitGroup.Done">func (wg *WaitGroup) Done()</a> </li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync#WaitGroup.Wait">func (wg *WaitGroup) Wait()</a> </li>
</ul>
</li>
</ul>
<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><p><a target="_blank" rel="noopener" href="https://pkg.go.dev/context">https://pkg.go.dev/context</a></p>
<p>Go语言的<code>context</code>模块提供了一种在应用程序中传递请求范围数据、控制并发和取消操作的机制。它允许你在一个请求的整个处理过程中跟踪上下文信息，并在需要时传递和使用该信息。</p>
<p><code>context</code>模块的主要作用如下：</p>
<ol>
<li><p>传递请求范围的数据：使用<code>context.Context</code>类型，你可以将请求范围的数据附加到上下文中，并在整个调用链中传递该上下文。这对于在请求处理过程中共享<strong>请求标识、认证信息、语言首选项</strong>等非常有用。</p>
</li>
<li><p>控制并发：<code>context</code>模块提供了管理并发操作的功能。你可以使用<code>context.Context</code>来创建带有取消和超时功能的上下文。当一个上下文被取消时，所有基于该上下文的操作都会被取消，这对于避免不必要的资源消耗和提高应用程序的可靠性非常重要。</p>
</li>
<li><p>取消操作：通过使用<code>context.Context</code>，你可以方便地取消正在进行的操作。当你需要提前中止一个请求或取消一个长时间运行的操作时，可以调用上下文的<code>cancel</code>函数来取消相关的操作。</p>
</li>
<li><p>超时控制：<code>context</code>模块还提供了超时控制的功能。你可以使用<code>context.WithTimeout</code>或<code>context.WithDeadline</code>函数创建一个带有超时限制的上下文。当超过指定的时间限制时，上下文将自动取消。</p>
</li>
</ol>
<p>通过使用<code>context</code>模块，你可以更好地管理并发操作、处理请求范围的数据，并在需要时方便地取消操作。这对于构建可靠的、高效的并发应用程序非常有帮助。</p>
<h2 id="Context-应用场景"><a href="#Context-应用场景" class="headerlink" title="Context 应用场景:"></a>Context 应用场景:</h2><ul>
<li>处理超时和取消操作。</li>
<li>在 goroutine 之间传递请求范围内的数据。</li>
<li>在 API 服务器中管理请求生命周期。gin包装了类似的机制，handler的参数就是context，从中用c.Param等方法获取请求、连接等信息，回复用ctx.JSON方法。</li>
<li>在数据库操作中处理超时。gorm框架，context.WithTimeout(context.Background(), 2*time.Second)管理超时。</li>
<li>在 RPC 系统中控制请求的超时和取消。</li>
</ul>
<h2 id="模块方法"><a href="#模块方法" class="headerlink" title="模块方法"></a>模块方法</h2><ul>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/context#AfterFunc">func AfterFunc(ctx Context, f func()) (stop func() bool)</a> 在ctx完成（取消、超时）后执行<code>f</code>函数，调用返回的 stop 函数会停止 ctx 与 f 的关联</li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/context#Cause">func Cause(c Context) error</a>  返回导致上下文取消的错误</li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/context#WithCancel">func WithCancel(parent Context) (ctx Context, cancel CancelFunc)</a> 创建一个带有取消机制的上下文</li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/context#WithCancelCause">func WithCancelCause(parent Context) (ctx Context, cancel CancelCauseFunc)</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/context#WithDeadline">func WithDeadline(parent Context, d time.Time) (Context, CancelFunc)</a> 创建一个带有截止时间的上下文</li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/context#WithDeadlineCause">func WithDeadlineCause(parent Context, d time.Time, cause error) (Context, CancelFunc)</a></li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/context#WithTimeout">func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc)</a> 创建一个带有超时时间的上下文</li>
<li><a target="_blank" rel="noopener" href="https://pkg.go.dev/context#WithTimeoutCause">func WithTimeoutCause(parent Context, timeout time.Duration, cause error) (Context, CancelFunc)</a></li>
</ul>
<h2 id="示例一：管理超时"><a href="#示例一：管理超时" class="headerlink" title="示例一：管理超时"></a>示例一：管理超时</h2><p>定义一个方法等待条件变量，在ctx取消时停止等待</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	waitOnCond := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, cond *sync.Cond, conditionMet <span class="keyword">func</span>()</span> <span class="title">bool</span>) <span class="title">error</span></span> &#123;</span><br><span class="line">		<span class="comment">// AfterFunc方法，在ctx取消唤醒所有进程，停止等待</span></span><br><span class="line">		stopf := context.AfterFunc(ctx, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="comment">// We need to acquire cond.L here to be sure that the Broadcast</span></span><br><span class="line">			<span class="comment">// below won&#x27;t occur before the call to Wait, which would result</span></span><br><span class="line">			<span class="comment">// in a missed signal (and deadlock).</span></span><br><span class="line">			cond.L.Lock()</span><br><span class="line">			<span class="keyword">defer</span> cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">			<span class="comment">// If multiple goroutines are waiting on cond simultaneously,</span></span><br><span class="line">			<span class="comment">// we need to make sure we wake up exactly this one.</span></span><br><span class="line">			<span class="comment">// That means that we need to Broadcast to all of the goroutines,</span></span><br><span class="line">			<span class="comment">// which will wake them all up.</span></span><br><span class="line">			<span class="comment">//</span></span><br><span class="line">			<span class="comment">// If there are N concurrent calls to waitOnCond, each of the goroutines</span></span><br><span class="line">			<span class="comment">// will spuriously wake up O(N) other goroutines that aren&#x27;t ready yet,</span></span><br><span class="line">			<span class="comment">// so this will cause the overall CPU cost to be O(N²).</span></span><br><span class="line">			cond.Broadcast()</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">defer</span> stopf()</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Since the wakeups are using Broadcast instead of Signal, this call to</span></span><br><span class="line">		<span class="comment">// Wait may unblock due to some other goroutine&#x27;s context becoming done,</span></span><br><span class="line">		<span class="comment">// so to be sure that ctx is actually done we need to check it in a loop.</span></span><br><span class="line">		<span class="keyword">for</span> !conditionMet() &#123;</span><br><span class="line">			cond.Wait()</span><br><span class="line">			<span class="keyword">if</span> ctx.Err() != <span class="literal">nil</span> &#123;</span><br><span class="line">				<span class="keyword">return</span> ctx.Err()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cond := sync.NewCond(<span class="built_in">new</span>(sync.Mutex))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">			ctx, cancel := context.WithTimeout(context.Background(), <span class="number">1</span>*time.Millisecond)</span><br><span class="line">			<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">			cond.L.Lock()</span><br><span class="line">			<span class="keyword">defer</span> cond.L.Unlock()</span><br><span class="line"></span><br><span class="line">			err := waitOnCond(ctx, cond, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> i%<span class="number">2</span> == <span class="number">0</span> &#125;)</span><br><span class="line">			<span class="comment">// err := waitOnCond(ctx, cond, func() bool &#123; return false &#125;)</span></span><br><span class="line">			fmt.Println(err)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	wg.Wait()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="示例二：管理连接"><a href="#示例二：管理连接" class="headerlink" title="示例二：管理连接"></a>示例二：管理连接</h2><p>此示例使用 AfterFunc 定义一个从 net.Conn 读取的函数，并在取消上下文时停止读取。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	readFromConn := <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, conn net.Conn, b []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">		stopc := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">		stop := context.AfterFunc(ctx, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			conn.SetReadDeadline(time.Now())</span><br><span class="line">			<span class="built_in">close</span>(stopc)</span><br><span class="line">		&#125;)</span><br><span class="line">		n, err = conn.Read(b)</span><br><span class="line">		<span class="keyword">if</span> !stop() &#123;</span><br><span class="line">			<span class="comment">// The AfterFunc was started.</span></span><br><span class="line">			<span class="comment">// Wait for it to complete, and reset the Conn&#x27;s deadline.</span></span><br><span class="line">			&lt;-stopc</span><br><span class="line">			conn.SetReadDeadline(time.Time&#123;&#125;)</span><br><span class="line">			<span class="keyword">return</span> n, ctx.Err()</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> n, err</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	listener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:0&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> listener.Close()</span><br><span class="line"></span><br><span class="line">	conn, err := net.Dial(listener.Addr().Network(), listener.Addr().String())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">	ctx, cancel := context.WithTimeout(context.Background(), <span class="number">1</span>*time.Millisecond)</span><br><span class="line">	<span class="keyword">defer</span> cancel()</span><br><span class="line"></span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	_, err = readFromConn(ctx, conn, b)</span><br><span class="line">	fmt.Println(err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="示例三：管理错误"><a href="#示例三：管理错误" class="headerlink" title="示例三：管理错误"></a>示例三：管理错误</h2><p>此示例使用 AfterFunc 定义一个组合两个 Context 的取消信号的函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;errors&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// mergeCancel returns a context that contains the values of ctx,</span></span><br><span class="line">	<span class="comment">// and which is canceled when either ctx or cancelCtx is canceled.</span></span><br><span class="line">	mergeCancel := <span class="function"><span class="keyword">func</span><span class="params">(ctx, cancelCtx context.Context)</span> <span class="params">(context.Context, context.CancelFunc)</span></span> &#123;</span><br><span class="line">		ctx, cancel := context.WithCancelCause(ctx)</span><br><span class="line">		stop := context.AfterFunc(cancelCtx, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			cancel(context.Cause(cancelCtx))</span><br><span class="line">		&#125;)</span><br><span class="line">		<span class="keyword">return</span> ctx, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			stop()</span><br><span class="line">			cancel(context.Canceled)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx1, cancel1 := context.WithCancelCause(context.Background())</span><br><span class="line">	<span class="keyword">defer</span> cancel1(errors.New(<span class="string">&quot;ctx1 canceled&quot;</span>))</span><br><span class="line"></span><br><span class="line">	ctx2, cancel2 := context.WithCancelCause(context.Background())</span><br><span class="line"></span><br><span class="line">	mergedCtx, mergedCancel := mergeCancel(ctx1, ctx2)</span><br><span class="line">	<span class="keyword">defer</span> mergedCancel()</span><br><span class="line"></span><br><span class="line">	cancel2(errors.New(<span class="string">&quot;ctx2 canceled&quot;</span>))</span><br><span class="line">	&lt;-mergedCtx.Done()</span><br><span class="line">	fmt.Println(context.Cause(mergedCtx))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="底层结构-1"><a href="#底层结构-1" class="headerlink" title="底层结构"></a>底层结构</h2><p>Go 语言中的 <code>context</code> 包的底层实现比较简单,主要由以下几个部分组成:</p>
<ol>
<li><p><strong>context 结构体</strong>:</p>
<ul>
<li><code>context</code> 结构体是 <code>context.Context</code> 接口的核心实现。</li>
<li>它包含了以下几个关键字段:<ul>
<li><code>done chan struct&#123;&#125;</code>: 一个用于通知 context 被取消的通道。</li>
<li><code>err error</code>: 表示 context 被取消的原因。</li>
<li><code>deadline time.Time</code>: context 的截止时间。</li>
<li><code>values map[interface&#123;&#125;]interface&#123;&#125;</code>: 存储 context 相关的键值对数据。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>emptyCtx 结构体</strong>:</p>
<ul>
<li><code>emptyCtx</code> 是 <code>context.Background()</code> 和 <code>context.TODO()</code> 返回的 context 实现。</li>
<li>它是一个单例模式的结构体,没有任何状态字段。</li>
</ul>
</li>
<li><p><strong>cancelCtx 结构体</strong>:</p>
<ul>
<li><code>cancelCtx</code> 是 <code>context.WithCancel()</code> 返回的 context 实现。</li>
<li>它在 <code>context</code> 结构体的基础上增加了以下字段:<ul>
<li><code>cancel func()</code>: 取消当前 context 的函数。</li>
<li><code>children []*cancelCtx</code>: 保存该 context 的所有子 context。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>timerCtx 结构体</strong>:</p>
<ul>
<li><code>timerCtx</code> 是 <code>context.WithDeadline()</code> 和 <code>context.WithTimeout()</code> 返回的 context 实现。</li>
<li>它在 <code>cancelCtx</code> 结构体的基础上增加了以下字段:<ul>
<li><code>deadline time.Time</code>: context 的截止时间。</li>
<li><code>timer *time.Timer</code>: 用于在截止时间到达时取消 context 的定时器。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>valueCtx 结构体</strong>:</p>
<ul>
<li><code>valueCtx</code> 是 <code>context.WithValue()</code> 返回的 context 实现。</li>
<li>它在 <code>context</code> 结构体的基础上增加了以下字段:<ul>
<li><code>key, val interface&#123;&#125;</code>: 存储 context 的键值对。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>这些结构体共同构成了 <code>context</code> 包的底层实现。当使用不同的 context 创建函数时,会返回对应的结构体实例。</p>
<h1 id="atom"><a href="#atom" class="headerlink" title="atom"></a>atom</h1><p><a target="_blank" rel="noopener" href="https://pkg.go.dev/sync/atomic">https://pkg.go.dev/sync/atomic</a></p>
<p>todo</p>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="控制并发数"><a href="#控制并发数" class="headerlink" title="控制并发数"></a>控制并发数</h2><h3 id="有缓冲通道"><a href="#有缓冲通道" class="headerlink" title="有缓冲通道"></a>有缓冲通道</h3><p>根据通道中没有数据时读取操作陷入阻塞和通道已满时继续写入操作陷入阻塞的特性，正好实现控制并发数量。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    count := <span class="number">10</span>                     <span class="comment">// 最大支持并发</span></span><br><span class="line">    sum := <span class="number">100</span>                      <span class="comment">// 任务总数</span></span><br><span class="line">    wg := sync.WaitGroup&#123;&#125;          <span class="comment">//控制主协程等待所有子协程执行完之后再退出。</span></span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, count) <span class="comment">// 控制任务并发的chan</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(c)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; sum; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        c &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 作用类似于waitgroup.Add(1)</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(j <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            fmt.Println(j)</span><br><span class="line">            &lt;-c <span class="comment">// 执行完毕，释放资源</span></span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第三方库实现的协程池"><a href="#第三方库实现的协程池" class="headerlink" title="第三方库实现的协程池"></a>第三方库实现的协程池</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;github.com/Jeffail/tunny&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pool := tunny.NewFunc(<span class="number">10</span>, <span class="function"><span class="keyword">func</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">        log.Println(i)</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">defer</span> pool.Close()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">500</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> pool.Process(i)</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(time.Second * <span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="手动实现协程池"><a href="#手动实现协程池" class="headerlink" title="手动实现协程池"></a>手动实现协程池</h3><p>todo</p>
<h2 id="Mutex-有几种模式？"><a href="#Mutex-有几种模式？" class="headerlink" title="Mutex 有几种模式？"></a>Mutex 有几种模式？</h2><p><strong>1）正常模式</strong></p>
<ol>
<li>当前的mutex只有一个goruntine来获取，那么没有竞争，直接返回。</li>
<li>新的goruntine进来，如果当前mutex已经被获取了，则该goruntine进入一个先入先出的waiter队列，在mutex被释放后，waiter按照先进先出的方式获取锁。该goruntine会处于自旋状态(不挂起，继续占有cpu)。</li>
<li>新的goruntine进来，mutex处于空闲状态，将参与竞争。新来的 goroutine 有先天的优势，它们正在 CPU 中运行，可能它们的数量还不少，所以，在高并发情况下，被唤醒的 waiter 可能比较悲剧地获取不到锁，这时，它会被插入到队列的前面。如果 waiter 获取不到锁的时间超过阈值 1 毫秒，那么，这个 Mutex 就进入到了饥饿模式。</li>
</ol>
<p><strong>2）饥饿模式</strong></p>
<p>在饥饿模式下，Mutex 的拥有者将直接把锁交给队列最前面的 waiter。新来的 goroutine 不会尝试获取锁，即使看起来锁没有被持有，它也不会去抢，也不会 spin（自旋），它会乖乖地加入到等待队列的尾部。 如果拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式:</p>
<ol>
<li>此 waiter 已经是队列中的最后一个 waiter 了，没有其它的等待锁的 goroutine 了；</li>
<li>此 waiter 的等待时间小于 1 毫秒。</li>
</ol>
<h2 id="goroutine-的自旋占用资源如何解决"><a href="#goroutine-的自旋占用资源如何解决" class="headerlink" title="goroutine 的自旋占用资源如何解决"></a>goroutine 的自旋占用资源如何解决</h2><p>自旋锁是指当一个线程在获取锁的时候，如果锁已经被其他线程获取，那么该线程将循环等待，然后不断地判断是否能够被成功获取，直到获取到锁才会退出循环。</p>
<p><strong>自旋的条件如下：</strong></p>
<p>1）还没自旋超过 4 次,</p>
<p>2）多核处理器，</p>
<p>3）GOMAXPROCS &gt; 1，</p>
<p>4）p 上本地 goroutine 队列为空。</p>
<p>mutex 会让当前的 goroutine 去空转 CPU，在空转完后再次调用 CAS 方法去尝试性的占有锁资源，直到不满足自旋条件，则最终会加入到等待队列里。</p>

    </div>

    
    
    

    
      <div>
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:24px;">（完）</div>
    
</div>
      </div>
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/golang/" rel="tag"># golang</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/05/11/go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="prev" title="go数据结构">
      <i class="fa fa-chevron-left"></i> go数据结构
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/05/15/go%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/" rel="next" title="go并发编程">
      go并发编程 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#goroutine%E5%92%8Cchannel"><span class="nav-number">1.</span> <span class="nav-text">goroutine和channel</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">协程概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#goroutine"><span class="nav-number">1.2.</span> <span class="nav-text">goroutine</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">1.2.1.</span> <span class="nav-text">使用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#channel"><span class="nav-number">1.3.</span> <span class="nav-text">channel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8channel"><span class="nav-number">1.3.1.</span> <span class="nav-text">创建和使用channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E9%98%BB%E5%A1%9E"><span class="nav-number">1.3.2.</span> <span class="nav-text">缓冲区和阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B3%E9%97%ADchannel"><span class="nav-number">1.3.3.</span> <span class="nav-text">关闭channel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#channel%E5%92%8Crange"><span class="nav-number">1.3.4.</span> <span class="nav-text">channel和range</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#channel%E5%92%8Cselect"><span class="nav-number">1.3.5.</span> <span class="nav-text">channel和select</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84"><span class="nav-number">1.3.6.</span> <span class="nav-text">底层结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#channel-%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.3.7.</span> <span class="nav-text">channel 是否线程安全</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#sync"><span class="nav-number">2.</span> <span class="nav-text">sync</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Cond%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="nav-number">2.1.</span> <span class="nav-text">Cond条件变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Locker%E9%94%81"><span class="nav-number">2.2.</span> <span class="nav-text">Locker锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mutex%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">2.3.</span> <span class="nav-text">Mutex互斥锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RWMutex%E8%AF%BB%E5%86%99%E9%94%81"><span class="nav-number">2.4.</span> <span class="nav-text">RWMutex读写锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84map"><span class="nav-number">2.5.</span> <span class="nav-text">Map线程安全的map</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Once"><span class="nav-number">2.6.</span> <span class="nav-text">Once</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Pool"><span class="nav-number">2.7.</span> <span class="nav-text">Pool</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#WaitGroup"><span class="nav-number">2.8.</span> <span class="nav-text">WaitGroup</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Context"><span class="nav-number">3.</span> <span class="nav-text">Context</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Context-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.1.</span> <span class="nav-text">Context 应用场景:</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">模块方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A%E7%AE%A1%E7%90%86%E8%B6%85%E6%97%B6"><span class="nav-number">3.3.</span> <span class="nav-text">示例一：管理超时</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A%E7%AE%A1%E7%90%86%E8%BF%9E%E6%8E%A5"><span class="nav-number">3.4.</span> <span class="nav-text">示例二：管理连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%89%EF%BC%9A%E7%AE%A1%E7%90%86%E9%94%99%E8%AF%AF"><span class="nav-number">3.5.</span> <span class="nav-text">示例三：管理错误</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BA%95%E5%B1%82%E7%BB%93%E6%9E%84-1"><span class="nav-number">3.6.</span> <span class="nav-text">底层结构</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#atom"><span class="nav-number">4.</span> <span class="nav-text">atom</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98"><span class="nav-number">5.</span> <span class="nav-text">常见问题</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E6%95%B0"><span class="nav-number">5.1.</span> <span class="nav-text">控制并发数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93"><span class="nav-number">5.1.1.</span> <span class="nav-text">有缓冲通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%8F%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.1.2.</span> <span class="nav-text">第三方库实现的协程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%8D%8F%E7%A8%8B%E6%B1%A0"><span class="nav-number">5.1.3.</span> <span class="nav-text">手动实现协程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Mutex-%E6%9C%89%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%BC%8F%EF%BC%9F"><span class="nav-number">5.2.</span> <span class="nav-text">Mutex 有几种模式？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#goroutine-%E7%9A%84%E8%87%AA%E6%97%8B%E5%8D%A0%E7%94%A8%E8%B5%84%E6%BA%90%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="nav-number">5.3.</span> <span class="nav-text">goroutine 的自旋占用资源如何解决</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Honghangzhi"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Honghangzhi</p>
  <div class="site-description" itemprop="description">不积跬步，无以千里</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Honghangzhi</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'Wk2wsEFrasa9yOsstHf3YRlp-gzGzoHsz',
      appKey     : 'zKA4ww3CAjsjGZ52EFJPkpRn',
      placeholder: "欢迎交流讨论...",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
